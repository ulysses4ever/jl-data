module dag2048

using jb2048
import Base.show
export MeanNode, MaxNode, meandag, maxdag

abstract DagNode

nutrange(p::Vector{Float64}) = findfirst(p):findlast(p)
const pal = 10  # probability array length
tal = collect(Float64, [1<<i for i=1:pal])  # tiles array list

meandag = Dict{UInt64,DagNode}()
type MeanNode <: DagNode
    board::Board
    # child::Vector{DagNode}
    proba::Vector{Float64}
    height::Int

    function MeanNode(b::Board)
        global meandag::Dict{UInt64,DagNode}
        bfree = b[ifree]
        key = hash((ifrozen,goal,restricted,bfree))
        node = get(meandag, key, nothing)
        node == nothing || return node
        proba = zeros(pal)
        height = 0
        izero = find(b .== 0)  # empty cells (indices)
        nz = length(izero)
        p1 = 0.9/nz
        p2 = 0.1/nz
        for i in izero
            b[i] = 1
            c = MaxNode(copy(b))
            proba += c.proba * p1
            h = c.height + 1
            h > height && (height = h)
            b[i] = 2
            c = MaxNode(copy(b))
            proba += c.proba * p2
            h = c.height + 1
            h > height && (height = h)
            b[i] = 0
        end
        # pprec > 0 && (proba = round(proba, pprec))
        proba = round(proba, 6)
        meandag[key] = new(b, proba, height)
    end
end

maxdag = Dict{UInt64,DagNode}()
type MaxNode <: DagNode
    board::Board
    child::Vector{DagNode}
    proba::Vector{Float64}
    best::Tuple{Int,Int}
    height::Int

    function MaxNode(b::Board)
        global maxdag::Dict{UInt64,DagNode}
        bfree = b[ifree]
        key = hash((ifrozen,goal,restricted,bfree))
        node = get(maxdag, key, nothing)
        node == nothing || return node
        child = DagNode[]
        proba = zeros(pal)
        # ip = collect(Float64, 1:pal)
        best = (0,0)
        height = 0
        n = 0
        sup = maximum(bfree)
        local p::Float64
        if sup < goal
            for d = 1:4
                bs, score, moved = slide(b, d)
                if moved
                    bs[ifrozen] == b[ifrozen] || continue
                    # all(b[ifrozen] .≤ bs[ifrozen]) || continue
                    sups = maximum(bs[ifree])
                    isup = find(bs .== sups) ∩ ifree
                    sups < restricted || (sups in bs[itarget] && isup ⊆ ixtarget) || continue
                    n += 1
                    c = MeanNode(bs)
                    push!(child, c)
                    if n < 2
                        best = (n,d)
                        proba = c.proba
                        p = sum(tal .* proba)
                    else
                        cp = sum(tal .* c.proba)
                        cp > p && (p = cp; proba = c.proba; best = (n,d))
                    end
                    h = c.height
                    h > height && (height=h)
                end
            end # for d = 1:4
        end # if sup < goal
        sup > 0 && n == 0 && (proba[sup] = 1.0)
        if height > 0
            k = nutrange(proba)
            if length(k) == 1
                leaf = true
                for c in child
                    proba == c.proba || (leaf = false; break)
                end
                leaf && (height = 0)
            end
        end
        maxdag[key] = new(b, child, proba, best, height)
    end
end

# isleaf(d::DagNode) = length(d.child) == 0
isleaf(d::DagNode) = (d.height == 0)

function show(io::IO, d::DagNode)
    b = d.board
    m, n = size(b)
    print(io, "[")
    for i in 1:m
        for j in 1:n
            print(io, " ", b[i,j])
        end
        if i < m
            print(io, ";")
        else
            print(io, "]")
        end
    end
    k = nutrange(d.proba)
    p = d.proba[k]
    p = round(100*p,2)
    # isleaf(d) && print(io, " leaf")
    if isa(d, MeanNode)
        print(io, " -> proba $k$p height $(d.height)")
    else
        print(io, " -> proba $k$p best $(d.best) height $(d.height)")
    end
end

function near(k, dims)
    m, n = dims
    i, j = ind2sub(dims,k)
    u = [0, 0, 0, 0]
    if j > 1
        p = k-m
        u[1] = p
        i % m > 0 && (u[3] = p+1)
    end
    if i > 1
        u[2] = k-1
        j < n && (u[4] = k+m-1)
    end
    u
end

function compact(b::Board, area)
    dims = size(b)
    for k in area
        x = b[k]
        u = near(k, dims)
        for i in u[1:2]
            i > 0 && b[i] ≤ x && return false
        end
        for i in u[3:4]
            i > 0 && b[i] == x && return false
        end
    end
    return true
end

function corners(u, dims)
    # u = collect(Int, u)
    v = Vector{Int}()
    m, n = dims
    a, b = 1, 0
    for c in u
        b += 1
        if b < c    # new col
            if b < a + m
                push!(v, b)
                a = b
            end
            b = c
        end
        a+m ≤ b && (a += m)
    end
    b += 1
    b < a + m && push!(v, b)
    b -= 1
    if b > 0
        b += m - (b-1)%m
        b < m*n && push!(v, b)
    end
    v
end

function target(b::Board)
    dims = size(b)
    global ifrozen = find(b .≥ goal)
    global ifree = setdiff(1:prod(dims), ifrozen)
    global itarget, ixtarget, goal
    !isempty(ifrozen) && (goal =  min(8, minimum(b[ifrozen])))
    itarget = Vector{Int}()
    for k in corners(ifrozen, dims)
        for i in near(k, dims)
            if i > 0 && b[i] == goal
                push!(itarget, k)
                break
            end
        end
    end
    ixtarget = copy(itarget)
    u = sort([ifrozen;itarget])
    append!(ixtarget, corners(u, dims))
    # println(b,goal,ifrozen,itarget,ixtarget)
    nothing
end

function play!(g::Game; moves=32768, display=false)
    n = g.length
    if n < 2
        g.hist = History(128)
        record(g.hist, g.board, 0, 0)
    end
    targetbak = goal
    target(g.board)
    gf = g[ifrozen]
    while g.length < n + moves
        node = MaxNode(g.board)
        isleaf(node) && break
        c = node.child[node.best[1]]
        g.board = copy(c.board)
        g.board[ifrozen] = gf
        g.newtile = tileinsert!(g.board)
        g.length += 1
        g.depth = node.height   # hack before plotting
        display && plot(g)
        record(g)
    end
    global goal = targetbak
    g.length
end

function xplay!(g::Game; minfrozen=nothing, display=false, spot=16)
    global restricted, goal
    m, n = size(g.board)
    while g[1] < spot
        u = find(g.board .≥ goal)
        length(u) ≥ minfrozen && compact(g.board, u) && play!(g, display=display)
        λ = g.length
        jb2048.play!(g, moves=1, display=display)
        λ == g.length && break
    end
    g.length
end

function xrepartition(n::Int; minfrozen=nothing, verbose=1:0, spot=16)
    hsup = zeros(Int, 16)
    hmoves = zeros(Int, n)
    for i=1:n
        g = jb2048.initgame()
        xplay!(g, minfrozen=minfrozen, spot=spot)
        # g[1]<7 && return g
        sup = maximum(g.board)
        hsup[sup] += 1
        hmoves[i] = g.length
        if length(verbose) > 1
            v = hsup[verbose]
            println(i,": ",(g.length, 1<<sup), " -> $v ifrozen=$ifrozen")
        end
    end
    round(Int, mean(hmoves)), hsup
end

end
