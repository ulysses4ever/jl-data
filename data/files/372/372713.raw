module dag2048

using jb2048
import Base.show

abstract DagNode

meandag = Dict{Board,DagNode}()
type MeanNode <: DagNode
    board::Board
    child::Vector{DagNode}
    val::Float64
    height::Int

    function MeanNode(b::Board)
        global meandag::Dict{Board,DagNode}
        node = get(meandag, b, nothing)
        node == nothing || return node
        child = DagNode[]
        val = 0.0
        height = 0
        fc = find(b .== 0)  # free cells (indices)
        nf = length(fc)
        p1 = 0.9/nf
        p2 = 0.1/nf
        for i in fc
            b[i] = 1
            c =  MaxNode(copy(b))
            push!(child, c)
            val += c.val * p1
            h = c.height + 1
            h > height && (height = h)
            b[i] = 2
            c =  MaxNode(copy(b))
            push!(child, c)
            val += c.val * p2
            h = c.height + 1
            h > height && (height = h)
            b[i] = 0
        end
        node = new(b, child, val, height)
        meandag[b] = node
    end
end

function meantree(b::Board)
    empty!(meandag)
    empty!(maxdag)
    MeanNode(b, 1)
end

maxdag = Dict{Board,DagNode}()
type MaxNode <: DagNode
    board::Board
    child::Vector{DagNode}
    val::Float64
    best::Tuple{Int,Int}
    height::Int     # max length

    function MaxNode(b::Board)
        global maxdag::Dict{Board,DagNode}
        node = get(maxdag, b, nothing)
        node == nothing || return node
        child = DagNode[]
        val = 0.0
        best = (0, 0)
        height = 0
        i = 0
        for d = 1:4
            bs, moved, score = slide(b, d)
            if moved
                i += 1
                c = MeanNode(bs)
                push!(child, c)
                c.val > val && (val=c.val; best=(i,d))
                h = c.height
                h > height && (height=h)
            end
        end
        # i == 0 && (val = 1 << maximum(b))
        # i == 0 && (val = sum([1<<t for t in b]))
        i == 0 && (val = b[1])
        node = new(b, child, val, best, height)
        maxdag[b] = node
    end
end

function maxtree(b::Board)
    empty!(meandag)
    empty!(maxdag)
    MaxNode(b)
end

isleaf(d::DagNode) = length(d.child) == 0
function isleaf(d::DagNode, target::Int)
    d.board[1] == target || isleaf(d)
end

function show(io::IO, d::DagNode)
    b = d.board
    m, n = size(b)
    print(io, "[")
    for i in 1:m
        for j in 1:n
            print(io, " ", b[i,j])
        end
        if i < m
            print(io, ";")
        else
            print(io, "]")
        end
    end
    val = round(d.val,3)
    if length(d.child) == 0
        print(io, ", leaf -> val $val")
        return
    end
    if isa(d, MeanNode)
        print(io, " mean -> val $val, height $(d.height)")
    else
        print(io, " max -> val $val, height $(d.height), best $(d.best)")
    end
end

function play!(g::Game, moves=32768; target=-1, display=false,verbose=false)
    b = g.board
    if g.length < 2
        g.hist = jb2048.History(128)
        jb2048.append(g.hist, g.board, 0)
    end
    while g.length < moves
        verbose && println("move $(g.length)")
        node = maxdag[b]
        verbose && println(node)
        isleaf(node) && break
        c = node.child[node.best[1]]
        b = copy(c.board)
        g.newtile = tileinsert!(b)
        verbose && println("$c, new tile $(g.newtile)")
        g.length += 1
        g.board = b
        display && plot(g)
        jb2048.append(g.hist, b, g.newtile)
        b[1] == target && break
    end
    g.length
end

function repartition(b::Board, n, t=-1)
    r = Dict{Int, Int}()
    nmoves = 0
    for i=1:n
        g = Game(b)
        play!(g, target=t)
        nmoves += g.length
        sup = g.board[1]
        sup < 5 && println(g.board,i)
        # sup = g.length
        # sup = sum([1<<t for t in g.board])
        # sup = maximum(g.board)
        if haskey(r, sup)
            r[sup] += 1
        else
            r[sup] = 1
        end
    end
    div(nmoves,n), [(k,r[k]) for k in sort(collect(keys(r)))]
end

function foo()
    0
end

end
