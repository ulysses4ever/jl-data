include("config.jl")
include("genotype.jl")

module Population
using Config
using Genotype

type Type_Population
    genotypes::Array{Genotype.Type_Genotype, 1}
    most_fit::Genotype.Type_Genotype
    average_fitness::Int32
    target_expression::Array{Float32, 1}
    first_20::Bool
    to_copy_over::Array{Int32, 1}
    fitness_vals_1::Dict{Int64, Float64}
    fitness_vals_2::Dict{Int64, Float64}
    target_number::Int32

    layer_1_weights::Array{Float32, 1}
    layer_2_weights::Array{Float32, 1}
    inputs::Array{Float32, 1}
    hidden_activations::Array{Float32, 1}
    outputs::Array{Float32, 1}
    walls::Array{Float32, 1}
    fitness_ref::Array{Float32, 1}

    mutation_tracker::Array{Int32, 1}
end

function make_population(config_vals::Config.Type_Config_Values)
    genotypes::Array{Genotype.Type_Genotype, 1} = Genotype.Type_Genotype[]
    to_copy_over::Array{Int32, 1} = zeros(Int32, config_vals.births_and_deaths_per_generation)
    for i = 1:config_vals.population_size
        push!(genotypes, Genotype.make_random_genotype(config_vals))
    end

    #fitness_vals_1::Array{Float64, 1} = []
    #fitness_vals_2::Array{Float64, 1} = []
    
    #=if config_vals.use_fitness_table
        fitness_file_array = readdlm(open("out"), Int32)
        pareto_max = [0, 0]
        pareto_min = [1000, 1000]
        for i in 1:256
            if (fitness_file_array[i, 2] > pareto_max[1]) && (fitness_file_array[i, 3] > pareto_max[2])
                pareto_max = [fitness_file_array[i, 2], fitness_file_array[i, 3]]
            end
            if (fitness_file_array[i, 2] < pareto_min[1]) && (fitness_file_array[i, 3] < pareto_min[2])
                pareto_min = [fitness_file_array[i, 2], fitness_file_array[i, 3]]
            end
        end
        for i = 1:config_vals.fitness_table_size
            push!(fitness_vals_1, sqrt((fitness_file_array[i, 2] - pareto_max[1])^2 + (fitness_file_array[i, 3] - pareto_max[2])^2))
            push!(fitness_vals_2, sqrt((fitness_file_array[i, 2] - pareto_min[1])^2 + (fitness_file_array[i, 3] - pareto_min[2])^2))
        end
    end=#
    #=if config_vals.use_sim
        fitness_vals_1 = zeros(Float64, 2^config_vals.max_num_nodes)
        fitness_vals_2 = zeros(Float64, 2^config_vals.max_num_nodes)
    end=#
    target_expression::Array{Int32, 1} = []
    if config_vals.use_sim
        target_expression = config_vals.sim_expression_1
    else
        target_expression = config_vals.expression_1
    end
    
    layer_1_weights = zeros(Float32, config_vals.num_input_nn_nodes * config_vals.num_hidden_nn_nodes)
    layer_2_weights = zeros(Float32, config_vals.num_output_nn_nodes * config_vals.num_hidden_nn_nodes)
    inputs = zeros(Float32, config_vals.num_input_nn_nodes)
    hidden_activations = zeros(Float32, config_vals.num_hidden_nn_nodes)
    outputs = zeros(Float32, config_vals.num_output_nn_nodes)
    walls = [convert(Float32, 0), convert(Float32, 1), convert(Float32, 0), 
             convert(Float32, 1), convert(Float32, 0), convert(Float32, 0),
             convert(Float32, 0), convert(Float32, 1), convert(Float32, 200),
             convert(Float32, 1), convert(Float32, 0), convert(Float32, 400),]
    fitness_ref = [convert(Float32, 1)]

    mutation_tracker = zeros(Float32, config_vals.max_num_nodes + 1)

    return Type_Population(genotypes, genotypes[1], 5, target_expression, false, to_copy_over, Dict{Int64, Float64}(), 
                           Dict{Int64, Float64}(), convert(Int32, 1), layer_1_weights, layer_2_weights, inputs, hidden_activations, 
                           outputs, walls, fitness_ref, mutation_tracker)
end

function switch_target(population::Type_Population, config_vals::Config.Type_Config_Values)
    if population.target_number == 1
        population.target_number = 2
    else
        population.target_number = 1
    end
    population.first_20 = false
    for genotype in population.genotypes
        genotype.fitness = -1.0
    end
    if config_vals.use_randomised_targets
        population.target_expression = rand(0:1, config_vals.target_length)
    else
        if population.target_expression == config_vals.expression_1
            population.target_expression = config_vals.expression_2
        elseif population.target_expression == config_vals.expression_2
            population.target_expression = config_vals.expression_1
        elseif population.target_expression == config_vals.sim_expression_1
            population.target_expression = config_vals.sim_expression_2
        else
            population.target_expression = config_vals.sim_expression_1
        end
    end
    evaluate(population, 0, config_vals)
end


function evaluate(population::Type_Population, i, config_vals::Config.Type_Config_Values)
    for genotype in population.genotypes
        if population.target_number == 1
            Genotype.evaluate(genotype, config_vals, population.target_expression, population.walls, population.layer_1_weights,
                                    population.layer_2_weights, population.inputs, population.hidden_activations, population.outputs, 
                                    population.fitness_ref, population.target_number, population.fitness_vals_1, population.mutation_tracker)
        else
            Genotype.evaluate(genotype, config_vals, population.target_expression, population.walls, population.layer_1_weights,
                                    population.layer_2_weights, population.inputs, population.hidden_activations, population.outputs, 
                                    population.fitness_ref, population.target_number, population.fitness_vals_2, population.mutation_tracker)
        end
    end
    if !population.first_20
        for genotype in population.genotypes
            if genotype.fitness == 100
                population.first_20 = true
                println("first 100 ", i % config_vals.generations_per_target_switch)
                break
            end
        end
    end
end

function print_stats(population::Type_Population, config_vals::Config.Type_Config_Values, verbose::Bool) 
    average_num_nodes::Float32 = 0.0
    average_num_connections::Float32 = 0.0
    average_fitness::Float32 = 0.0
    max_fitness::Float32 = 0.0
    min_fitness::Float32 = 100000000000.0
    best = population.genotypes[1]
    for genotype in population.genotypes
        average_fitness += genotype.fitness
        average_num_nodes += genotype.num_nodes
        this_average_num_connections = 0.0
        for i = 1:genotype.num_nodes
            this_average_num_connections += genotype.used_connections[i]
        end
        this_average_num_connections /= genotype.num_nodes
        average_num_connections += this_average_num_connections
        if genotype.fitness > max_fitness
            max_fitness = genotype.fitness
            best = genotype
        end
        if genotype.fitness < min_fitness
            min_fitness = genotype.fitness
        end
    end
    average_fitness /= length(population.genotypes)
    average_num_nodes /= length(population.genotypes)
    average_num_connections /= length(population.genotypes)
    println("average fitness ", average_fitness, " max/min fitness ", max_fitness, " ", min_fitness, 
             " av num nodes ", average_num_nodes, " av num connns ", average_num_connections)
    #=for i = (config_vals.num_simulation_iterations - 1) * config_vals.max_num_nodes:length(best.activations)
        print(best.activations[i])
    end=#
    #=ccall((:simulate, "/home/david/TehzCodes/GRNEvolution/librobosim"), Void,
                      (Int32, Ptr{Float32}, Ptr{Float32}, Int32, Ptr{Int32}, Int32, Int32, Int32, 
                       Int32, Ptr{Float32}, Ptr{Float32}, Ptr{Float32}, Ptr{Float32}, Ptr{Float32}, Ptr{Float32}, Int32),
                      convert(Int32, 1000), population.walls, population.target_expression, convert(Int32, length(population.target_expression)/2), 
    best.activations[(config_vals.num_simulation_iterations * config_vals.max_num_nodes + 1):((config_vals.num_simulation_iterations + 1) * config_vals.max_num_nodes)],
                config_vals.bits_per_weight, config_vals.num_input_nn_nodes, config_vals.num_hidden_nn_nodes, 
                config_vals.num_output_nn_nodes, population.layer_1_weights, population.layer_2_weights, population.inputs, population.hidden_activations, 
                population.outputs, population.fitness_ref, convert(Int32, 1))=#
    println(best.activations[(config_vals.num_simulation_iterations * config_vals.max_num_nodes + 1):length(best.activations)])
    println("")
    if(verbose)
        #=println("parents connections ", best.parents_connections)
        println("child s connections ", best.connections)
        println("parents     weights ", best.parents_weights)
        println("child s     weights ", best.weights)
        println("parents node weights ", best.parents_node_weights)
        println("child s node weights ", best.node_weights)
        println("parents thresholds ", best.parents_thresholds)
        println("child s thresholds ", best.thresholds)
        println("parents activations")
        for i = 1:(config_vals.num_simulation_iterations + 1)
            println(best.parents_activations[((i - 1) * best.num_nodes + 1):(i * best.num_nodes)])
        end
        println("childs activations")
        for i = 1:(config_vals.num_simulation_iterations + 1)
            println(best.activations[((i - 1) * best.num_nodes + 1):(i * best.num_nodes)])
        end=#
        #=fitness_values::Array{Float64, 1} = []
        temp = Genotype.make_random_genotype(config_vals)
        for i = 1:1000
            Genotype.copy_into(temp, best)
            Genotype.mutate(temp, config_vals)
            Genotype.evaluate(temp, config_vals.expression_1, config_vals, population.fitness_vals_1)
            push!(fitness_values, temp.fitness)
        end
        fitness_values = sort(fitness_values)
        println("mutattions ", fitness_values)
        fitness_values = []
        for i = 1:1000
            Genotype.copy_into(temp, best)
            Genotype.mutate(temp, config_vals)
            Genotype.evaluate(temp, config_vals.expression_2, config_vals, population.fitness_vals_1)
            push!(fitness_values, temp.fitness)
        end
        fitness_values = sort(fitness_values)
        println("mutattions ", fitness_values)=#
        #=println("fitness ")
        for i = 1:config_vals.population_size
            print(population.genotypes[i].fitness, " ")
        end=#
    end
    return 0
end

function breed_and_exterminate(population::Type_Population, config_vals::Config.Type_Config_Values)

    if(length(population.genotypes) > config_vals.births_and_deaths_per_generation)
        for i = 1:config_vals.births_and_deaths_per_generation
            index_to_delete = 1
            lowest_fitness::Float32 = 100000000000
            for j = 1:config_vals.extermination_tournament_size
                new_index = rand(1:length(population.genotypes))
                if population.genotypes[new_index].fitness < lowest_fitness
                    index_to_delete = new_index
                    lowest_fitness = population.genotypes[new_index].fitness
                end
            end
            population.to_copy_over[i] = index_to_delete
        end
    else
        println("skipsdfsdfsdfsd")
    end
    for i = 1:config_vals.births_and_deaths_per_generation
        index_to_breed = 1
        highest_fitness::Float32 = -1
        for j = 1:config_vals.breeding_tournament_size
            new_index = rand(1:length(population.genotypes))
            if population.genotypes[new_index].fitness > highest_fitness
                index_to_breed = new_index
                highest_fitness = population.genotypes[new_index].fitness
            end
        end
        Genotype.copy_into(population.genotypes[population.to_copy_over[i]], population.genotypes[index_to_breed])
        if config_vals.use_global_mutation_rate
            Genotype.mutate_at_global_rate(population.genotypes[population.to_copy_over[i]], config_vals)
        else
            Genotype.mutate(population.genotypes[population.to_copy_over[i]], config_vals)
        end
        population.genotypes[population.to_copy_over[i]].fitness = -1.0
    end
        return 0
end

end
