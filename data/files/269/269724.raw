include("config.jl")

module Genotype
using Config

type Type_Genotype
    num_nodes::Int32
    used_connections::Array{Int32, 1}
    connection_indeces::Array{Int32, 1}
    truth_table_indeces::Array{Int32, 1}
    connections::Array{Int32, 1}
    activations::Array{Int32, 1}

    truth_table::Array{Int32, 1}
    weights::Array{Int32, 1}
    thresholds::Array{Int32, 1}
    
    fitness::Float32
    marked_for_removal::Bool
end

function make_zero(genotype::Type_Genotype)
    genotype.num_nodes = 0
    genotype.used_connections = []
    genotype.connection_indeces = []
    genotype.truth_table_indeces = []
    genotype.connections = []
    genotype.activations = []

    genotype.truth_table = []
    genotype.weights = []
    genotype.thresholds = []
    
    genotype.fitness = 0
    genotype.marked_for_removal = 0
end

function copy_into(target::Type_Genotype, destination::Type_Genotype)
    num_nodes::Int32 = genotype.num_nodes

    used_connections::Array{Int32, 1} = zeros(Int32, length(genotype.used_connections))
    for i = 1:length(genotype.used_connections)
        used_connections[i] = genotype.used_connections[i]
    end
    
    connection_indeces::Array{Int32, 1} = zeros(Int32, length(genotype.connection_indeces))
    for i = 1:length(genotype.connection_indeces)
        connection_indeces[i] = genotype.connection_indeces[i]
    end

    truth_table_indeces::Array{Int32, 1} = zeros(Int32, length(genotype.truth_table_indeces))
    for i = 1:length(genotype.truth_table_indeces)
        truth_table_indeces[i] = genotype.truth_table_indeces[i]
    end

    connections::Array{Int32, 1} = zeros(Int32, length(genotype.connections))
    for i = 1:length(genotype.connections)
        connections[i] = genotype.connections[i]
    end

    activations::Array{Int32, 1} = zeros(Int32, length(genotype.activations))
    for i = 1:length(genotype.activations)
        activations[i] = genotype.activations[i]
    end


    truth_table::Array{Int32, 1} = zeros(Int32, length(genotype.truth_table))
    for i = 1:length(genotype.truth_table)
        truth_table[i] = genotype.truth_table[i]
    end
    

    weights::Array{Int32, 1} = zeros(Int32, length(genotype.weights))
    for i = 1:length(genotype.weights)
        weights[i] = genotype.weights[i]
    end

    thresholds::Array{Int32, 1} = zeros(Int32, length(genotype.thresholds))
    for i = 1:length(genotype.thresholds)
        thresholds[i] = genotype.thresholds[i]
    end
    
    fitness::Float32 = genotype.fitness
    marked_for_removal::Bool = genotype.marked_for_removal

    return Type_Genotype(num_nodes, used_connections, connection_indeces, truth_table_indeces, connections, 
                         activations, truth_table, weights, thresholds,  fitness, marked_for_removal)
end

function make_random_genotype(config_vals::Config.Type_Config_Values)
    used_connections::Array{Int32, 1} = []
    if !config_vals.use_fixed_arrays
        used_connections = rand(config_vals.initial_min_num_connections:config_vals.initial_max_num_connections,
                                config_vals.initial_num_nodes)
    end
    connection_indeces::Array{Int32, 1} = []
    truth_table_indeces::Array{Int32, 1} = []
    if !config_vals.use_fixed_arrays
        # These indeces are meant to be exclusive of the first number and inclusive of the last
        # In the C code this will swap, due to the 0 indexing
        connection_indeces = zeros(Int32, config_vals.initial_num_nodes + 1)
        truth_table_indeces = zeros(Int32, config_vals.initial_num_nodes + 1)
        for i = 2:(config_vals.initial_num_nodes + 1)
            connection_indeces[i] = connection_indeces[i - 1] + used_connections[i - 1]
            truth_table_indeces[i] = truth_table_indeces[i - 1] + 2^used_connections[i - 1]
        end
    end
    num_nodes = config_vals.initial_num_nodes
    connections::Array{Int32, 1} = []
    if config_vals.use_fixed_arrays
        connections = zeros(Int32, config_vals.max_num_nodes * config_vals.max_num_connections)
        for i = 1:config_vals.initial_num_nodes
            for j = (i * config_vals.max_num_nodes):((i * config_vals.max_num_nodes) + 
                                                     rand(config_vals.initial_min_num_connections:config_vals.initial_max_num_connections))
                connections[j] = rand(1:config_vals.initial_num_nodes)
        end
    else
        connections = rand(1:config_vals.initial_num_nodes, 
                                            convert(Int64, connection_indeces[config_vals.initial_num_nodes + 1]))
    end
    thresholds::Array{Int32, 1} = []
    truth_table::Array{Int32, 1} = []
    weights::Array{Int32, 1} = []
    if config_vals.use_truth_table
        truth_table = rand(0:1, convert(Int64, truth_table_indeces[config_vals.initial_num_nodes + 1]))
    else
        thresholds = rand(config_vals.min_threshold:config_vals.max_threshold, convert(Int64, num_nodes))
        weights = rand(config_vals.min_weight:config_vals.max_weight, length(connections))
    end
    activations::Array{Int32, 1} = zeros(Int32, config_vals.initial_num_nodes * (config_vals.num_simulation_iterations + 1))
    # Due to behaviour of rand!, the whole activations array is randomised. Obviousely, all values not in the first row will be overwritten.
    rand!(activations, 0:1)
    return Type_Genotype(num_nodes, used_connections, connection_indeces, truth_table_indeces, connections, 
                         activations, truth_table, weights, thresholds,  0.0, false)
end

function simulate(genotype::Type_Genotype, config_vals::Config.Type_Config_Values)
    Libdl.dlopen("/home/david/TehzCodes/GRNEvolution/libboolnet")
    if config_vals.use_truth_table
        ccall((:run_network_flat, "/home/david/TehzCodes/GRNEvolution/libboolnet"), Void,
              (Int32, Int32, Ptr{Int32}, Ptr{Int32}, Ptr{Int32}, Ptr{Int32}, Ptr{Int32}),
              config_vals.num_simulation_iterations, genotype.num_nodes,
              genotype.connection_indeces, genotype.truth_table_indeces, genotype.activations,
              genotype.connections, genotype.truth_table)
    else
        ccall((:run_network_threshold, "/home/david/TehzCodes/GRNEvolution/libboolnet"), Void,
              (Int32, Int32, Ptr{Int32}, Ptr{Int32}, Ptr{Int32}, Ptr{Int32}, Ptr{Int32}),
              config_vals.num_simulation_iterations, genotype.num_nodes,
              genotype.connection_indeces, genotype.activations,
              genotype.connections, genotype.weights, genotype.thresholds)
    end
    if !isequal(genotype.activations[(genotype.num_nodes * (config_vals.num_simulation_iterations - 1) + 1):(genotype.num_nodes * config_vals.num_simulation_iterations)], genotype.activations[(genotype.num_nodes * config_vals.num_simulation_iterations + 1):(genotype.num_nodes * (config_vals.num_simulation_iterations + 1))])

        genotype.marked_for_removal = true

    end
    return 0
            
end

function evaluate(genotype::Type_Genotype, target_expression::Array{Int32, 1}, config_vals::Config.Type_Config_Values)
    if genotype.fitness == 0.0
        simulate(genotype, config_vals)
        for i = 1:length(target_expression)
            if genotype.activations[end - length(target_expression) + i] == target_expression[i]
                genotype.fitness += 1.0
            end
        end
    end
    return 0
end

function mutate(genotype::Type_Genotype, config_vals::Config.Type_Config_Values)
    genotype.fitness = 0.0
    if rand(1:100) < 100 * config_vals.mutate_dup_del_prob
        if rand(0:1) == 0
            for i = 1:rand(config_vals.min_num_dups_or_dels:config_vals.max_num_dups_or_dels)
                delete_node(genotype, config_vals)
            end
        else
            for i = 1:rand(config_vals.min_num_dups_or_dels:config_vals.max_num_dups_or_dels)
                duplicate_node(genotype, config_vals)
            end
        end
    end
    if rand(1:100) < 100 * config_vals.mutate_conn_prob
        for i = 1:rand(config_vals.min_num_conn_muts:config_vals.max_num_conn_muts)
            mutate_connection(genotype, config_vals)
        end
    end
    if rand(1:100) < 100 * config_vals.mutate_activation_prob
        for i = 1:rand(config_vals.min_num_activation_muts:config_vals.max_num_activation_muts)
            mutate_activation(genotype, config_vals)
        end
    end
    if rand(1:100) < 100 * config_vals.delete_conn_prob
        for i = 1:rand(config_vals.min_num_conn_dels:config_vals.max_num_conn_dels)
            if genotype.connection_indeces[end] > 1
                delete_connection(genotype, rand(1:genotype.connection_indeces[end]), config_vals)
            end
        end
    end
    if rand(1:100) < 100 * config_vals.add_conn_prob
        for i = 1:rand(config_vals.min_num_conn_adds:config_vals.max_num_conn_adds)
            add_connection(genotype, -1, -1, config_vals)
        end
    end
    if config_vals.use_truth_table
        if rand(1:100) < 100 * config_vals.mutate_truth_table_prob
            for i = 1:rand(config_vals.min_num_tt_muts:config_vals.max_num_tt_muts)
                mutate_truth_table(genotype, config_vals)
            end
        end
    else
        if rand(1:100) < 100 * config_vals.mutate_threshold_prob
            for i = 1:rand(config_vals.min_num_thresh_muts:config_vals.max_num_thresh_muts)
                mutate_threshold(genotype, config_vals)
            end
        end
        if rand(1:100) < 100 * config_vals.mutate_weight_prob
            for i = 1:rand(config_vals.min_num_weight_muts:config_vals.max_num_weight_muts)
                mutate_weight(genotype, config_vals)
            end
        end
    end
    return 0
end

function delete_connection(genotype::Type_Genotype, connection_index, config_vals::Config.Type_Config_Values)
    # For now the truth table is just truncated at the removed connection
    node = 0
    for index in genotype.connection_indeces
        if connection_index <= index
            break
        end
        node += 1
    end
    #println("delete connection", connection_index)
    genotype.used_connections[node] -= 1    
    for j = 1:(genotype.num_nodes + 1)
        if genotype.connection_indeces[j] >= connection_index
            genotype.connection_indeces[j] -= 1
        end
    end
    deleteat!(genotype.connections, connection_index)
    if genotype.used_connections[node] < config_vals.min_num_connections
        add_connection(genotype, node, -1, config_vals)
    end
    if config_vals.use_truth_table
        length_to_delete = ((genotype.truth_table_indeces[node + 1]) - genotype.truth_table_indeces[node])/2
        deleteat!(genotype.truth_table, (genotype.truth_table_indeces[node] + 1):(genotype.truth_table_indeces[node] + length_to_delete))
        for i = (node + 1):(genotype.num_nodes + 1)
            genotype.truth_table_indeces[i] -= length_to_delete
        end
    else
        deleteat!(genotype.weights, connection_index)
    end
    return 0
end

function add_connection(genotype::Type_Genotype, node, connect_to, config_vals::Config.Type_Config_Values)
    #println("adding connection")
    if node == -1
        node = rand(1:genotype.num_nodes)
    end
    if connect_to == -1
        connect_to = rand(1:genotype.num_nodes)
    end
    if genotype.used_connections[node] < config_vals.max_num_connections
        genotype.used_connections[node] += 1
        index = genotype.connection_indeces[node + 1] + 1
        insert!(genotype.connections, index, connect_to)
        for i = (node + 1):(genotype.num_nodes + 1)
            genotype.connection_indeces[i] += 1
        end
        if config_vals.use_truth_table
            truth_table_length = genotype.truth_table_indeces[node + 1] - genotype.truth_table_indeces[node]
            for i = 0:(truth_table_length  - 1)
                #insert!(genotype.truth_table, genotype.truth_table_indeces[node] + (2 * i) + 1, 
                #        genotype.truth_table[genotype.truth_table_indeces[node] + (2 * i) + 1]) 
                insert!(genotype.truth_table, genotype.truth_table_indeces[node] + (2 * i) + 1, 
                        rand(0:1)) 
            end
            for i = (node + 1):(genotype.num_nodes + 1)
                genotype.truth_table_indeces[i] += truth_table_length
            end
        else
            insert!(genotype.weights, index, rand(config_vals.min_weight:config_vals.max_weight))
        end
    end
    return 0
end

function delete_node(genotype::Type_Genotype, config_vals::Config.Type_Config_Values)
    if genotype.num_nodes > config_vals.min_num_nodes
        to_delete = rand(1:genotype.num_nodes)
        #println("delete node ", to_delete)
        deleteat!(genotype.activations, to_delete)
        deleteat!(genotype.activations, ((genotype.num_nodes - 1) * (config_vals.num_simulation_iterations + 1)):(genotype.num_nodes * (config_vals.num_simulation_iterations + 1) - 2))
        deleteat!(genotype.connections, (genotype.connection_indeces[to_delete] + 1):genotype.connection_indeces[to_delete + 1])
        if config_vals.use_truth_table
            deleteat!(genotype.truth_table, (genotype.truth_table_indeces[to_delete] + 1):genotype.truth_table_indeces[to_delete + 1])
            for i = (to_delete + 1):(genotype.num_nodes + 1)
                genotype.truth_table_indeces[i] -= 2 ^ genotype.used_connections[to_delete]
            end
            deleteat!(genotype.truth_table_indeces, to_delete)
        else
            deleteat!(genotype.thresholds, to_delete)
        end
        for i = (to_delete + 1):(genotype.num_nodes + 1)
            genotype.connection_indeces[i] -= genotype.used_connections[to_delete]
        end
        deleteat!(genotype.connection_indeces, to_delete)
        deleteat!(genotype.used_connections, to_delete)
        genotype.num_nodes -= 1
        connection_index = 1
        last_index = genotype.connection_indeces[genotype.num_nodes + 1]
        if genotype.connection_indeces[end] > 1
            while true
                if genotype.connections[connection_index] > to_delete
                    genotype.connections[connection_index] -= 1
                    connection_index += 1
                elseif genotype.connections[connection_index] == to_delete
                    last_index -= 1
                    delete_connection(genotype, connection_index, config_vals)
                else
                    connection_index += 1
                end
                if connection_index > last_index
                    break
                end
            end
        end
    end
    return 0
end

function duplicate_node(genotype::Type_Genotype, config_vals::Config.Type_Config_Values)
    to_duplicate = rand(1:genotype.num_nodes)
    #println("\nduplicating ", to_duplicate, "\n")
    genotype.num_nodes += 1
    push!(genotype.activations, genotype.activations[to_duplicate])
    append!(genotype.activations, zeros(Int32, config_vals.num_simulation_iterations))
    append!(genotype.connections, genotype.connections[(genotype.connection_indeces[to_duplicate] + 1):genotype.connection_indeces[to_duplicate + 1]])
    if config_vals.use_truth_table
        append!(genotype.truth_table, genotype.truth_table[(genotype.truth_table_indeces[to_duplicate] + 1):genotype.truth_table_indeces[to_duplicate + 1]])
        push!(genotype.truth_table_indeces, length(genotype.truth_table))
    else
        append!(genotype.weights, genotype.weights[(genotype.connection_indeces[to_duplicate] + 1):genotype.connection_indeces[to_duplicate + 1]])
        push!(genotype.thresholds, genotype.thresholds[to_duplicate])
    end
    push!(genotype.connection_indeces, length(genotype.connections))
    push!(genotype.used_connections, genotype.used_connections[to_duplicate])
    for i = 1:genotype.num_nodes
        for j = (genotype.connection_indeces[i] + 1):genotype.connection_indeces[i + 1]
            if genotype.connections[j] == to_duplicate
                add_connection(genotype, i, genotype.num_nodes, config_vals)
            end
        end
    end
    return 0
end

function mutate_connection(genotype::Type_Genotype, config_vals::Config.Type_Config_Values)
    #println("mutating conn")
    if genotype.connection_indeces[end] > 0
        genotype.connections[rand(1:genotype.connection_indeces[end])] = rand(1:genotype.num_nodes)
    end
    return 0
end

function mutate_threshold(genotype::Type_Genotype, config_vals::Config.Type_Config_Values)
    #println("mutating threshold")
    genotype.thresholds[rand(1:genotype.num_nodes)] = rand(config_vals.min_threshold:config_vals.max_threshold)

end

function mutate_weight(genotype::Type_Genotype, config_vals::Config.Type_Config_Values)
    #println("mutating weight")
    if(genotype.connection_indeces[end] > 1)
        genotype.weights[rand(1:genotype.connection_indeces[end])] = rand(config_vals.min_weight:config_vals.max_weight)
    end
    return 0
end

function mutate_activation(genotype::Type_Genotype, config_vals::Config.Type_Config_Values)
    #println("mutating act")
    to_mutate = rand(1:genotype.num_nodes)
    genotype.activations[to_mutate] = 1 - genotype.activations[to_mutate]
    return 0
end

function mutate_truth_table(genotype::Type_Genotype, config_vals::Config.Type_Config_Values)
    #println("mutating tt")
    to_mutate = rand(1:genotype.truth_table_indeces[end])
    genotype.truth_table[to_mutate] = 1 - genotype.truth_table[to_mutate]
    return 0
end

end

