using LightBayes


function simulate(r::Float64, n::Int)
    # Simulate Δb for H0 & H1
    #
    # generate two clusters of samples, respectively centered
    # at (r, 0) and (-r, 0), where each cluster contains n
    # samples.
    #
    # This function computes the values of Δb, respectively
    # for the following two hypotheses:
    #
    # - H0: all samples are generated by a single component
    # - H1: each cluster of samples are generated by a different
    #       component
    #
    # Prior model: θ ~ N(0, σ0^2) with σ0 = 10.0
    # Likelihood:  x ~ N(θ, σ^2) with σ = 1.0
    #

    # data
    n = 1000
    X1 = [r, 0.0] .+ rand(2, 1000)
    X2 = [-r, 0.0] .+ rand(2, 1000)

    X = hcat(X1, X2)
    @assert size(X) == (2, 2n)

    # prior
    β0 = zeros(2)
    σ0 = 10.0
    κ0 = inv(σ0^2)
    pri = IsoGaussPrior(β0, κ0)

    # likelihood model
    σ = 1.0
    g = IsoGaussModel(σ)

    # H0: single component
    pp0 = posterior(pri, g, X)
    Δb0 = logpar(pp0) - logpar(pri)

    # H1: two components:
    pp1 = posterior(pri, g, X1)
    pp2 = posterior(pri, g, X2)
    Δb1 = (logpar(pp1) - logpar(pri)) + (logpar(pp2) - logpar(pri))

    return (Δb0, Δb1)
end


# main script

n = 1000

for r in [0.0, 0.1, 0.2, 0.5, 1.0, 2.0, 5.0]
    Δb0, Δb1 = simulate(r, n)
    @printf("With r = %5.1f:  H0.Δb = %8.2f,  H1.Δb = %8.2f\n", r, Δb0, Δb1)
end
