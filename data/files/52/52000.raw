export
  newcontext, freecontext,
  load_param_file, save_param_file,
  init_problem, solve_problem, restart_problem,
  mip_init_problem, mip_solve_problem,
  set_param, get_param,
  get_number_FC_evals, get_number_GA_evals,
  get_number_H_evals, get_number_HV_evals,
  get_number_iters, get_number_cg_iters,
  get_abs_feas_error, get_rel_feas_error,
  get_abs_opt_error, get_rel_opt_error,
  get_mip_num_nodes, get_mip_num_solves,
  get_mip_abs_gap, get_mip_rel_gap,
  get_mip_incumbent_obj, get_mip_relaxation_bnd,
  get_mip_lastnode_obj, get_mip_incumbent_x

# /* -----  Creating and destroying solver objects ----- */

# /** Call KTR_new or KTR_new_puts first.  Either returns a pointer to the
#  *  solver object that is used in all other KNITRO API calls.
#  *  A new KNITRO license is acquired and held until KTR_free has been called,
#  *  or until the calling program ends.
#  *  Returns NULL on error.
#  */
# KTR_context_ptr  KNITRO_API KTR_new (void);

function newcontext()
  ptr = @ktr_ccall(new,Ptr{Void},())
  if ptr == C_NULL
    error("KNITRO: Error creating solver")
  end
  ptr
end

# /** Call KTR_new or KTR_new_puts first.  Either returns a pointer to the
#  *  solver object that is used in all other KNITRO API calls.
#  *  A new KNITRO license is acquired and held until KTR_free has been called,
#  *  or until the calling program ends.
#  *  This function also takes an argument that sets a "put string" callback
#  *  function to handle output generated by the KNITRO solver, and a pointer
#  *  for passing user-defined data.  See KTR_set_puts_callback for more
#  *  information.
#  *  Returns NULL on error.
#  */

# KTR_context_ptr  KNITRO_API KTR_new_puts (KTR_puts * const  fnPtr,
#                                           void     * const  userParams);

function newcontext_puts(f::Function, userParams=C_NULL)
  cb = cfunction(f, Cint, (Ptr{Cchar}, Ptr{Void}))
  ptr = @ktr_ccall(new,Ptr{Void},(Ptr{Void}, Ptr{Void}),
                   cb, userParams)
  if ptr == C_NULL
    error("KNITRO: Error creating solver with put-string")
  end
  ptr
end  

# /** Free all memory and release any KNITRO license acquired by calling
#  *  KTR_new or KTR_new_puts.  The address of the pointer is set to NULL
#  *  after freeing memory, to help avoid mistakes.
#  *  Returns 0 if OK, nonzero if error.
#  */
# int  KNITRO_API KTR_free (KTR_context_ptr *  kc_handle);

function freecontext(kp_env::Ptr{Void})
  if kp_env != C_NULL
    return_code = @ktr_ccall(free, Int32, (Ptr{Void},), kp_env)
    if return_code != 0
      error("KNITRO: Error freeing memory")
    end
  end
end

# /* -----  Creating and destroying solvers in high volume ----- */

# /** High volume applications construct new KNITRO instances repeatedly,
#  *  each lasting only a short time.  Special functions allow a single
#  *  license to be checked out once for a sequence of KNITRO instances.
#  *  Reusing a license saves time in the KNITRO solver, and improves the
#  *  performance of the Ziena License Manager server.
#  *
#  *  The typical calling sequence is:
#  *    ZLM_checkout_license
#  *      KTR_new_zlm
#  *        KTR_init_problem
#  *        KTR_solve (a single call, or a reverse communications loop)
#  *      KTR_free
#  *      KTR_new_zlm
#  *        KTR_init_problem
#  *        KTR_solve (a single call, or a reverse communications loop)
#  *      KTR_free
#  *      ...
#  *    ZLM_release_license
#  *
#  *  High volume functions are not available in the "student" version.
#  *  Please see the Ziena License Manager user manual for more information.
#  */

# /** Allocate memory for a license from the Ziena License Manager for high
#  *  volume KNITRO applications.  The license will be checked out the first
#  *  time KTR_new_zlm is called.  The license must be checked in later by
#  *  calling ZLM_release_license.
#  *  Returns NULL on error.
#  */
# ZLM_context_ptr  KNITRO_API ZLM_checkout_license (void);

# function checkoutlicense()
#   ptr = @zlm_ccall(checkout_license,Ptr{Void},())
#   if ptr == C_NULL
#     error("KNITRO: Error checking out license")
#   end
#   ZLMcontext(ptr)
# end

# /** Returns a pointer to the solver object that is used in all other KNITRO
#  *  API calls.  Pass the license acquired by calling ZLM_checkout_license.
#  *  This function also takes an argument that sets a "put string" callback
#  *  function to handle output generated by the KNITRO solver, and a pointer
#  *  for passing user-defined data.  See KTR_set_puts_callback for more
#  *  information.
#  *  Returns NULL on error.
#  */
# KTR_context_ptr  KNITRO_API KTR_new_zlm (KTR_puts    * const  fnPtr,
#                                          void        * const  userParams,
#                                          ZLM_context * const  pZLMcontext);

# /** Release the KNITRO license and free allocated memory.
#  *  KNITRO will set the address of the pointer to NULL after freeing
#  *  memory, to help avoid mistakes.
#  *  Returns 0 if OK, nonzero if error.
#  */
# int  KNITRO_API ZLM_release_license (ZLM_context *  pZLMcontext);

# function releaselicense(zc::ZLMcontext)
#   if zc.context != C_NULL
#     return_code = @ktr_ccall(free, Int32, (Ptr{Void},), zc.context)
#     if return_code != 0
#       error("KNITRO: Error releasing license and freeing memory")
#     end
#     zc.context = C_NULL
#   end
# end

# /* ----- Changing and reading solver parameters ----- */

# /** Parameters cannot be set after KNITRO begins solving; ie, after
#  *  the KTR_solve function is called.  They may be set again after
#  *  calling KTR_restart.
#  *    All methods return 0 if OK, nonzero if there was an error.
#  *  In most cases, parameter values are not validated until
#  *  KTR_init_problem or KTR_solve is called.
#  */

# /** Reset all parameters to default values.
#  */
# int  KNITRO_API KTR_reset_params_to_defaults (KTR_context_ptr  kc);

function reset_params_to_defaults(kp::KnitroProblem)
  return_code = @ktr_ccall(reset_params_to_defaults, Int32, (Ptr{Void},), kp.env)
  if return_code != 0
    error("KNITRO: Error resetting parameters")
  end
end

# /** Set all parameters specified in the given file. */
# int  KNITRO_API KTR_load_param_file
#     (KTR_context_ptr  kc, const char * const  filename);

function load_param_file(kp::KnitroProblem, filename::String)
  return_code = @ktr_ccall(load_param_file, Int32,
                           (Ptr{Void},Ptr{Cchar}),
                           kp.env, filename)
  if return_code != 0
    error("KNITRO: Error loading parameters from $(filename)")
  end
end

# /** Write all current parameter values to a file. */
# int  KNITRO_API KTR_save_param_file
#     (KTR_context_ptr  kc, const char * const  filename);

function save_param_file(kp::KnitroProblem, filename::String)
  return_code = @ktr_ccall(save_param_file, Int32, (Ptr{Void},Ptr{Cchar}),
                           kp.env, filename)
  if return_code != 0
    error("KNITRO: Error writing parameters to $(filename)")
  end
end

# /** Set a parameter using its string name. */
# int  KNITRO_API KTR_set_int_param_by_name
#     (KTR_context_ptr  kc, const char * const  name, const int  value);

function set_param(kp::KnitroProblem, name::String, value::Int32)
  return_code = @ktr_ccall(set_int_param_by_name, Int32, (Ptr{Void},Ptr{Cchar},Cint),
                           kp.env, name, value)
  if return_code != 0
    error("KNITRO: Error setting int parameter by name")
  end
end

# int  KNITRO_API KTR_set_char_param_by_name
#     (KTR_context_ptr  kc, const char * const  name, const char * const  value);
function set_param(kp::KnitroProblem, name::String, value::String)
  return_code = @ktr_ccall(set_char_param_by_name, Int32, (Ptr{Void},Ptr{Cchar},Ptr{Cchar}),
                           kp.env, name, value)
  if return_code != 0
    error("KNITRO: Error setting char parameter by name")
  end
end

# int  KNITRO_API KTR_set_double_param_by_name
#     (KTR_context_ptr  kc, const char * const  name, const double  value);
function set_param(kp::KnitroProblem, name::String, value::Float64)
  return_code = @ktr_ccall(set_char_param_by_name, Int32, (Ptr{Void},Ptr{Cchar},Cdouble),
                           kp.env, name, value)
  if return_code != 0
    error("KNITRO: Error setting float parameter by name")
  end
end

# /** Set a parameter using its integer identifier KTR_PARAM_x (defined below). */
# int  KNITRO_API KTR_set_int_param
#     (KTR_context_ptr  kc, const int  param_id, const int  value);
function set_param(kp::KnitroProblem, id::Int32, value::Int32)
  return_code = @ktr_ccall(set_int_param, Int32, (Ptr{Void},Cint,Cint),
                           kp.env, id, value)
  if return_code != 0
    error("KNITRO: Error setting int parameter by id")
  end
end

# int  KNITRO_API KTR_set_char_param
#     (KTR_context_ptr  kc, const int  param_id, const char * const  value);
function set_param(kp::KnitroProblem, id::Int32, value::String)
  return_code = @ktr_ccall(set_char_param, Int32, (Ptr{Void},Cint,Ptr{Cchar}),
                           kp.env, id, value)
  if return_code != 0
    error("KNITRO: Error setting char parameter by id")
  end
end

# int  KNITRO_API KTR_set_double_param
#     (KTR_context_ptr  kc, const int  param_id, const double  value);
function set_param(kp::KnitroProblem, id::Int32, value::Float64)
  return_code = @ktr_ccall(set_double_param, Int32, (Ptr{Void},Cint,Cdouble),
                           kp.env, id, value)
  if return_code != 0
    error("KNITRO: Error setting float parameter by id")
  end
end

# /** Get a parameter using its string name. */
# int  KNITRO_API KTR_get_int_param_by_name
#     (KTR_context_ptr  kc, const char * const  name, int * const  value);

function get_param(kp::KnitroProblem,
                  name::String,
                  value::Vector{Int32})
  @ktr_ccall(get_int_param_by_name, Int32, (Ptr{Void}, Ptr{Cchar}, Ptr{Cint}),
             kp.env, name, value)
end

# int  KNITRO_API KTR_get_double_param_by_name
#     (KTR_context_ptr  kc, const char * const  name, double * const  value);

function get_param(kp::KnitroProblem,
                  name::String,
                  value::Vector{Float64})
  @ktr_ccall(get_double_param_by_name, Int32, (Ptr{Void}, Ptr{Cchar}, Ptr{Cdouble}),
             kp.env, name, value)
end

# /** Get a parameter using its integer identifier KTR_PARAM_x (defined below). */
# int  KNITRO_API KTR_get_int_param
#     (KTR_context_ptr  kc, const int  param_id, int * const  value);

function get_param(kp::KnitroProblem,
                  id::Int32,
                  value::Vector{Int32})
  @ktr_ccall(get_double_param_by_name, Int32, (Ptr{Void}, Cint, Ptr{Cint}),
             kp.env, id, value)
end

# int  KNITRO_API KTR_get_double_param
#     (KTR_context_ptr  kc, const int  param_id, double * const  value);

function get_param(kp::KnitroProblem,
                  id::Int32,
                  value::Vector{Float64})
  @ktr_ccall(get_double_param, Int32, (Ptr{Void}, Cint, Ptr{Cdouble}),
             kp.env, id, value)
end

# /** Similar to KTR_load_param_file but specifically allows user to
#  *  specify a file of options (and option values) to explore for
#  *  the KNITRO-Tuner.
#  */
# int  KNITRO_API KTR_load_tuner_file
#     (KTR_context_ptr  kc, const char * const  filename);

function load_tuner_file(kp::KnitroProblem,
                         filename::String)
  return_code = @ktr_ccall(load_tuner_file, Int32, (Ptr{Void}, Ptr{Cchar}),
                           kp.env, filename)
  if return_code != 0
    error("KNITRO: Error loading tuner file")
  end
end

# /** Copy the KNITRO release name into "release".  This variable must be
#  *  preallocated to have "length" elements, including the string termination
#  *  character.  For compatibility with future releases, please allocate at
#  *  least 15 characters. */
# void  KNITRO_API KTR_get_release
#     (const int  length, char * const  release);

function get_release(kp::KnitroProblem,
                     release::String)
  @ktr_ccall(get_release, Any, (Ptr{Void}, Ptr{Cchar}),
             kp.env, release)
end

# /** Set an array of absolute feasibility tolerances (one for each
#  *  constraint and variable) to use for the termination tests.
#  *  The user options KTR_PARAM_FEASTOL/KTR_PARAM_FEASTOLABS define
#  *  a single tolerance that is applied equally to every constraint
#  *  and variable.  This API function allows the user to specify
#  *  separate feasibility termination tolerances for each constraint
#  *  and variable.  Values specified through this function will override
#  *  the value determined by KTR_PARAM_FEASTOL/KTR_PARAM_FEASTOLABS. The
#  *  tolerances should be positive values.  If a non-positive value is
#  *  specified, that constraint or variable will use the standard tolerances
#  *  based on  KTR_PARAM_FEASTOL/KTR_PARAM_FEASTOLABS.
#  *  Array cFeasTols has length m, array xFeasTols has length n, and
#  *  array ccFeasTols has length ncc, where ncc is the number of
#  *  complementarity constraints added through KTR_addcompcons().
#  *  The regular constraints are considered to be satisfied when
#  *      c[i] - cUpBnds[i] <= cFeasTols[i]  for all i=1..m, and
#  *      cLoBnds[i] - c[i] <= cFeasTols[i]  for all i=1..m
#  *  The variables are considered to be satisfied when
#  *      x[i] - xUpBnds[i] <= xFeasTols[i]  for all i=1..n, and
#  *      xLoBnds[i] - x[i] <= xFeasTols[i]  for all i=1..n
#  *  The complementarity constraints are considered to be satisfied when
#  *      min(x1_i, x2_i) <= ccFeasTols[i]  for all i=1..ncc,
#  *  where x1 and x2 are the arrays of complementary pairs.
#  *  If there are no regular (or complementarity) constraints set
#  *  cFeasTols=NULL (or ccFeasTols=NULL).  If
#  *  cFeasTols/xFeasTols/ccFeasTols=NULL, then the standard tolerances will
#  *  be used.  KNITRO makes a local copy of all inputs, so the application
#  *  may free memory after the call.
#  *  This routine must be called after calling KTR_init_problem /
#  *  KTR_mip_init_problem and after any calls to KTR_addcompcons.  It
#  *  must be called before calling KTR_solve / KTR_mip_solve.
#  *  Returns 0 if OK, nonzero if error.
#  */
# int  KNITRO_API KTR_set_feastols
#     (      KTR_context_ptr kc,
#      const double * const  cFeasTols,
#      const double * const  xFeasTols,
#      const double * const  ccFeasTols);

function set_feastols(kp::KnitroProblem, c_tol::Vector{Float64}, x_tol::Vector{Float64},
                     cc_tol::Vector{Float64})
  return_code = @ktr_ccall(set_feastols, Int32, (Ptr{Void}, Ptr{Cdouble}, Ptr{Cdouble},
                           Ptr{Cdouble}), kp.env, c_tol, x_tol, cc_tol)
  if return_code != 0
    error("KNITRO: Error setting feasibility tolerances")
  end
end

#  /** Set names for model components passed in by the user/modeling
#   *  language so that KNITRO can internally print out these names.
#   *  KNITRO makes a local copy of all inputs, so the application may
#   *  free memory after the call.
#   *  This routine must be called after calling KTR_init_problem /
#   *  KTR_mip_init_problem and before calling KTR_solve / KTR_mip_solve.
#   *  Returns 0 if OK, nonzero if error.
#   */
# int  KNITRO_API KTR_set_names
#     (      KTR_context_ptr kc,
#      const char   * const  objName,
#            char   * const  varNames[],
#            char   * const  conNames[]);

function set_names(kp::KnitroProblem, objName::String, varNames::Vector{String},
                   conNames::Vector{String})
  return_code = @ktr_ccall(set_names, Int32, (Ptr{Void}, Ptr{Cchar},
                           Ptr{Ptr{Cchar}}, Ptr{Ptr{Cchar}}),
                           kp.env, objName, varNames, conNames)
  if return_code != 0
    error("KNITRO: Error setting names for model components")
  end
end

# /* ----- Problem modification ----- */

# /** This function adds complementarity constraints to the problem.
#  *  It must be called after KTR_init_problem and before KTR_solve.
#  *  The two lists are of equal length, and contain matching pairs of
#  *  variable indices.  Each pair defines a complementarity constraint
#  *  between the two variables.  The function can be called more than once
#  *  to accumulate a long list of complementarity constraints in KNITRO's
#  *  internal problem definition.
#  *
#  *  Returns 0 if OK, or a negative value on error.
#  */
# int  KNITRO_API KTR_addcompcons (KTR_context_ptr    kc,
#                                  const int          numCompConstraints,
#                                  const int * const  indexList1,
#                                  const int * const  indexList2);

function add_contraints(kp::KnitroProblem,
                        ncons::Int32,
                        index1::Vector{Int32},
                        index2::Vector{Int32})
  return_code = @ktr_ccall(add_compcons, Int32, (Ptr{Void},Cint,Ptr{Cint},
                           Ptr{Cint}), kp.env,ncons,index1,index2)
  if return_code != 0
    error("KNITRO: Error adding complementary constraints")
  end
end

# /** Prepare KNITRO to re-optimize the current problem after
#  *  modifying the variable bounds from a previous solve.
#  *  It must be called after KTR_init_problem and precedes a call
#  *  to KTR_solve.
#  *  Returns 0 if OK, nonzero if error.
#  */
# int  KNITRO_API KTR_chgvarbnds (      KTR_context_ptr          kc,
#                                 const double          * const  xLoBnds,
#                                 const double          * const  xUpBnds);

function chgvarbnds(kp::KnitroProblem,
                    x_L::Vector{Float64},
                    x_U::Vector{Float64})
  return_code = @ktr_ccall(add_compcons, Int32, (Ptr{Void},Ptr{Cdouble},
                           Ptr{Cdouble}), kp.env, x_L, x_U)
  if return_code != 0
    error("KNITRO: Error modifying variable bounds")
  end
end

# /* ----- Solving ----- */

# /** Problem structure is passed to KNITRO using KTR_init_problem.
#  *    The problem is solved by calling KTR_solve.  Applications must
#  *  provide a means of evaluating the nonlinear objective, constraints,
#  *  first derivatives, and (optionally) second derivatives.  (First
#  *  derivatives are also optional, but highly recommended.)
#  *    If the application provides callback functions for making evaluations
#  *  (see KTR_callback below), then a single call to KTR_solve will return
#  *  the solution.  Alternatively, the application can employ a reverse
#  *  communications driver.  In this case, KTR_solve returns a status code
#  *  whenever it needs evaluation data (see examples/C/reverseCommExample.c).
#  *
#  *  The typical calling sequence is:
#  *    KTR_new
#  *    KTR_init_problem
#  *    KTR_set_xxx_param (set any number of parameters)
#  *    KTR_solve (a single call, or a reverse communications loop)
#  *    KTR_free
#  *
#  *  Calling sequence if the same problem is to be solved again,
#  *  with different parameters or a different start point:
#  *    KTR_new
#  *    KTR_init_problem
#  *    KTR_set_xxx_param (set any number of parameters)
#  *    KTR_solve (a single call, or a reverse communications loop)
#  *    KTR_restart
#  *    KTR_set_xxx_param (set any number of parameters)
#  *    KTR_solve (a single call, or a reverse communications loop)
#  *    KTR_free
#  *
#  *  For MIP problems, use KTR_mip_init_problem and KTR_mip_solve
#  *  instead of KTR_init_problem and KTR_solve. 
#  */

# /** Initialize KNITRO with a new problem.  KNITRO makes a local copy of
#  *  all inputs, so the application may free memory after the call
#  *  completes.  Arrays cannot be NULL, except as follows:
#  *  - If "xLoBnds" or "xUpBnds" are NULL, then KNITRO assumes all variables
#  *    are unbounded in that direction.
#  *  - If the application does not supply an exact Hessian, then pass nnzH=0
#  *    and NULL pointers for "hessIndexRows" and "hessIndexCols".
#  *  - If "xInitial" or "lambdaInitial" are NULL, then KNITRO determines the
#  *    initial start point.
#  *  If a particular bound does not exist, then load the array element
#  *  with KTR_INFBOUND for an upper bound, or -KTR_INFBOUND for a lower bound.
#  *  KNITRO interprets this value as infinity and ignores the bound.
#  *    To make the j-th constraint be an equality constraint, set cLoBnds[j]
#  *  equal to cUpBnds[j].
#  *
#  *  Returns 0 if OK, nonzero if error.
#  *
#  *  Brief description of the arguments (consult the KNITRO manual for details):
#  *    n             - number of unknowns
#  *    objGoal       - objective goal (KTR_OBJGOAL_MINIMIZE or _MAXIMIZE)
#  *    objType       - objective type (eg, KTR_OBJTYPE_GENERAL)
#  *    xLoBnds       - (length n) lower bounds on the variables
#  *    xUpBnds       - (length n) upper bounds on the variables
#  *    m             - number of constraints
#  *    cType         - (length m) constraint type (eg, KTR_CONTYPE_GENERAL)
#  *    cLoBnds       - (length m) lower bounds on the constraints
#  *    cUpBnds       - (length m) upper bounds on the constraints
#  *    nnzJ          - number of nonzeroes in the sparse constraint Jacobian
#  *    jacIndexVars  - (length nnzJ) variable index (column) of each nonzero
#  *    jacIndexCons  - (length nnzJ) constraint index (row) of each nonzero
#  *    nnzH          - number of nonzeroes in the sparse Hessian of Lagrangian
#  *    hessIndexRows - (length nnzH) row index of each nonzero
#  *    hessIndexCols - (length nnzH) column index of each nonzero
#  *    xInitial      - (length n) initial start point for the unknowns
#  *    lambdaInitial - (length m+n) initial start point for multipliers
#  */
# int  KNITRO_API KTR_init_problem (KTR_context_ptr       kc,
#                                   const int             n,
#                                   const int             objGoal,
#                                   const int             objType,
#                                   const double * const  xLoBnds,
#                                   const double * const  xUpBnds,
#                                   const int             m,
#                                   const int    * const  cType,
#                                   const double * const  cLoBnds,
#                                   const double * const  cUpBnds,
#                                   const int             nnzJ,
#                                   const int    * const  jacIndexVars,
#                                   const int    * const  jacIndexCons,
#                                   const int             nnzH,
#                                   const int    * const  hessIndexRows,
#                                   const int    * const  hessIndexCols,
#                                   const double * const  xInitial,
#                                   const double * const  lambdaInitial);

function init_problem(kp::KnitroProblem,
                      objGoal::Int32,
                      objType::Int32,
                      x_L::Vector{Float64},
                      x_U::Vector{Float64},
                      c_Type::Vector{Int32},
                      c_L::Vector{Float64},
                      c_U::Vector{Float64},
                      jac_var::Vector{Int32},
                      jac_cons::Vector{Int32},
                      hess_rows::Vector{Int32},
                      hess_cols::Vector{Int32};
                      initial_x = C_NULL,
                      initial_lambda = C_NULL)
  n = length(x_L)
  m = length(c_Type)
  nnzJ = length(jac_var)
  nnzH = length(hess_rows)
  return_code = @ktr_ccall(init_problem, Int32, (Ptr{Void},Int32,Int32,Int32,
                           Ptr{Cdouble},Ptr{Cdouble},Int32,Ptr{Int32},
                           Ptr{Cdouble},Ptr{Cdouble},Int32,Ptr{Int32},
                           Ptr{Int32},Int32,Ptr{Int32},Ptr{Int32}, Ptr{Void},
                           Ptr{Void}), kp.env, n, objGoal, objType,
                           x_L, x_U, m, c_Type, c_L, c_U, nnzJ, jac_var,
                           jac_cons, nnzH, hess_rows, hess_cols,
                           initial_x, initial_lambda)
  if return_code != 0
    error("KNITRO: Error initializing problem")
  end
end
        
# /** Call KNITRO to solve the problem.  If the application provides callback
#  *  functions for evaluating the function, constraints, and derivatives,
#  *  then a single call to KTR_solve returns the solution.  Otherwise,
#  *  KNITRO operates in reverse communications mode and returns a status code
#  *  that may request another call.  See the KNITRO manual for details.
#  *
#  *  Returns one of the status codes KTR_RC_* (see definitions in this file).
#  *  In particular:
#  *    <0 - KNITRO terminated with a fatal error
#  *     0 - KNITRO is finished: x, lambda, and obj contain the optimal solution
#  *     1 - call KTR_solve again (reverse comm) with obj and c containing
#  *         the objective and constraints evaluated at x
#  *     2 - call KTR_solve again (reverse comm) with objGrad and jac containing
#  *         the objective and constraint first derivatives evaluated at x
#  *     3 - call KTR_solve again (reverse comm) with hess containing
#  *         H(x,lambda), the Hessian of the Lagrangian evaluated at x and lambda
#  *     7 - call KTR_solve again (reverse comm) with hessVector containing
#  *         the result of H(x,lambda) * hessVector
#  *
#  *  Brief description of the arguments (consult the KNITRO manual for details):
#  *    x          - output (length n) solution point estimate
#  *    lambda     - output (length m+n) Lagrange multiplier estimate
#  *    evalStatus - input  evaluation status (0=OK)
#  *    obj        - input  (length 1) objective at x
#  *                 output            optimal objective when finished
#  *    c          - input  (length m) constraints at x
#  *    objGrad    - input  (length n) objective gradient at x
#  *    jac        - input  (length nnzJ) sparse constraint gradient at x
#  *    hess       - input  (length nnzH) sparse Hessian at x and lambda
#  *    hessVector - input  (length n) result of H(x,lambda) * hessVector
#  *                 output            vector to multiply Hessian by
#  *    userParams - input  passed directly to application callback functions
#  *
#  *  If "gradopt" is set to compute finite differences for first derivatives,
#  *  then KTR_solve will modify objGrad and jac; otherwise, these arguments
#  *  are not modified.
#  */
# int  KNITRO_API KTR_solve ( KTR_context_ptr      kc,
#                                  double * const  x,
#                                  double * const  lambda,
#                            const int             evalStatus,
#                                  double * const  obj,
#                            const double * const  c,
#                                  double * const  objGrad,
#                                  double * const  jac,
#                            const double * const  hess,
#                                  double * const  hessVector,
#                                  void   * const  userParams);

function solve_problem(kp::KnitroProblem, x::Vector{Float64}, lambda::Vector{Float64},
                       evalStatus::Int32, obj::Vector{Float64}, cons::Vector{Float64},
                       objGrad::Vector{Float64}, jac::Vector{Float64}, hess::Vector{Float64},
                       hessVector::Vector{Float64})
  return_code = @ktr_ccall(solve, Int32, (Ptr{Void},Ptr{Cdouble},Ptr{Cdouble},
                           Int32,Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble},
                           Ptr{Cdouble},Ptr{Cdouble}, Any), kp.env, x, lambda, evalStatus,
                           obj, cons, objGrad, jac, hess, hessVector, kp)
  if return_code < 0
    error("KNITRO: Error solving problem")
  end
  return_code
end

function solve_problem(kp::KnitroProblem, x::Vector{Float64}, lambda::Vector{Float64},
                       evalStatus::Int32, obj::Vector{Float64})
  # For callback mode
  return_code = @ktr_ccall(solve, Int32, (Ptr{Void},Ptr{Cdouble},Ptr{Cdouble},
                           Int32,Ptr{Cdouble},Ptr{Void},Ptr{Void},Ptr{Void},
                           Ptr{Void},Ptr{Void}, Any), kp.env, x, lambda, evalStatus,
                           obj, C_NULL, C_NULL, C_NULL, C_NULL, C_NULL, kp)
  if return_code < 0
    error("KNITRO: Error solving problem (in callback mode")
  end
  return_code
end

# /** Prepare KNITRO to restart the current problem at a new start point.
#  *  If output to a file is enabled, this will erase the current file.
#  *  KNITRO parameter values are not changed by this call.
#  *  Returns 0 if OK, nonzero if error.
#  */
# int  KNITRO_API KTR_restart (KTR_context_ptr       kc,
#                              const double * const  xInitial,
#                              const double * const  lambdaInitial);

function restart_problem(kp::KnitroProblem, x_0::Vector{Cdouble}, lambda_0::Vector{Cdouble})
  return_code = @ktr_ccall(restart, Int32, (Ptr{Void},Ptr{Cdouble},Ptr{Cdouble}),
                           kp.env, x_0, lambda_0)
  if return_code != 0
    error("KNITRO: Error restarting problem")
  end
end

# /** For MIP problems, use KTR_mip_init_problem and KTR_mip_solve
#  *  instead of KTR_init_problem and KTR_solve. 
#  */
    
# /** Initialize KNITRO with a new MIP problem.  KNITRO makes a local copy of
#  *  all inputs, so the application may free memory after the call
#  *  completes.  Arrays cannot be NULL, except as follows:
#  *  - If "xLoBnds" or "xUpBnds" are NULL, then KNITRO assumes all continuous
#  *    variables are unbounded in that direction.
#  *  - If "yLoBnds" or "yUpBnds" are NULL, then KNITRO assumes all integer
#  *    variables are unbounded in that direction.
#  *  - If the application does not supply an exact Hessian, then pass nnzH=0
#  *    and NULL pointers for "hessIndexRows" and "hessIndexCols".
#  *  - If "xInitial" or "lambdaInitial" are NULL, then KNITRO determines the
#  *    initial start point.
#  *  If a particular bound does not exist, then load the array element
#  *  with KTR_INFBOUND for an upper bound, or -KTR_INFBOUND for a lower bound.
#  *  KNITRO interprets this value as infinity and ignores the bound.
#  *    To make the j-th constraint be an equality constraint, set cLoBnds[j]
#  *  equal to cUpBnds[j].
#  *
#  *  Returns 0 if OK, nonzero if error.
#  *
#  *  Brief description of the arguments (consult the KNITRO manual for details):
#  *    n             - number of unknowns (continuous and integer)
#  *    objGoal       - objective goal (KTR_OBJGOAL_MINIMIZE or _MAXIMIZE)
#  *    objType       - objective type (eg, KTR_OBJTYPE_GENERAL)
#  *    objFnType     - objective function type (eg, KTR_FNTYPE_CONVEX)
#  *    xType         - (length n) variable type (eg, KTR_VARTYPE_INTEGER)
#  *    xLoBnds       - (length n) lower bounds on the variables
#  *    xUpBnds       - (length n) upper bounds on the variables
#  *    m             - number of constraints
#  *    cType         - (length m) constraint type (eg, KTR_CONTYPE_GENERAL)
#  *    cFnType       - (length m) constraint function type (eg, KTR_FNTYPE_CONVEX)
#  *    cLoBnds       - (length m) lower bounds on the constraints
#  *    cUpBnds       - (length m) upper bounds on the constraints
#  *    nnzJ          - number of nonzeroes in the sparse constraint Jacobian
#  *    jacIndexVars  - (length nnzJ) variable index (column) of each nonzero
#  *    jacIndexCons  - (length nnzJ) constraint index (row) of each nonzero
#  *    nnzH          - number of nonzeroes in the sparse Hessian of Lagrangian
#  *    hessIndexRows - (length nnzH) row index of each nonzero
#  *    hessIndexCols - (length nnzH) column index of each nonzero
#  *    xInitial      - (length n) initial start point for the unknowns
#  *    lambdaInitial - (length m+n) initial start point for multipliers
#  */
# int  KNITRO_API KTR_mip_init_problem
#     (      KTR_context_ptr kc,
#      const int             n,
#      const int             objGoal,
#      const int             objType,
#      const int             objFnType,
#      const int    * const  xType,
#      const double * const  xLoBnds,
#      const double * const  xUpBnds,
#      const int             m,
#      const int    * const  cType,
#      const int    * const  cFnType,
#      const double * const  cLoBnds,
#      const double * const  cUpBnds,
#      const int             nnzJ,
#      const int    * const  jacIndexVars,
#      const int    * const  jacIndexCons,
#      const int             nnzH,
#      const int    * const  hessIndexRows,
#      const int    * const  hessIndexCols,
#      const double * const  xInitial,
#      const double * const  lambdaInitial);

function mip_init_problem(kp::KnitroProblem,
                          objGoal::Int32,
                          objType::Int32,
                          objFnType::Int32,
                          x_Type::Vector{Int32},
                          x_L::Vector{Float64},
                          x_U::Vector{Float64},
                          c_Type::Vector{Int32},
                          c_FnType::Vector{Int32},
                          c_L::Vector{Float64},
                          c_U::Vector{Float64},
                          jac_var::Vector{Int32},
                          jac_cons::Vector{Int32},
                          hess_rows::Vector{Int32},
                          hess_cols::Vector{Int32};
                          initial_x = C_NULL,
                          initial_lambda = C_NULL)
  n = length(x_L)
  m = length(c_Type)
  nnzJ = length(jac_var)
  nnzH = length(hess_rows)
  return_code = @ktr_ccall(mip_init_problem, Int32, (Ptr{Void},Cint,Cint,Cint,
                           Cint,Ptr{Cint},Ptr{Cdouble},Ptr{Cdouble},Cint,Ptr{Cint},
                           Ptr{Cint},Ptr{Cdouble},Ptr{Cdouble},Cint,Ptr{Cint},
                           Ptr{Cint},Cint,Ptr{Cint},Ptr{Cint}, Ptr{Void},
                           Ptr{Void}), kp.env, n, objGoal, objType, objFnType,
                           x_Type, x_L, x_U, m, c_Type, c_FnType, c_L, c_U,
                           nnzJ, jac_var, jac_cons, nnzH, hess_rows, hess_cols,
                           initial_x, initial_lambda)
  if return_code != 0
    error("KNITRO: Error initializing MIP problem")
  end
end

# /** Set the branching priorities for integer variables.
#  *  Priorities must be positive numbers (variables with non-positive values
#  *  are ignored).  Variables with higher priority values will be considered
#  *  for branching before variables with lower priority values.  When
#  *  priorities for a subset of variables are equal, the branching rule is
#  *  applied as a tiebreaker.
#  *  Array xPriorities has length n, and values for continuous variables are
#  *  ignored.  KNITRO makes a local copy of all inputs, so the application
#  *  may free memory after the call.
#  *  This routine must be called after calling KTR_mip_init_problem and
#  *  before calling KTR_mip_solve.
#  *  Returns 0 if OK, nonzero if error.
#  */
# int  KNITRO_API KTR_mip_set_branching_priorities
#     (      KTR_context_ptr kc,
#      const int * const     xPriorities);

function set_branching_priorities(kp::KnitroProblem,
                                  xPriorities::Vector{Int})
  return_code = @ktr_ccall(mip_set_branching_priorities, Int32, (Ptr{Void},
                           Ptr{Cint}), kp.env, xPriorities)
  if return_code != 0
    error("KNITRO: Error setting MIP branching priorities")
  end
end  

# /** Call KNITRO to solve the MIP problem.  If the application provides callback
#  *  functions for evaluating the function, constraints, and derivatives,
#  *  then a single call to KTR_mip_solve returns the solution.  Otherwise,
#  *  KNITRO operates in reverse communications mode and returns a status code
#  *  that may request another call.  See the KNITRO manual for details.
#  *
#  *  Returns one of the status codes KTR_RC_* (see definitions in this file).
#  *  In particular:
#  *    <0 - KNITRO terminated with a fatal error
#  *     0 - KNITRO is finished: x, lambda, and obj contain the optimal solution
#  *     1 - call KTR_mip_solve again (reverse comm) with obj and c containing
#  *         the objective and constraints evaluated at x
#  *     2 - call KTR_mip_solve again (reverse comm) with objGrad and jac
#  *         containing the objective and constraint first derivatives evaluated
#  *         at x
#  *     3 - call KTR_mip_solve again (reverse comm) with hess containing
#  *         H(x,lambda), the Hessian of the Lagrangian evaluated at x and lambda
#  *     7 - call KTR_mip_solve again (reverse comm) with hessVector containing
#  *         the result of H(x,lambda) * hessVector
#  *
#  *  Brief description of the arguments (consult the KNITRO manual for details):
#  *    x          - output (length n) solution point estimate
#  *    lambda     - output (length m+n) Lagrange multiplier estimate
#  *    evalStatus - input  evaluation status (0=OK)
#  *    obj        - input  (length 1) objective at x
#  *                 output            optimal objective if KTR_RC_BEGINEND
#  *    c          - input  (length m) constraints at x
#  *    objGrad    - input  (length n) objective gradient at x
#  *    jac        - input  (length nnzJ) sparse constraint gradient at x
#  *    hess       - input  (length nnzH) sparse Hessian at x and lambda
#  *    hessVector - input  (length n) vector to multiply Hessian by
#  *                 output            result of H(x,lambda) * hessVector
#  *    userParams - input  passed directly to application callback functions
#  *
#  *  If "gradopt" is set to compute finite differences for first derivatives,
#  *  then KTR_mip_solve will modify objGrad and jac; otherwise, these arguments
#  *  are not modified.
#  */
# int  KNITRO_API KTR_mip_solve
#     (      KTR_context_ptr kc,
#            double * const  x,
#            double * const  lambda,
#      const int             evalStatus,
#            double * const  obj,
#            double * const  c,
#            double * const  objGrad,
#            double * const  jac,
#            double * const  hess,
#            double * const  hessVector,
#            void   * const  userParams);

function mip_solve_problem(kp::KnitroProblem, x::Vector{Float64}, lambda::Vector{Float64},
                           evalStatus::Int32, obj::Vector{Float64}, cons::Vector{Float64},
                           objGrad::Vector{Float64}, jac::Vector{Float64}, hess::Vector{Float64},
                           hessVector::Vector{Float64})
  return_code = @ktr_ccall(mip_solve, Int32, (Ptr{Void},Ptr{Cdouble},Ptr{Cdouble},
                           Int32,Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble},
                           Ptr{Cdouble},Ptr{Cdouble}, Any), kp.env, x, lambda, evalStatus,
                           obj, cons, objGrad, jac, hess, hessVector, kp)
  if return_code < 0
    error("KNITRO: Error solving MIP problem")
  end
  return_code
end

function mip_solve_problem(kp::KnitroProblem, x::Vector{Float64}, lambda::Vector{Float64},
                           evalStatus::Int32, obj::Vector{Float64})
  # For callback mode
  return_code = @ktr_ccall(mip_solve, Int32, (Ptr{Void},Ptr{Cdouble},Ptr{Cdouble},
                           Int32,Ptr{Cdouble},Ptr{Void},Ptr{Void},Ptr{Void},
                           Ptr{Void},Ptr{Void}, Any), kp.env, x, lambda, evalStatus,
                           obj, C_NULL, C_NULL, C_NULL, C_NULL, C_NULL, kp)
  if return_code != 0
    error("KNITRO: Error solving MIP problem (in callback mode")
  end
  return_code
end

# /** Set an array of relative stepsizes to use for the finite-difference
#  *  gradient/Jacobian computations when using finite-difference
#  *  first derivatives.  Finite-difference step sizes "delta" in KNITRO are
#  *  computed as:
#  *       delta[i] = relStepSizes[i]*max(abs(x[i]),1);
#  *  The default relative step sizes for each component of "x" are sqrt(eps)
#  *  for forward finite differences, and eps^(1/3) for central finite
#  *  differences.  Use this function to overwrite the default values.
#  *  Array relStepSizes has length n and all values should be non-zero. If
#  *  relStepSizes is set to NULL, then default KNITRO values will be used.
#  *  KNITRO makes a local copy of all inputs, so the application may free
#  *  memory after the call.  This routine must be called after calling
#  *  KTR_init_problem and before calling KTR_solve.
#  *  Returns 0 if OK, nonzero if error.
#  */
# int  KNITRO_API KTR_set_findiff_relstepsizes
#     (      KTR_context_ptr kc,
#      const double * const  relStepSizes);

function set_findiff_relstepsizes(kp::KnitroProblem,
                                  relStepSizes::Vector{Float64})
  return_code = @ktr_ccall(set_findiff_relstepsizes, Int32, (Ptr{Void},
                           Ptr{Cdouble}), kp.env, relStepSizes)
  if return_code != 0
    error("KNITRO: Error setting relative stepsizes for the finite-difference gradient/Jacobian computations")
  end
end

# /* ----- Reading solution properties ----- */

# /** Return the number of function evaluations requested by KTR_solve.
#  *  A single request evaluates the objective and all constraint functions.
#  *  Returns a negative number if there is a problem with kc.
#  */
# int  KNITRO_API KTR_get_number_FC_evals (const KTR_context_ptr  kc);

function get_number_FC_evals(kp::KnitroProblem)
  n = @ktr_ccall(get_number_FC_evals, Int32, (Ptr{Void},), kp.env)
  if n < 0
    error("KNITRO: Error returning number of function evaluations")
  end
  n
end

# /** Return the number of gradient evaluations requested by KTR_solve.
#  *  A single request evaluates first derivatives of the objective and
#  *  all constraint functions.
#  *  Returns a negative number if there is a problem with kc.
#  */
# int  KNITRO_API KTR_get_number_GA_evals (const KTR_context_ptr  kc);

function get_number_GA_evals(kp::KnitroProblem)
  n = @ktr_ccall(get_number_GA_evals, Int32, (Ptr{Void},), kp.env)
  if n < 0
    error("KNITRO: Error returning number of gradient evaluations")
  end
  n
end

# /** Return the number of Hessian evaluations requested by KTR_solve.
#  *  A single request evaluates second derivatives of the objective and
#  *  all constraint functions.
#  *  Returns a negative number if there is a problem with kc.
#  */
# int  KNITRO_API KTR_get_number_H_evals (const KTR_context_ptr  kc);

function get_number_H_evals(kp::KnitroProblem)
  n = @ktr_ccall(get_number_H_evals, Int32, (Ptr{Void},), kp.env)
  if n < 0
    error("KNITRO: Error returning number of hessian evaluations")
  end
  n
end

# /** Return the number of Hessian-vector products requested by KTR_solve.
#  *  A single request evaluates the product of the Hessian of the
#  *  Lagrangian with a vector submitted by KNITRO.
#  *  Returns a negative number if there is a problem with kc.
#  */
# int  KNITRO_API KTR_get_number_HV_evals (const KTR_context_ptr  kc);

function get_number_HV_evals(kp::KnitroProblem)
  n = @ktr_ccall(get_number_HV_evals, Int32, (Ptr{Void},), kp.env)
  if n < 0
    error("KNITRO: Error returning number of hessian-vector evaluations")
  end
  n
end

# /* ----- Solution properties for continuous problems only ----- */
    
# /** Return the number of iterations made by KTR_solve.
#  *  Returns a negative number if there is a problem with kc.
#  */
# int  KNITRO_API KTR_get_number_iters (const KTR_context_ptr  kc);

function get_number_iters(kp::KnitroProblem)
  n = @ktr_ccall(get_number_iters, Int32, (Ptr{Void},), kp.env)
  if n < 0
    error("KNITRO: Error returning number of iterations")
  end
  n
end

# /** Return the number of conjugate gradient (CG) iterations made by
#  *  KTR_solve.
#  *  Returns a negative number if there is a problem with kc.
#  */
# int  KNITRO_API KTR_get_number_cg_iters (const KTR_context_ptr  kc);

function get_number_cg_iters(kp::KnitroProblem)
  n = @ktr_ccall(get_number_cg_iters, Int32, (Ptr{Void},), kp.env)
  if n < 0
    error("KNITRO: Error returning number of conjugate gradient iterations")
  end
  n
end

# /** Return the absolute feasibility error at the solution.
#  *  Refer to the KNITRO manual section on Termination Tests for a
#  *  detailed definition of this quantity.
#  *  Returns a negative number if there is a problem with kc.
#  */
# double  KNITRO_API KTR_get_abs_feas_error (const KTR_context_ptr  kc);

function get_abs_feas_error(kp::KnitroProblem)
  n = @ktr_ccall(get_abs_feas_error, Float64, (Ptr{Void},), kp.env)
  if n < 0
    error("KNITRO: Error getting absolute feasibility error at solution")
  end
  n
end

# /** Return the relative feasibility error at the solution.
#  *  Refer to the KNITRO manual section on Termination Tests for a
#  *  detailed definition of this quantity.
#  *  Returns a negative number if there is a problem with kc.
#  */
# double  KNITRO_API KTR_get_rel_feas_error (const KTR_context_ptr  kc);

function get_rel_feas_error(kp::KnitroProblem)
  n = @ktr_ccall(get_rel_feas_error, Float64, (Ptr{Void},), kp.env)
  if n < 0
    error("KNITRO: Error getting relative feasibility error at solution")
  end
  n
end

# /** Return the absolute optimality error at the solution.
#  *  Refer to the KNITRO manual section on Termination Tests for a
#  *  detailed definition of this quantity.
#  *  Returns a negative number if there is a problem with kc.
#  */
# double  KNITRO_API KTR_get_abs_opt_error (const KTR_context_ptr  kc);

function get_abs_opt_error(kp::KnitroProblem)
  n = @ktr_ccall(get_abs_opt_error, Float64, (Ptr{Void},), kp.env)
  if n < 0
    error("KNITRO: Error getting absolute optimality error at solution")
  end
  n
end

# /** Return the relative optimality error at the solution.
#  *  Refer to the KNITRO manual section on Termination Tests for a
#  *  detailed definition of this quantity.
#  *  Returns a negative number if there is a problem with kc.
#  */
# double  KNITRO_API KTR_get_rel_opt_error (const KTR_context_ptr  kc);

function get_rel_opt_error(kp::KnitroProblem)
  n = @ktr_ccall(get_rel_opt_error, Float64, (Ptr{Void},), kp.env)
  if n < 0
    error("KNITRO: Error getting relative optimality error at solution")
  end
  n
end

# /** Return the solution status, objective, primal and dual variables.
#  *  The status and objective value scalars are returned as pointers
#  *  that need to be de-referenced to get their values.  The arrays
#  *  "x" and "lambda" must be allocated by the user.
#  *  Returns 0 if call is successful;
#  *         <0 if there is an error.
#  */
# int  KNITRO_API KTR_get_solution (const KTR_context_ptr kc,
#                                         int     * const status,
#                                         double  * const obj,         
#                                         double  * const x,
#                                         double  * const lambda);

function get_solution(kp::KnitroProblem,
                      status::Vector{Int32},
                      obj::Vector{Float64},
                      x::Vector{Float64},
                      lambda::Vector{Float64})
  return_code = @ktr_ccall(get_solution, Int32, (Ptr{Void}, Ptr{Cint},
                           Ptr{Cdouble},Ptr{Cdouble},Ptr{Cdouble}), kp.env,
                           status, obj, x, lambda)
  if return_code < 0
    error("KNITRO: Error getting the solution status, objective, primal and dual variables")
  end
end

# /** Return the values of the constraint vector c(x) in "c".
#  *  The array "c" must be allocated by the user.
#  *  Returns 0 if call is successful;
#  *         <0 if there is an error.
#  */
# int  KNITRO_API KTR_get_constraint_values (const KTR_context_ptr kc,
#                                                  double  * const c);

function get_constraint_values(kp::KnitroProblem,
                               cons::Vector{Float64})
  return_code = @ktr_ccall(get_constraint_values, Int32, (Ptr{Void},
                           Ptr{Cdouble}), kp.env, cons)
  if return_code < 0
    error("KNITRO: Error getting the values of the constraint vector c(x)")
  end
end

# /** Return the values of the objective gradient vector in "objGrad".
#  *  The array "objGrad" must be allocated by the user.  It is a
#  *  dense array of dimension "n" (where "n" is the number of variables
#  *  in the problem).
#  *  Returns 0 if call is successful;
#  *         <0 if there is an error.
#  */
# int  KNITRO_API KTR_get_objgrad_values (const KTR_context_ptr kc,
#                                               double  * const objGrad);

function get_objgrad_values(kp::KnitroProblem,
                            objGrad::Vector{Float64})
  return_code = @ktr_ccall(get_objgrad_values, Int32, (Ptr{Void},
                           Ptr{Cdouble}), kp.env, objGrad)
  if return_code < 0
    error("KNITRO: Error getting the values of the objective gradient vector")
  end
end

# /** Return the values of the constraint Jacobian in "jac".
#  *  The Jacobian values returned correspond to the non-zero sparse
#  *  Jacobian indices provided by the user in KTR_init_problem().
#  *  The array "jac" must be allocated by the user.
#  *  Returns 0 if call is successful;
#  *         <0 if there is an error.
#  */
# int  KNITRO_API KTR_get_jacobian_values (const KTR_context_ptr kc,
#                                                double  * const jac);

function get_jacobian_values(kp::KnitroProblem,
                             jac::Vector{Float64})
  return_code = @ktr_ccall(get_jacobian_values, Int32, (Ptr{Void},
                           Ptr{Cdouble}), kp.env, jac)
  if return_code < 0
    error("KNITRO: Error getting the values of the constraint Jacobian")
  end
end

# /** Return the values of the Hessian (or possibly Hessian
#  *  approximation) in "hess".  This routine is currently only valid
#  *  if 1 of the 2 following cases holds:
#  *  1) KTR_HESSOPT_EXACT (presolver on or off), or;
#  *  2) KTR_HESSOPT_BFGS or KTR_HESSOPT_SR1, but only with the
#  *     KNITRO presolver off (i.e. KTR_PRESOLVE_NONE).
#  *
#  *  In all other cases, either KNITRO does not have an internal
#  *  representation of the Hessian (or Hessian approximation),
#  *  or the internal Hessian approximation corresponds only to
#  *  the presolved problem form and may not be valid for the
#  *  original problem form.  In these cases "hess" is left
#  *  unmodified, and the routine has return code 1.
#  *
#  *  Note that in case 2 above (KTR_HESSOPT_BFGS or KTR_HESSOPT_SR1)
#  *  the values returned in "hess" are the upper triangular values
#  *  of the dense quasi-Newton Hessian approximation stored row-wise.
#  *  There are ((n*n - n)/2 + n) such values (where "n" is the number
#  *  of variables in the problem. These values may be quite different
#  *  from the values of the exact Hessian.
#  *
#  *  When KTR_HESSOPT_EXACT (case 1 above) the Hessian values
#  *  returned correspond to the non-zero sparse Hessian indices
#  *  provided by the user in KTR_init_problem().
#  *
#  *  The array "hess" must be allocated by the user.
#  *  Returns 0 if call is successful;
#  *          1 if "hess" was not set because KNITRO does not
#  *            have a valid Hessian for the model stored.
#  *         <0 if there is an error.
#  */
# int  KNITRO_API KTR_get_hessian_values (const KTR_context_ptr kc,
#                                               double  * const hess);    

function get_hessian_values(kp::KnitroProblem,
                            hess::Vector{Float64})
  return_code = @ktr_ccall(get_hessian_values, Int32, (Ptr{Void},
                           Ptr{Cdouble}), kp.env, hess)
  if return_code < 0
    error("KNITRO: Error getting the values of the Hessian")
  end
end

    
# /* ----- Solution properties for MIP problems only ----- */
    
# /** Return the number of nodes processed in the MIP solve.
#  *  Returns a negative number if there is a problem with kc.    
#  */
# int  KNITRO_API KTR_get_mip_num_nodes (const KTR_context_ptr kc);

function get_mip_num_nodes(kp::KnitroProblem)
  n = @ktr_ccall(get_mip_num_nodes, Int32, (Ptr{Void},), kp.env)
  if n < 0
    error("KNITRO: Error getting the number of nodes processed in the MIP solve")
  end
end

# /** Return the number of continuous subproblems processed in the
#  *  MIP solve.
#  *  Returns a negative number if there is a problem with kc.
#  */
# int  KNITRO_API KTR_get_mip_num_solves (const KTR_context_ptr kc);

function get_mip_num_solves(kp::KnitroProblem)
  n = @ktr_ccall(get_mip_num_solves, Int32, (Ptr{Void},), kp.env)
  if n < 0
    error("KNITRO: Error getting the number of continuous subproblems processed in the MIP solve")
  end
end

# /** Return the final absolute integrality gap in the MIP solve.
#  *  Refer to the KNITRO manual section on Termination Tests for
#  *  a detailed definition of this quantity. Returns KTR_INFBOUND
#  *  if no incumbent (i.e., integer feasible) point found.
#  *  Returns KTR_RC_BAD_KCPTR if there is a problem with kc.
#  */
# double  KNITRO_API KTR_get_mip_abs_gap (const KTR_context_ptr kc);    

function get_mip_abs_gap(kp::KnitroProblem)
  @ktr_ccall(get_mip_abs_gap, Float64, (Ptr{Void},), kp.env)
end

# /** Return the final absolute integrality gap in the MIP solve.
#  *  Refer to the KNITRO manual section on Termination Tests for
#  *  a detailed definition of this quantity.  Returns KTR_INFBOUND
#  *  if no incumbent (i.e., integer feasible) point found.
#  *  Returns KTR_RC_BAD_KCPTR if there is a problem with kc.
#  */
# double  KNITRO_API KTR_get_mip_rel_gap (const KTR_context_ptr kc); 

function get_mip_rel_gap(kp::KnitroProblem)
  @ktr_ccall(get_mip_rel_gap, Float64, (Ptr{Void},), kp.env)
end

# /** Return the objective value of the MIP incumbent solution.
#  *  Returns KTR_INFBOUND if no incumbent (i.e., integer feasible)
#  *  point found.
#  *  Returns KTR_RC_BAD_KCPTR if there is a problem with kc.
#  */
# double  KNITRO_API KTR_get_mip_incumbent_obj (const KTR_context_ptr kc);

function get_mip_incumbent_obj(kp::KnitroProblem)
  @ktr_ccall(get_mip_incumbent_obj, Float64, (Ptr{Void},), kp.env)
end

# /** Return the value of the current MIP relaxation bound.
#  *  Returns KTR_RC_BAD_KCPTR if there is a problem with kc.
#  */
# double  KNITRO_API KTR_get_mip_relaxation_bnd (const KTR_context_ptr kc);

function get_mip_relaxation_bnd(kp::KnitroProblem)
  @ktr_ccall(get_mip_relaxation_bnd, Float64, (Ptr{Void},), kp.env)
end

# /** Return the objective value of the most recently solved MIP
#  *  node subproblem.
#  *  Returns KTR_RC_BAD_KCPTR if there is a problem with kc.
#  */
# double  KNITRO_API KTR_get_mip_lastnode_obj (const KTR_context_ptr kc);

function get_mip_lastnode_obj(kp::KnitroProblem)
  @ktr_ccall(get_mip_lastnode_obj, Float64, (Ptr{Void},), kp.env)
end

# /** Return the MIP incumbent solution in "x" if one exists.
#  *  Returns 1 if incumbent solution exists and call is successful;
#  *          0 if no incumbent (i.e., integer feasible) exists
#  *              and leaves "x" unmodified;
#  *         <0 if there is an error.
#  */
# int  KNITRO_API KTR_get_mip_incumbent_x (const KTR_context_ptr kc,
#                                          double * const x);

function get_mip_incumbent_x(kp::KnitroProblem, x::Vector{Float64})
  @ktr_ccall(get_mip_incumbent_x, Int32, (Ptr{Void}, Ptr{Cdouble}), kp.env, x)
end

# /* ----- Checking derivatives ----- */

# /** Compare the application's analytic first derivatives to a finite
#  *  difference approximation at x.  The objective and all constraint
#  *  functions are checked.  Like KTR_solve, the routine may be used in
#  *  reverse communications or callback mode (see examples/C/checkDersExample.c).
#  *
#  *  Returns one of the status codes KTR_RC_* (see definitions in this file).
#  *  In particular:
#  *    <0 - error
#  *     0 - routine is finished
#  *     1 - call routine again (reverse comm) with obj and c containing
#  *         the objective and constraints evaluated at x
#  *     2 - call routine again (reverse comm) with objGrad and jac containing
#  *         the objective and constraint first derivatives evaluated at x
#  *
#  *  Description of the arguments:
#  *    x                - input  (length n) point at which to check derivatives
#  *                       output            point at which to evaluate obj and c
#  *    finiteDiffMethod - 1 = forward differences, 2 = central differences
#  *    absThreshold     - print when |estimate - analytic| > threshold
#  *    relThreshold     - print when |estimate - analytic| > threshold * scale
#  *                         where scale = max{1, |analytic|}
#  *    evalStatus       - input            evaluation status (0=OK)
#  *    obj              - input            objective at x
#  *    c                - input (length m) constraints at x
#  *    objGrad          - input (length n) analytic gradient at x
#  *    jac              - input (length nnzJ) analytic constraint Jacobian at x
#  *    userParams       - input  passed directly to application callback
#  */
# int  KNITRO_API KTR_check_first_ders (const KTR_context_ptr  kc,
#                                             double * const   x,
#                                       const int              finiteDiffMethod,
#                                       const double           absThreshold,
#                                       const double           relThreshold,
#                                       const int              evalStatus,
#                                       const double           obj,
#                                       const double * const   c,
#                                       const double * const   objGrad,
#                                       const double * const   jac,
#                                             void   *         userParams);

function check_first_ders(kp::KnitroProblem,
                          x::Vector{Float64},
                          finiteDiffMethod::Int32,
                          absThreshold::Float64,
                          relThreshold::Float64,
                          evalStatus::Int32,
                          obj::Float64,
                          cons::Vector{Float64},
                          objGrad::Vector{Float64},
                          jac::Vector{Float64})
  return_code = @ktr_ccall(check_first_ders, Int32, (Ptr{Void}, Ptr{Cdouble}, Cint,
                           Cdouble, Cdouble, Cint, Cdouble, Ptr{Cdouble},
                           Ptr{Cdouble}, Ptr{Cdouble}, Ptr{Void}), kp.env, x,
                           finiteDiffMethod, absThreshold, relThreshold, evalStatus,
                           obj, cons, objGrad, jac, C_NULL)
  if return_code < 0
    error("KNITRO: Error comparing the application's analytic first derivatives to a finite difference approximation at x")
  end
end