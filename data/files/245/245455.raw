##############################################################################
##
## TODO
##
##############################################################################

# - Test different WIF types
# - Add negative WIF tests (e.g., invalid compression bits)
# - Test different key types (e.g., compressed)
# - Add negative key tests

using Coin
using Base.Test

##############################################################################
##
## Base58 tests
##
##############################################################################

base58data = parseint(BigInt, "800c28fca386c7a227600b2fe50b7cae11ec86d3bf1fbe471be89827e19d72aa1d507a5b8d", 16)

# Base 58 encoding
@test encode58(base58data) == "5HueCGU8rMjxEXxiPuD5BDku4MkFqeZyd4dZ1jvhTVqvbTLvyTJ"

# Base 58 decoding
@test decode58("5HueCGU8rMjxEXxiPuD5BDku4MkFqeZyd4dZ1jvhTVqvbTLvyTJ") == base58data

# TODO: add test for leading 0

##############################################################################
##
## Key generation tests
##
##############################################################################

secret_key = "18E14A7B6A307F426A94F8114701E7C8E774E7F9A47E2C2035DB29A206321725"
public_key = get_pub_key(secret_key)
@test public_key == "16UwLL9Risc3QfPqBUvKofHmBQ7wMtjvM"

##############################################################################
##
## Wallet Interchange Format tests
##
##############################################################################

# Private key to WIF
@test private2wif("0c28fca386c7a227600b2fe50b7cae11ec86d3bf1fbe471be89827e19d72aa1d") == "5HueCGU8rMjxEXxiPuD5BDku4MkFqeZyd4dZ1jvhTVqvbTLvyTJ"

# WIF to private key
@test wif2private("5HueCGU8rMjxEXxiPuD5BDku4MkFqeZyd4dZ1jvhTVqvbTLvyTJ") == "0c28fca386c7a227600b2fe50b7cae11ec86d3bf1fbe471be89827e19d72aa1d"

# WIF checksum
@test wif_check_sum("5HueCGU8rMjxEXxiPuD5BDku4MkFqeZyd4dZ1jvhTVqvbTLvyTJ")

@test pub2base58("0450863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B23522CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6") == "16UwLL9Risc3QfPqBUvKofHmBQ7wMtjvM"

##############################################################################
##
## Transaction tests
##
##############################################################################

# Test header generation
payload = "0100000001484d40d45b9ea0d652fca8258ab7caa42541eb52975857f96fb50cd732c8b481000000008a47304402202cb265bf10707bf49346c3515dd3d16fc454618c58ec0a0ff448a676c54ff71302206c6624d762a1fcef4618284ead8f08678ac05b13c84235f1654e6ad168233e8201410414e301b2328f17442c0b8310d787bf3d8a404cfbd0704f135b6ad4b2d3ee751310f981926e53a6e8c39bd7d3fefd576c543cce493cbac06388f2651d1aacbfcdffffffff0162640100000000001976a914c8e90996c7c6080ee06284600c684ed904d14c5c88ac00000000"
# @test create_header(magic_mainnet, "tx", payload) == "f9beb4d9747800000000000000000000df000000ea0f5494"

# Transaction output
tx_out = Tx_Output(123, "abc")
@test bytearray(tx_out) == [0x7b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x0a, 0xbc]
tx_out = Tx_Output(5000000, "76A9141AA0CD1CBEA6E7458A7ABAD512A9D9EA1AFB225E88AC")
@test bytearray(tx_out) == [0x40, 0x4b, 0x4c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0x1a, 0xa0, 0xcd, 0x1c, 0xbe, 0xa6, 0xe7, 0x45, 0x8a, 0x7a, 0xba, 0xd5, 0x12, 0xa9, 0xd9, 0xea, 0x1a, 0xfb, 0x22, 0x5e, 0x88, 0xac]
tx_out = Tx_Output(91234, [0x76, 0xa9, 0x14, 0xc8, 0xe9, 0x09, 0x96, 0xc7, 0xc6, 0x08, 0x0e, 0xe0, 0x62, 0x84, 0x60, 0x0c, 0x68, 0x4e, 0xd9, 0x04, 0xd1, 0x4c, 0x5c, 0x88, 0xac])

# Transaction outpoint (i.e., reference to previous transaction)
@test_throws ErrorException OutPoint("abc", 1)
outpoint = OutPoint("abcaabcaabcaabcaabcaabcaabcaabcaabcaabcaabcaabcaabcaabcaabcaabca", 1)
@test bytearray(outpoint) == [0xca, 0xab, 0xca, 0xab, 0xca, 0xab, 0xca, 0xab, 0xca, 0xab, 0xca, 0xab, 0xca, 0xab, 0xca, 0xab, 0xca, 0xab, 0xca, 0xab, 0xca, 0xab, 0xca, 0xab, 0xca, 0xab, 0xca, 0xab, 0xca, 0xab, 0xca, 0xab, 0x01, 0x00, 0x00, 0x00]
outpoint = OutPoint("81b4c832d70cb56ff957589752eb4125a4cab78a25a8fc52d6a09e5bd4404d48", 0)
@test bytearray(outpoint) == [0x48, 0x4d, 0x40, 0xd4, 0x5b, 0x9e, 0xa0, 0xd6, 0x52, 0xfc, 0xa8, 0x25, 0x8a, 0xb7, 0xca, 0xa4, 0x25, 0x41, 0xeb, 0x52, 0x97, 0x58, 0x57, 0xf9, 0x6f, 0xb5, 0x0c, 0xd7, 0x32, 0xc8, 0xb4, 0x81, 0x00, 0x00, 0x00, 0x00]

# Transaction input
scriptSig = "47304402202cb265bf10707bf49346c3515dd3d16fc454618c58ec0a0ff448a676c54ff71302206c6624d762a1fcef4618284ead8f08678ac05b13c84235f1654e6ad168233e8201410414e301b2328f17442c0b8310d787bf3d8a404cfbd0704f135b6ad4b2d3ee751310f981926e53a6e8c39bd7d3fefd576c543cce493cbac06388f2651d1aacbfcd"
tx_in = Tx_Input(outpoint, scriptSig)
@test bytearray(tx_in) == [0x48, 0x4d, 0x40, 0xd4, 0x5b, 0x9e, 0xa0, 0xd6, 0x52, 0xfc, 0xa8, 0x25, 0x8a, 0xb7, 0xca, 0xa4, 0x25, 0x41, 0xeb, 0x52, 0x97, 0x58, 0x57, 0xf9, 0x6f, 0xb5, 0x0c, 0xd7, 0x32, 0xc8, 0xb4, 0x81, 0x00, 0x00, 0x00, 0x00, 0x8a, 0x47, 0x30, 0x44, 0x02, 0x20, 0x2c, 0xb2, 0x65, 0xbf, 0x10, 0x70, 0x7b, 0xf4, 0x93, 0x46, 0xc3, 0x51, 0x5d, 0xd3, 0xd1, 0x6f, 0xc4, 0x54, 0x61, 0x8c, 0x58, 0xec, 0x0a, 0x0f, 0xf4, 0x48, 0xa6, 0x76, 0xc5, 0x4f, 0xf7, 0x13, 0x02, 0x20, 0x6c, 0x66, 0x24, 0xd7, 0x62, 0xa1, 0xfc, 0xef, 0x46, 0x18, 0x28, 0x4e, 0xad, 0x8f, 0x08, 0x67, 0x8a, 0xc0, 0x5b, 0x13, 0xc8, 0x42, 0x35, 0xf1, 0x65, 0x4e, 0x6a, 0xd1, 0x68, 0x23, 0x3e, 0x82, 0x01, 0x41, 0x04, 0x14, 0xe3, 0x01, 0xb2, 0x32, 0x8f, 0x17, 0x44, 0x2c, 0x0b, 0x83, 0x10, 0xd7, 0x87, 0xbf, 0x3d, 0x8a, 0x40, 0x4c, 0xfb, 0xd0, 0x70, 0x4f, 0x13, 0x5b, 0x6a, 0xd4, 0xb2, 0xd3, 0xee, 0x75, 0x13, 0x10, 0xf9, 0x81, 0x92, 0x6e, 0x53, 0xa6, 0xe8, 0xc3, 0x9b, 0xd7, 0xd3, 0xfe, 0xfd, 0x57, 0x6c, 0x54, 0x3c, 0xce, 0x49, 0x3c, 0xba, 0xc0, 0x63, 0x88, 0xf2, 0x65, 0x1d, 0x1a, 0xac, 0xbf, 0xcd, 0xff, 0xff, 0xff, 0xff]

# Transaction
tx = Tx([tx_in], [tx_out])
@test bytearray(tx) == [0x01, 0x00, 0x00, 0x00, 0x01, 0x48, 0x4d, 0x40, 0xd4, 0x5b, 0x9e, 0xa0, 0xd6, 0x52, 0xfc, 0xa8, 0x25, 0x8a, 0xb7, 0xca, 0xa4, 0x25, 0x41, 0xeb, 0x52, 0x97, 0x58, 0x57, 0xf9, 0x6f, 0xb5, 0x0c, 0xd7, 0x32, 0xc8, 0xb4, 0x81, 0x00, 0x00, 0x00, 0x00, 0x8a, 0x47, 0x30, 0x44, 0x02, 0x20, 0x2c, 0xb2, 0x65, 0xbf, 0x10, 0x70, 0x7b, 0xf4, 0x93, 0x46, 0xc3, 0x51, 0x5d, 0xd3, 0xd1, 0x6f, 0xc4, 0x54, 0x61, 0x8c, 0x58, 0xec, 0x0a, 0x0f, 0xf4, 0x48, 0xa6, 0x76, 0xc5, 0x4f, 0xf7, 0x13, 0x02, 0x20, 0x6c, 0x66, 0x24, 0xd7, 0x62, 0xa1, 0xfc, 0xef, 0x46, 0x18, 0x28, 0x4e, 0xad, 0x8f, 0x08, 0x67, 0x8a, 0xc0, 0x5b, 0x13, 0xc8, 0x42, 0x35, 0xf1, 0x65, 0x4e, 0x6a, 0xd1, 0x68, 0x23, 0x3e, 0x82, 0x01, 0x41, 0x04, 0x14, 0xe3, 0x01, 0xb2, 0x32, 0x8f, 0x17, 0x44, 0x2c, 0x0b, 0x83, 0x10, 0xd7, 0x87, 0xbf, 0x3d, 0x8a, 0x40, 0x4c, 0xfb, 0xd0, 0x70, 0x4f, 0x13, 0x5b, 0x6a, 0xd4, 0xb2, 0xd3, 0xee, 0x75, 0x13, 0x10, 0xf9, 0x81, 0x92, 0x6e, 0x53, 0xa6, 0xe8, 0xc3, 0x9b, 0xd7, 0xd3, 0xfe, 0xfd, 0x57, 0x6c, 0x54, 0x3c, 0xce, 0x49, 0x3c, 0xba, 0xc0, 0x63, 0x88, 0xf2, 0x65, 0x1d, 0x1a, 0xac, 0xbf, 0xcd, 0xff, 0xff, 0xff, 0xff, 0x01, 0x62, 0x64, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xc8, 0xe9, 0x09, 0x96, 0xc7, 0xc6, 0x08, 0x0e, 0xe0, 0x62, 0x84, 0x60, 0x0c, 0x68, 0x4e, 0xd9, 0x04, 0xd1, 0x4c, 0x5c, 0x88, 0xac, 0x00, 0x00, 0x00, 0x00]

priv_key = Crypto.random(256)
pub_key = Crypto.ec_pub_key(priv_key)
keys = [Keys(priv_key, pub_key)]

outpoints = [OutPoint("81b4c832d70cb56ff957589752eb4125a4cab78a25a8fc52d6a09e5bd4404d48", 1)]
addresses = ["1KKKK6N21XKo48zWKuQKXdvSsCf95ibHFa"]
amounts = [91234]
tx = create_tx(keys, outpoints, addresses, amounts)

##############################################################################
##
## Utility tests
##
##############################################################################

# Reverse endian of hex string
@test reverse_endian("") == ""
@test reverse_endian("0c28fca386c7a227600b2fe50b7cae11ec86d3bf1fbe471be89827e19d72aa1d") == "1daa729de12798e81b47be1fbfd386ec11ae7c0be52f0b6027a2c786a3fc280c"
@test reverse_endian(0) == 0
@test reverse_endian(0x22) == 0x22
@test reverse_endian(0x333) == 0x3303
@test reverse_endian(0x2234) == 0x3422
@test reverse_endian(0xf9beb4d9) == 0xd9b4bef9
@test reverse_endian(BigInt(19238471923847192837419283749128374912837491823742198374)) == 9830438508025927557749821611753759704769006686345681864
# reverse_endian assumes that BigInt is at least 16 bytes and Int is system-dependent
@test reverse_endian(BigInt(24)) == 31901471898837980949691369446728269824
@test reverse_endian(23) == 1657324662872342528
@test reverse_endian(-23) == -1585267068834414593

# Test VarInt conversion
@test to_varint(1) == [0x01]
@test to_varint(252) == [0xfc]
@test to_varint(253) == [0xfd, 0x00, 0xfd]
@test to_varint(0xffff) == [0xfd, 0xff, 0xff]
@test to_varint(0x10000) == [0xfe, 0x00, 0x01, 0x00, 0x00]
@test to_varint(0x100000000) == [0xff, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00]
