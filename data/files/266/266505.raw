# TODO: Decide whether to provide both @mutate! vs @mutate macros.
# TODO: Make a copy before mutating the copy.
macro mutate(input::Symbol, _args::Expr...)
    args = collect(_args)
    g = MutateNode(DataNode(), args)
    helper_ex = _build_helper_ex(g)
    return quote
        set_helper!($g, $helper_ex)
        _collect($(esc(input)), $g)
    end
end

macro mutate(_args::Expr...)
    args = collect(_args)
    g = MutateNode(DataNode(), args)
    helper_ex = _build_helper_ex(g)
    return quote
        set_helper!($g, $helper_ex)
        _collect(CurryNode(), $g)
    end
end

### Helper

function _build_helper_ex(g::MutateNode)
    # TODO: check_node(g)
    helper_parts_ex = Expr(:ref, :Tuple, _build_helper_parts(g)...)
    return quote
        Helper{MutateNode}($helper_parts_ex)
    end
end

"""
    `_build_helper_parts(g::MutateNode)`

Returns a vector of `Expr` objects of the form

`Expr(:tuple, res_fld, kernel_expr, ind2sym)`,

one such `Expr` for each column transformation specified in `@mutate(tbl, ...)`.
For each such transformation, `res_fld::Symbol` is the name of the resultant
column, `kernel_expr::Expr` defines a lambda encoding the scalar-valued
transformation to be applied rowwise over the argument columns, and
`ind2sym::Vector{Symbol}` is a mapping from numeric indices (positions in the
tuple argument of the lambda defined by `kernel_expr`) to fields (column names).
"""
function _build_helper_parts(g::MutateNode)
    helper_parts_exs = Vector{Expr}()
    for e in g.args
        res_fld = QuoteNode(get_res_field(e))
        core_expr = get_value_expr(e)
        kernel_expr, ind2sym = build_kernel_ex(core_expr)
        push!(helper_parts_exs,
              # Helper{MutateNode} part
            #   Expr(:tuple, res_fld, anon_func_expr, esc(ind2sym))
            :( ($res_fld, $kernel_expr, $(esc(ind2sym))) )
        )
    end
    return helper_parts_exs
end

### RHS

function rhs_mutate(f, tbl, arg_flds)
    # Pre-process table in terms of kernel and argument column names
    T, row_itr = _preprocess(f, tbl, arg_flds)

    # Pre-allocate the table's new column.
    n = length(tbl[arg_flds[1]])
    output = NullableArray(T, n)

    # Fill the new column in row-by-row.
    # @code_warntype _fill_output!(output, f, row_itr)
    apply_mutate_func!(output, f, row_itr)

    # Return the output
    return output
end

"""
Given a tuple-to-scalar function that should be used to generate the output of
a `@mutate` operation, iterate over the elements of a tuple iterator to
produce the individual scalar values generated by the tuple-to-scalar function.
Store each of these values in the passed-in NullableVector.

Note that this function automatically applies the "natural" lifting semantics,
in which an expression over nullables produces a null value if any of the
inputs are null-valued. Another function will need to written to handle the
more complicated case in which only some sub-expressions are lifted and others
must be evaluated using custom lifting semantics.

* TODO: Parallelize this when threading is available in Base Julia.
* TODO: See if using `@inbounds` improves performance.
"""
@noinline function apply_mutate_func!(
    output::NullableVector,
    f::Any,
    tuple_iterator::Any,
)::Void
    # Iterate over all of the rows of the tuple iterator.
    for (i, tpl) in enumerate(tuple_iterator)
        # Apply default lifting semantics by branching on hasnull(tpl).
        if hasnulls(tpl)
            output.isnull[i] = true
        else
            output.isnull[i] = false
            output.values[i] = f(map(unwrap, tpl))
        end
    end
    return
end
