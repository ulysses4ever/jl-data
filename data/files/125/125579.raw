#=
 main functions of EvolutionaryAction.jl
  intended to be called by user
=#

# reconstruct phylogenetic tree and add to existing EvAc object
function maketree! ( evac::EvAc, file::ASCIIString; threads::Int64=1 )
	treefile = buildtree( file, threads )
	# read tree and update field in EvAc object
	evac.phy = readtree( treefile )[1]
end


# reconstruct phylogenetic tree and return new EvAc object
function maketree ( file::ASCIIString; threads::Int64=1 )
	# read-in alignment
	aln = readfasta( file )
	# run raxml in shell
	treefile = buildtree( file, threads )
	# read tree
	phy  = readtree( treefile )[1]
	# return alignment and tree as new EvAc object
	evac = EvAc( aln, phy )
	return( evac )
end


# calculate real-value Evolutionary Trace measure for an alignment
#  using a given tree
function rvevolutionarytrace! ( evac::EvAc; verbose::Bool=false )
	println("calculating real-value Evolutionary Trace")
	# get hierarchical groupings of the tree
	hiera = divideintogroups( evac.phy )
	# get residue for given sequence ID at given position and store in dictionary
	seqpos = Dict{String,String}()
	for si in 1:length(evac.aln)
		seqpos[ evac.aln[si][1] ] = uppercase( evac.aln[si][2] )
	end
	# get residues and their occurrences for given hierarchy partition
	function resnuminhiera (ix, jx, px )
		res = Dict{Char,Integer}()
		for id in hiera[ix][jx]
			if haskey( res,seqpos[id][px] )
				res[ seqpos[id][px] ] += 1
			else
				res[ seqpos[id][px] ]  = 1
			end
		end
		return res 
	end
	# calculate ET measure for an alignment position
	#  by summing over the nodes and associated groups
	resnum  = Dict{Char,Integer}()
	itrdone = 0
	evac.et = @parallel (vcat) for pos in 1:length(evac.aln[1][2])
		etp = 1.0
		for i in 1:length(hiera)
			etpg = 0.0
			for j in 1:length(hiera[i])
				resnum = resnuminhiera( i,j,pos )
				rsum   = sum( values(resnum) )
				for (resi,rnum) in resnum
					if sum( resi .== evac.alphabet ) != 0                                                
						etpg -= ( rnum/rsum * log(rnum/rsum) )
					end
				end
			end
			etp += (etpg / i)
		end
		# report some progress?
		if verbose
			itrdone += 1
			if itrdone % 10 == 0
				itrrel = round( itrdone/length(evac.aln[1][2])*length(workers())*100,1 )
				println( " ",itrdone," (",itrrel,"%) positions processed" )
			end
		end
		etp
	end
end


# determine consensus sequence of an alignment
function consensusseq ( aln, alphabet )
	# do for each position
	cons = Char[]
	for pos in 1:length(aln[1][2])
		re, rn = countresinums( aln, pos, alphabet )
		if length(re) == 0
			println( "   ! Warning: possible gap-only column (",pos,") !")
			println( "   ! Remove such columns and rerun !")
			cons = vcat( cons, '-' )
		else
			cons = vcat( cons, re[1] )
		end
	end
	# return consensus as string
	return join( cons )
end


# calculate substitution log-odds for pairs of amino acids
#  using a given alignment
function substlogodds! ( evac::EvAc )
	println("calculating substitution log-odds")
	# calculate total number of matches for aa pairs (fij)
	fij = zeros(Int64,20,20)
	# count amino acids for a single alignment
	function countaa ( ali )
		for pos in 1:length(ali[1][2])
			# count number of occurrences for each aa in column
			aa, an = countresinums( ali, pos, evac.alphabet )
			# disregard gap-only columns
			if length(aa) == 0
				continue
			end
			# count number of substitutions from most common
			#  to each other aa
			ix = findin( evac.alphabet, aa[1] )
			fij[ix,ix] += (an[1] * (an[1]-1) / 2)
			j = 2
			while j <= length(aa)
				jx = findin( evac.alphabet, aa[j] )			
				fij[ix,jx] += (an[1] * an[j])
				j += 1
			end
		end
	end
	countaa( evac.aln )
	# calculate substitution frequencies for aa pairs (qij)
	qij = zeros(Float64,20,20)
	for i in 1:size(fij,1)
		rsum = sum( fij[i,:] )
		for j in 1:size(fij,2)
			qij[i,j] = (fij[i,j] / rsum)
		end
	end
	# calculate probability of occurrence for each aa (ej)
	ej = zeros(Float64,20)
	fsum = sum(fij)
	for j in 1:size(fij,2)
		ej[j] = (sum(fij[:,j]) / fsum)
	end
	# calculate log-odds
	sij = ones(Float64,20,20)
	for i in 1:size(qij,1)
		for j in 1:size(qij,2)
			if qij[i,j] > 0
				sij[i,j] = qij[i,j] / ej[j]
			end
		end
	end
	sij = log2(sij)
	# check for zero log-odds indicating undersized data set
	if sum(sij .== 0) > 0
		println( "   ! Warning: some substitution log-odds are zero, indicating undersized data set !" )
	end
	# update log-odds field of the EvAc object
	evac.odds = sij
end

# calculate substitution log-odds for pairs of amino acids
#  using several alignments
function substlogodds ( files::Array{ASCIIString,1}, alphabet::Array{Char,1} )
	if ( length(files) == 1 )
		println("calculating substitution log-odds")
	else
		println("calculating common substitution log-odds")
	end
	# calculate total number of matches for aa pairs (fij)
	fij = zeros(Int64,20,20)
	# count amino acids for a single alignment
	function countaa ( ali )
		for pos in 1:length(ali[1][2])
			# count number of occurrences for each aa in column
			aa, an = countresinums( ali, pos, alphabet )
			# disregard gap-only columns
			if length(aa) == 0
				continue
			end
			# count number of substitutions from most common
			#  to each other aa
			ix = findin( alphabet, aa[1] )
			fij[ix,ix] += (an[1] * (an[1]-1) / 2)
			j = 2
			while j <= length(aa)
				jx = findin( alphabet, aa[j] )			
				fij[ix,jx] += (an[1] * an[j])
				j += 1
			end
		end
	end
	for file in files
		aln = readfasta( file )
		countaa( aln )
	end
	# calculate substitution frequencies for aa pairs (qij)
	qij = zeros(Float64,20,20)
	for i in 1:size(fij,1)
		rsum = sum( fij[i,:] )
		for j in 1:size(fij,2)
			qij[i,j] = (fij[i,j] / rsum)
		end
	end
	# calculate probability of occurrence for each aa (ej)
	ej = zeros(Float64,20)
	fsum = sum(fij)
	for j in 1:size(fij,2)
		ej[j] = (sum(fij[:,j]) / fsum)
	end
	# calculate log-odds
	sij = ones(Float64,20,20)
	for i in 1:size(qij,1)
		for j in 1:size(qij,2)
			if qij[i,j] > 0
				sij[i,j] = qij[i,j] / ej[j]
			end
		end
	end
	sij = log2(sij)
	# check for zero log-odds indicating undersized data set
	if sum(sij .== 0) > 0
		println( "   ! Warning: some substitution log-odds are zero, indicating undersized data set !" )
	end
	# update log-odds field of the EvAc object
	return( sij )
end


# calculate Evolutionary Action (FINAL MEASURE!)
#  using pre-calculated Evolutionary Trace and substitution log-odds
function evolutionaryaction! ( evac::EvAc; returnall::Bool=false )
	println("calculating Evolutionary Action")
	# get consensus sequence of the alignment
	consensus = consensusseq( evac.aln, evac.alphabet )
	# normalize Evolutionary Trace scores to percentiles based on their ranks
	etn = sortrank(evac.et,rev=true) / length(evac.et) * 100
	# normalize substitution log-odds to percentiles based on ranking
	# among all possible substitutions
	subs = Float64[]
	for pos in 1:length(consensus)
		ai = findin( evac.alphabet, consensus[pos] )[1]
		for aj in 1:length(evac.alphabet)
			subs = vcat( subs, evac.odds[ai,aj] )
		end
	end
	subsn = sortrank(subs,rev=true) / length(subs) * 100
	# calculate EA for each possible substitution 
	ea = Float64[]
	for pos in 1:length(consensus)
		for aj in 1:length(evac.alphabet)
			ea = vcat( ea, etn[pos] * subsn[ (pos-1)*20+aj ] )
		end
	end
	# normalize EA scores
	ean = sortrank(ea) / length(ea) * 100
	# get EA scores for individual mutations in each sequence
	eam = zeros(Float64,length(evac.aln),length(consensus))
	for si in 1:length(evac.aln)
		for pos in 1:length(consensus)
			resi = evac.aln[si][2][pos]
			aj   = findin( evac.alphabet,resi )
			if length(aj) == 0
				aj = findin( evac.alphabet, consensus[pos] )
			end
			eam[si,pos] = ean[ (pos-1)*20+aj[1] ]
		end
	end
	# update ea field of EvAc object
	evac.ea = eam
	# optionally return EA scores for each possible substitution
	if returnall
		return reshape( ean, (length(alphabet),length(consensus)) )
	end
end


# print substitution log-odds matrix to file
function printlogodds( evac::EvAc, file; digits::Int64=2 )
	# open file for writing
	outf = open( file, "w" )
	# write matrix to file
	write( outf, join(vcat("",evac.alphabet,"\n"), "\t") )
	for i in 1:size(evac.odds,1)
		row = round( evac.odds[i,:], digits )
		write( outf, join(hcat(string(evac.alphabet[i]),row,"\n"), "\t") )
	end
	# close file
	close(outf)
end


# read substitution log-odds matrix from file
function readlogodds( file )
	# read data from file
	inp  = readdlm( file )[ 2:end,2:end ]
	# convert data type
	odds = convert( Array{Float64,2},inp )
	# return log-odds
	return odds
end


# print final EA scores to file
function printea( evac::EvAc, file; digits=2 )
	# open file for writing
	outf = open( file, "w" )
	# write EA scores to file
	for i in 1:size(evac.ea,1)
		row = round( evac.ea[i,:], digits )
		sid = evac.aln[i][1]
		write( outf, join(hcat(sid,row,"\n"), "\t") )
	end
	# close file
	close(outf)
end


# run full analysis for a single alignment
function runea( file::ASCIIString; threads::Int64=1, verbose::Bool=false )
	# calculate tree and init EvAc object
	evac = maketree( file, threads=threads )
	# compute substitution log-odds
	substlogodds!( evac )
	# compute evolutionary trace scores
	rvevolutionarytrace!( evac, verbose=verbose )
	# compute evolutionary action scores
	evolutionaryaction!( evac )	
	# return results
	return( evac )
end


# run full analysis in batch mode
#  using all alignments in specified folder
#  common substitution log-odds will be calculated
function runea( folder::ASCIIString, resdir::ASCIIString; threads::Int64=1, verbose::Bool=true )
	# get all fasta alignment filenames in folder
	alnfiles = filter( x->ismatch(r".fas[A]*$",x), readdir(folder) )
	resfiles = map( x->string(resdir,"/",x,"-EA.txt"), alnfiles )
	map!( x->string(folder,"/",x), alnfiles )
	alnfiles = map( ascii, alnfiles )
	resfiles = map( ascii, resfiles )
	# check if proper files in folder
	if length(alnfiles) == 0
		println( "   ! No alignment files found in the specified folder !")
		println( "   ! Make sure all alignment filenames end with '.fas' or '.fasA' !")
		return( false )
	else
		println( length(alnfiles)," alignment files will be analyzed")
		println( "results will be written to ",resdir )
		if nprocs() > 1
			println( "parallel mode enabled - ",nprocs()-1," processors will be used" )
		end
	end
	# check if result directory exists
	if !isdir(resdir)
		mkdir( resdir )
	end
	# compute common substitution log-odds and save to file
	evactmp = EvAc()
	evactmp.odds = substlogodds( alnfiles, evactmp.alphabet )
	printlogodds( evactmp, string(resdir,"/","logodds.txt") )
	# compile tree, ET, and EA scores for each alignment
	for i in 1:length(alnfiles)
		# report progress
		println( "analyzing ",alnfiles[i]," ..." )
		# init by tree
		evac  = maketree( alnfiles[i], threads=threads )
		# set substitution log-odds
		evac.odds = evactmp.odds
		# compute evolutionary trace
		rvevolutionarytrace!( evac, verbose=verbose )
		# compute evolutionary action and save to file
		evolutionaryaction!( evac )
		# save evolutionary action to file
		printea( evac, resfiles[i] )
		# report progress
		println( "done with ",alnfiles[i]," ..." )
	end
end

