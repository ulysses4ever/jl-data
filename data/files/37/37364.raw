#sset.jl
import Base.length
import Base.pop!
import Base.shift!
import Base.insert!
import Base.size
import Base.convert
#=
 * @module - sorted set
 * @description - sorted set uses and internal bst
 *  to search and find , maintains uniq based comparator
 *  @after npm sset {0.0.4}
 =#
include("../bs.jl/bs.jl")

#=
 * @description default comparator
 * @param a
 * @param b
 * @returns {number}
 * @private
 =#
cmp(a, b)  = a - b;

#=
 * @description Sorted Set
 * @param array
 * @param comparator
 * @constructor
 =#
 type SSet
 	items::Array
 	cmp::Function
	function SSet(items=tuple(), comparator::Function=cmp)
		this = new()
		T = eltype(items)
		!isa(T, Tuple) && error("items must be tuple type")
		this.items = T[]
		println(typeof(this.items))
		this.cmp   = comparator;
	  #init, addarray
	  addarray(this, items)
	  return this
	end
end

#=
 * @description add item to the Array
 * accepts multiple arguments
 * returns the index of the first item inserted
 * @returns {*}
 =#
function add(arguments...)
  return addarray(this, arguments);
end
push=add

#=
 * @description
 * Add items from an unsorted Array-like object
 * (Note: #add() uses this method with it's arguments object)
 * returns the index of the first item inserted
 * @param array
 * @returns {*}
 =#
function addarray(this::SSet, array)
  first = nothing
  i = length(array)
  while i >= 1
    first = addone(this, array[i])
    i -= 1
  end
  return first;
end

#=
 * @description Adds a single item into the Array
 * @param item
 * @returns {number}
 =#
function addone(this::SSet, item)
	item::eltype(this)
  idx = indexof(this, item);
  if idx <= 0
    index = abs(idx) - 1;
    index < 0 && (index = 1) #1 based indexing
    println(index)
    insert!(this.items, index, item)
  else #already exist replace
    index = idx;
    println(index)
  	splice!(this.items, index, item);
  end
  return index;
end

#=
 * @description
 * Checks for the presence of a value in the Array
 * @param item
 * @returns {boolean}
 =#
function contains(this::SSet,item)
  return this.indexof(item) >= 0;
end

#=
 * @description returns a string summary of contents
 * @returns {string}
 =#
function tostring(this::SSet)
  string(this.items)
end

#=
 * @description item by index from the Array
 * @param idx
 * @returns {*}
 =#
get(this::SSet, idx) = this.items[idx]

#=
 * @description removes an item by value from the Array
 * returns the item that was removed, or undefined if
 * not found
 * @returns {*|undefined}
 =#
rm(this::SSet, value) = rmat(this, indexof(this, value))

#=
 * @description removes an item at an index
 * item rm'ed or undefined - array splice
 * @param index
 * @returns {*|undefined}
 =#
rmat(this::SSet, index)= splice!(this.items, index)

#=
 * @description  binary search for item.
 * Returns the index if the item is found, if not, the index of the item
 * that is the closest match + 1 will be returned as a minus value
 * (that is decided by the binsearch module)
 * @param key
 * @returns {*}
 =#
function indexof(this::SSet, key)  
  return bs(this.items, key, this.cmp)
end

#=
 * @description
 * @return{boolean}
 =#
isempty(this::SSet) = (length(this.items) == 0)

#=
 * @description
 * @return{*}
 =#
first(this::SSet) = get(this, 1)

#=
 * @description
 * @return{*}
 =#
last(this::SSet) = get(this, size(this))

#=
 * @description equivalent of Array#map
 * @returns {*}
 =#
function map(fn::Function, this::SSet)
  return map(fn, this.items);
end

#=
 * @description equivalent of Array#filter
 * @returns {*}
 =#
filter(fn::Function, this::SSet) = filter(fn, this.items)



#=
 * @description equivalent of Array#pop
 * @returns {*}
 =#
pop!(this::SSet) = pop!(this.items)

#=
 * @description equivalent of Array#shift
 * @returns {*}
 =#
shift!(this::SSet,item) = shift!(this.items, item);

#=
 * @description  size of the Array
 * @returns {Number}
 =#
size(this::SSet)   =  length(this.items)
length(this::SSet) = size(this::SSet)

#=
 * @description clear
 =#
function empty(this::SSet)
  	T = eltype(array)
		this.items = isa(T, Tuple) ? T[] : typeof(array)[];
end
clear(this::SSet) = empty(this::SSet)
#=
 * @description Export a copy of the internal Array.
 * @returns {Array}
 =#
toarray(this::SSet) = deepcopy(this.items)
values(this::SSet)  = toarray(this::SSet)