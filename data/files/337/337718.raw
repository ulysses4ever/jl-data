module MonetDB

using PyCall, Nettle
@pyimport struct

export monetdbconn

include("types.jl")

# mapi
function connect(;
				hostname::AbstractString = "localhost",
				port::Int = 50000,
				username::AbstractString = "monetdb",
				password::AbstractString = "monetdb",
				database::AbstractString = "demo",
				language::AbstractString = "sql",
				unix_socket::Any = nothing
				)

	#Julia function opens connection first, then you pass messages for authentication
	conn = try
		Base.connect(hostname, port)
	catch
		error("Could not connect to given hostname/port")
	end

    #Create global to hold constants, remove finicky need for everyone to name
	global monetdbconn = MonetDBConnection(
	(1024 * 8) - 2, 	#MAX_PACKAGE_LENGTH::Int
	"", 				#MSG_PROMPT::AbstractString
	"\1\2\n", 			#MSG_MORE::AbstractString
	"#", 				#MSG_INFO::AbstractString
	"!", 				#MSG_ERROR::AbstractString
	"&", 				#MSG_Q::AbstractString
	"&1", 				#MSG_QTABLE::AbstractString
	"&2", 				#MSG_QUPDATE::AbstractString
	"&3", 				#MSG_QSCHEMA::AbstractString
	"&4", 				#MSG_QTRANS::AbstractString
	"&5", 				#MSG_QPREPARE::AbstractString
	"&6", 				#MSG_QBLOCK::AbstractString
	"%", 				#MSG_HEADER::AbstractString
	"[", 				#MSG_TUPLE::AbstractString
	"=", 				#MSG_TUPLE_NOSLICE::AbstractString
	"^", 				#MSG_REDIRECT::AbstractString
	"=OK", 				#MSG_OK::AbstractString
	0, 					#STATE_INIT::Int
	1, 					#STATE_READY::Int
    0,                  #STATE::Int
	hostname, 			#hostname::AbstractString
	port,				#port::Int
	username,			#username::AbstractString
	password,			#password::AbstractString
	database,			#database::AbstractString
	language,			#language::AbstractString
	unix_socket,		#unix_socket::Any
	conn				#monetdb_socket::TCPSocket
	)

    login!(monetdbconn)
    monetdbconn.STATE = monetdbconn.STATE_READY

	return "Connected to MonetDB: $(hostname):$(port)"
end

function login!(m::MonetDBConnection; iteration::Int = 1)

    challenge = _getblock_inet(m)
    response = _challenge_response(m, challenge)
    _putblock_inet(m, response)
    prompt = _getblock_inet(m)

    if length(prompt) == 0 || prompt == m.MSG_OK
        # Empty response, server is happy
        return "Login Successful"

    elseif startswith(prompt, m.MSG_ERROR)
        error(split(prompt, ":")[3])

    elseif startswith(prompt, m.MSG_REDIRECT)
        # a redirect can contain multiple redirects, only use the first
        redirect = split(prompt[2:end], ":")

        if redirect[2] == "merovingian"

            if iteration <= 10
                login!(m,iteration = iteration + 1)
            else
                error("Maximum number of redirects reached (10)")
            end

        elseif redirect[2] == "monetdb"
             m.hostname = redirect[3][3:end]
             m.port, m.database = redirect[4].split('/')
             typeof(m.port) <: AbstractString ?  m.port = parse(Int,m.port) : m.port
             close(m.monetdb_socket)
             connect(m.hostname, m.port, m.username, m.password, m.database, m.language)
        else
            error(split(prompt, ":")[3])
        end

    else
        error(split(prompt, ":")[3])
    end

end

function disconnect(;m::MonetDBConnection = monetdbconn)

	try
        Base.close(m.monetdb_socket)
        return("MonetDB connection closed")
    catch
        error("An error has occurred")
    end

end

#Incomplete
function cmd(operation::AbstractString=""; m::MonetDBConnection = monetdbconn)
    MonetDB._putblock_inet(m, operation)
    response = MonetDB._getblock_inet(m)
end

#Should be correct, otherwise wouldn't be able to query at all
function _challenge_response(m::MonetDBConnection, challenge::AbstractString)

    challenges = split(challenge, ':')
    salt, identity, protocol, hashes, endian = challenges[1:5]

    if protocol in ("9", '9')
        algo = challenges[6] #sha512
        password_hex = hexdigest(lowercase(algo), m.password)
    else
        error("We only speak protocol v9")
    end

    h = split(hashes, ',')
    if "SHA1" in h
        pwhash = "{SHA1}" * hexdigest("sha1", password_hex * salt)
    elseif "MD5" in h
        pwhash = "{MD5}" * hexdigest("md5", password_hex * salt)
    else
        error("Unsupported hash algorithms required")
    end

    loopstr = ""
    for val in ["BIG", m.username, pwhash, m.language, m.database]
        loopstr *= val * ":"
    end
    return loopstr #Ex: 'BIG:voc:{MD5}211a6fca6f4b3c979970e4bfd9c22f17:sql:voc:'

end

# function _getblock(;connection::Any = "")
#     connection["_getblock"]()
# end

#implement _getbytes in Julia
function _getblock_inet(m::MonetDBConnection)
    result = IOBuffer()
    length = last = 0
    while last != 1
        flag = readbytes(m.monetdb_socket,2)
        unpacked = struct.unpack("<H", flag)[1] # little endian short, needs a Julia replacement
        length = unpacked >> 1
        last = unpacked & 1
        write(result,readbytes(m.monetdb_socket,length))
    end
    return takebuf_string(result)
end

# function _getblock_socket(;connection::Any = "")
#     connection["getblock_socket"]()
# end

# function _putblock(; block::AbstractString="", connection::Any = "")
#     connection["_putblock"](block)
# end

# needs Julia replacement for struct.pack
function _putblock_inet(m::MonetDBConnection, block::AbstractString)
    pos = 1
    last = 0
    while last != 1
        l = length(block)
        if l <= m.MAX_PACKAGE_LENGTH
            data = block[pos:end]
            last = 1
        else
            data = block[pos:pos+m.MAX_PACKAGE_LENGTH]
        end
        flag = struct.pack("<H", (l << 1) + last) #need a Julia replacement
        write(m.monetdb_socket, flag)
        write(m.monetdb_socket, block)
        pos += l
    end
end

end # module
