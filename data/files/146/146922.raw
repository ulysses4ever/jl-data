# WARNING: This file was generated from fasta.rl using ragel. Do not edit!
# FASTA sequence types

immutable FASTA <: FileFormat end


"Metadata for FASTA sequence records containing just a `description` field"
type FASTAMetadata
    description::StringField
end


function FASTAMetadata()
    return FASTAMetadata(StringField())
end


function (==)(a::FASTAMetadata, b::FASTAMetadata)
    return a.description == b.description
end


function copy(metadata::FASTAMetadata)
    return FASTAMetadata(copy(metadata.description))
end


"FASTASeqRecord{S} is a `SeqRecord` for FASTA sequences of type `S`"
typealias FASTASeqRecord           SeqRecord{Sequence, FASTAMetadata}

"A `SeqRecord` type for FASTA DNA sequences"
typealias FASTADNASeqRecord       DNASeqRecord{FASTAMetadata}

"A `SeqRecord` type for FASTA RNA sequences"
typealias FASTARNASeqRecord       RNASeqRecord{FASTAMetadata}

"A `SeqRecord` type for FASTA amino acid sequences"
typealias FASTAAminoAcidSeqRecord AminoAcidSeqRecord{FASTAMetadata}


function show{S}(io::IO, seqrec::SeqRecord{S, FASTAMetadata})
    write(io, ">", seqrec.name, " ", seqrec.metadata.description, "\n")
    show(io, seqrec.seq)
end


"Writes a FASTASeqRecord to an IO-stream (and obeys FASTAs max character constraint)"
function Base.write{T}(io::IO, seqrec::SeqRecord{T, FASTAMetadata})
    write(io, ">", seqrec.name)
    if !isempty(seqrec.metadata.description)
        write(io, " ", seqrec.metadata.description)
    end
    write(io, "\n")
    maxchars = 79
    counter = 1
    len = length(seqrec.seq)
    for nt in seqrec.seq
        show(io, nt)
        if counter % maxchars == 0 && counter < len
            write(io, "\n")
        end
        counter += 1
    end
    write(io, "\n")
end


const _fastaparser_start  = convert(Int , 6)
const _fastaparser_first_final  = convert(Int , 6)
const _fastaparser_error  = convert(Int , 0)
const _fastaparser_en_main  = convert(Int , 6)
"A type encapsulating the current state of a FASTA parser"
type FASTAParser <: AbstractParser
    state::Ragel.State
    seqbuf::BufferedOutputStream{BufferedStreams.EmptyStreamSource}
    default_alphabet::Alphabet

    function FASTAParser(input::BufferedInputStream)
        cs = _fastaparser_start;
	return new(Ragel.State(cs, input), BufferedOutputStream(), DNA_ALPHABET)
    end
end


function eltype(::Type{FASTAParser})
    return FASTASeqRecord
end


function open(input::BufferedInputStream, ::Type{FASTA})
    return FASTAParser(input)
end


typealias FASTAAnySeqRecord{S} SeqRecord{S, FASTAMetadata}

Ragel.@generate_read_fuction("_fastaparser", FASTAParser, FASTAAnySeqRecord,
    begin
        if p == pe
	@goto _test_eof

end
@switch cs  begin
    @case 6
@goto st_case_6
@case 0
@goto st_case_0
@case 1
@goto st_case_1
@case 2
@goto st_case_2
@case 3
@goto st_case_3
@case 4
@goto st_case_4
@case 7
@goto st_case_7
@case 8
@goto st_case_8
@case 5
@goto st_case_5

end
@goto st_out
@label ctr13
	state.linenum += 1
@goto st6
@label st6
p+= 1;
	if p == pe
	@goto _test_eof6

end
@label st_case_6
@switch ( data[1 + p ])  begin
    @case 9
@goto st6
@case 10
@goto ctr13
@case 32
@goto st6
@case 62
@goto st1

end
if 11 <= ( data[1 + p ]) && ( data[1 + p ]) <= 13
	@goto st6

end
@goto st0
@label st_case_0
@label st0
cs = 0;
	@goto _out
@label ctr17
	if seqtype(typeof(output)) == Sequence
            alphabet = infer_alphabet(input.seqbuf.buffer, 1,
                                       length(input.seqbuf), input.default_alphabet)
            ET = alphabet_type[alphabet]
            if ET == typeof(output.seq)
                copy!(output.seq, input.seqbuf.buffer, 1, length(input.seqbuf))
            else
                output.seq = ET(input.seqbuf.buffer, 1, length(input.seqbuf),
                                mutable=true)
            end
            input.default_alphabet = alphabet
        else
            copy!(output.seq, input.seqbuf.buffer, 1, length(input.seqbuf))
        end
        empty!(input.seqbuf)
        yield = true;
        	p+= 1; cs = 1; @goto _out



@goto st1
@label ctr21
	Ragel.@append_from_anchor!(input.seqbuf)
	if seqtype(typeof(output)) == Sequence
            alphabet = infer_alphabet(input.seqbuf.buffer, 1,
                                       length(input.seqbuf), input.default_alphabet)
            ET = alphabet_type[alphabet]
            if ET == typeof(output.seq)
                copy!(output.seq, input.seqbuf.buffer, 1, length(input.seqbuf))
            else
                output.seq = ET(input.seqbuf.buffer, 1, length(input.seqbuf),
                                mutable=true)
            end
            input.default_alphabet = alphabet
        else
            copy!(output.seq, input.seqbuf.buffer, 1, length(input.seqbuf))
        end
        empty!(input.seqbuf)
        yield = true;
        	p+= 1; cs = 1; @goto _out



@goto st1
@label st1
p+= 1;
	if p == pe
	@goto _test_eof1

end
@label st_case_1
if ( data[1 + p ]) == 32
	@goto st0

end
if ( data[1 + p ]) < 14
	if 9 <= ( data[1 + p ])
	@goto st0

end

elseif ( ( data[1 + p ]) > 31  )
	if 33 <= ( data[1 + p ])
	@goto ctr0

end

else
	@goto ctr0

end
@goto ctr0
@label ctr0
	Ragel.@anchor!
@goto st2
@label st2
p+= 1;
	if p == pe
	@goto _test_eof2

end
@label st_case_2
@switch ( data[1 + p ])  begin
    @case 9
@goto ctr3
@case 10
@goto ctr4
@case 11
@goto ctr3
@case 12
@goto st0
@case 13
@goto ctr5
@case 32
@goto ctr3

end
if ( data[1 + p ]) > 31
	if 33 <= ( data[1 + p ])
	@goto st2

end

elseif ( ( data[1 + p ]) >= 14  )
	@goto st2

end
@goto st2
@label ctr3
	Ragel.@copy_from_anchor!(output.name)
@goto st3
@label st3
p+= 1;
	if p == pe
	@goto _test_eof3

end
@label st_case_3
@switch ( data[1 + p ])  begin
    @case 9
@goto st3
@case 10
@goto ctr6
@case 11
@goto st3
@case 32
@goto st3

end
if ( data[1 + p ]) > 31
	if 33 <= ( data[1 + p ])
	@goto ctr6

end

elseif ( ( data[1 + p ]) >= 12  )
	@goto ctr6

end
@goto ctr6
@label ctr6
	Ragel.@anchor!
@goto st4
@label st4
p+= 1;
	if p == pe
	@goto _test_eof4

end
@label st_case_4
@switch ( data[1 + p ])  begin
    @case 10
@goto ctr9
@case 13
@goto ctr10

end
if ( data[1 + p ]) > 12
	if 14 <= ( data[1 + p ])
	@goto st4

end

elseif ( ( data[1 + p ]) >= 11  )
	@goto st4

end
@goto st4
@label ctr4
	Ragel.@copy_from_anchor!(output.name)
	state.linenum += 1
@goto st7
@label ctr9
	Ragel.@copy_from_anchor!(output.metadata.description)
	state.linenum += 1
@goto st7
@label ctr11
	state.linenum += 1
@goto st7
@label ctr19
	Ragel.@append_from_anchor!(input.seqbuf)
@goto st7
@label ctr20
	Ragel.@append_from_anchor!(input.seqbuf)
	state.linenum += 1
@goto st7
@label st7
p+= 1;
	if p == pe
	@goto _test_eof7

end
@label st_case_7
@switch ( data[1 + p ])  begin
    @case 9
@goto st7
@case 10
@goto ctr11
@case 32
@goto st7
@case 62
@goto ctr17

end
if ( data[1 + p ]) < 14
	if 11 <= ( data[1 + p ])
	@goto st7

end

elseif ( ( data[1 + p ]) > 31  )
	if ( data[1 + p ]) > 61
	if 63 <= ( data[1 + p ])
	@goto ctr15

end

elseif ( ( data[1 + p ]) >= 33  )
	@goto ctr15

end

else
	@goto ctr15

end
@goto ctr15
@label ctr15
	Ragel.@anchor!
@goto st8
@label st8
p+= 1;
	if p == pe
	@goto _test_eof8

end
@label st_case_8
@switch ( data[1 + p ])  begin
    @case 9
@goto ctr19
@case 10
@goto ctr20
@case 32
@goto ctr19
@case 62
@goto ctr21

end
if ( data[1 + p ]) < 14
	if 11 <= ( data[1 + p ])
	@goto ctr19

end

elseif ( ( data[1 + p ]) > 31  )
	if ( data[1 + p ]) > 61
	if 63 <= ( data[1 + p ])
	@goto st8

end

elseif ( ( data[1 + p ]) >= 33  )
	@goto st8

end

else
	@goto st8

end
@goto st8
@label ctr5
	Ragel.@copy_from_anchor!(output.name)
@goto st5
@label ctr10
	Ragel.@copy_from_anchor!(output.metadata.description)
@goto st5
@label st5
p+= 1;
	if p == pe
	@goto _test_eof5

end
@label st_case_5
if ( data[1 + p ]) == 10
	@goto ctr11

end
@goto st0
@label st_out
@label _test_eof6
cs = 6; @goto _test_eof
@label _test_eof1
cs = 1; @goto _test_eof
@label _test_eof2
cs = 2; @goto _test_eof
@label _test_eof3
cs = 3; @goto _test_eof
@label _test_eof4
cs = 4; @goto _test_eof
@label _test_eof7
cs = 7; @goto _test_eof
@label _test_eof8
cs = 8; @goto _test_eof
@label _test_eof5
cs = 5; @goto _test_eof
@label _test_eof
if p == eof
	@switch cs  begin
    @case 7
	if seqtype(typeof(output)) == Sequence
            alphabet = infer_alphabet(input.seqbuf.buffer, 1,
                                       length(input.seqbuf), input.default_alphabet)
            ET = alphabet_type[alphabet]
            if ET == typeof(output.seq)
                copy!(output.seq, input.seqbuf.buffer, 1, length(input.seqbuf))
            else
                output.seq = ET(input.seqbuf.buffer, 1, length(input.seqbuf),
                                mutable=true)
            end
            input.default_alphabet = alphabet
        else
            copy!(output.seq, input.seqbuf.buffer, 1, length(input.seqbuf))
        end
        empty!(input.seqbuf)
        yield = true;
        	p+= 1; cs = 0; @goto _out




	break;
	@case 8
	Ragel.@append_from_anchor!(input.seqbuf)
	if seqtype(typeof(output)) == Sequence
            alphabet = infer_alphabet(input.seqbuf.buffer, 1,
                                       length(input.seqbuf), input.default_alphabet)
            ET = alphabet_type[alphabet]
            if ET == typeof(output.seq)
                copy!(output.seq, input.seqbuf.buffer, 1, length(input.seqbuf))
            else
                output.seq = ET(input.seqbuf.buffer, 1, length(input.seqbuf),
                                mutable=true)
            end
            input.default_alphabet = alphabet
        else
            copy!(output.seq, input.seqbuf.buffer, 1, length(input.seqbuf))
        end
        empty!(input.seqbuf)
        yield = true;
        	p+= 1; cs = 0; @goto _out




	break;

end

end
@label _out
end)



