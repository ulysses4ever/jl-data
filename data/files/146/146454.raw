# WARNING: This file was generated from bed.rl using ragel. Do not edit!
immutable BED <: FileFormat end

@doc """
Metadata for BED interval records.
""" ->
immutable BEDMetadata
    name::Nullable{String}
    score::Nullable{Int}
    thick_first::Nullable{Int}
    thick_last::Nullable{Int};
    item_rgb::Nullable{RGB{Float32}};
    block_count::Nullable{Int}
    block_sizes::Nullable{Vector{Int}}
    block_firsts::Nullable{Vector{Int}}

    function BEDMetadata(name=Nullable{String}(),
                         score=Nullable{Int}(),
                         thick_first=Nullable{Int}(),
                         thick_last=Nullable{Int}(),
                         item_rgb=Nullable{Float32}(),
                         block_count=Nullable{Int}(),
                         block_sizes=Nullable{Vector{Int}}(),
                         block_firsts=Nullable{Vector{Int}}())
        return new(name, score, thick_first, thick_last, item_rgb,
                   block_count, block_sizes, block_firsts)
    end
end


@doc """
An `Interval` with associated metadata from a BED file.
""" ->
typealias BEDInterval Interval{BEDMetadata}


module BEDParserImpl

import Bio.Intervals: Strand, STRAND_NA, BEDInterval, BEDMetadata
import Bio.Ragel
using Docile, Switch, Compat, Color
export BEDParser, takevalue!


const bed_start  = convert(Int , 41)
const bed_first_final  = convert(Int , 41)
const bed_error  = convert(Int , 0)
const bed_en_main  = convert(Int , 41)
type BEDParser
    state::Ragel.State

    # intermediate values when parsing
    seqname::String
    first::Int64
    last::Int64
    strand::Strand

    red::Float32
    green::Float32
    blue::Float32
    name::Nullable{String}
    score::Nullable{Int}
    thick_first::Nullable{Int}
    thick_last::Nullable{Int};
    item_rgb::Nullable{RGB{Float32}};
    block_count::Nullable{Int}
    block_sizes::Nullable{Vector{Int}}
    block_firsts::Nullable{Vector{Int}}

    function BEDParser(input::Union(IO, String, Vector{Uint8}),
                       memory_map::Bool=false)
        begin
cs = bed_start;
	end
return new(Ragel.State(cs, input, memory_map),
                   "", 0, 0, STRAND_NA, 0.0, 0.0, 0.0,
                   Nullable{String}(), Nullable{Int}(), Nullable{Int}(),
                   Nullable{Int}(), Nullable{RGB{Float32}}(), Nullable{Int}(),
                   Nullable{Vector{Int}}(), Nullable{Vector{Int}}())
    end
end


function Ragel.ragelstate(parser::BEDParser)
    return parser.state
end


function accept_state!(input::BEDParser, output::BEDInterval)
    output = input.nextitem
    input.nextitem = BEDInterval()
end


function takevalue!(input::BEDParser)
    value = BEDInterval(input.seqname, input.first, input.last, input.strand,
                        BEDMetadata(input.name, input.score, input.thick_first,
                                    input.thick_last, input.item_rgb,
                                    input.block_count, input.block_sizes,
                                    input.block_firsts))
    input.strand = STRAND_NA
    name = Nullable{String}()
    score = Nullable{Int}()
    thick_first = Nullable{Int}()
    thick_last = Nullable{Int};()
    item_rgb = Nullable{RGB{Float32}};()
    block_count = Nullable{Int}()
    block_sizes = Nullable{Vector{Int}}()
    block_firsts = Nullable{Vector{Int}}()

    return value
end


Ragel.@generate_read_fuction("bed", BEDParser, BEDInterval,
    begin
        @inbounds begin
            begin
if p == pe 
	@goto _test_eof

end
@switch cs  begin
    @case 41
@goto st_case_41
@case 0
@goto st_case_0
@case 1
@goto st_case_1
@case 2
@goto st_case_2
@case 3
@goto st_case_3
@case 4
@goto st_case_4
@case 5
@goto st_case_5
@case 6
@goto st_case_6
@case 7
@goto st_case_7
@case 8
@goto st_case_8
@case 9
@goto st_case_9
@case 10
@goto st_case_10
@case 11
@goto st_case_11
@case 12
@goto st_case_12
@case 13
@goto st_case_13
@case 14
@goto st_case_14
@case 15
@goto st_case_15
@case 16
@goto st_case_16
@case 17
@goto st_case_17
@case 18
@goto st_case_18
@case 19
@goto st_case_19
@case 20
@goto st_case_20
@case 21
@goto st_case_21
@case 22
@goto st_case_22
@case 23
@goto st_case_23
@case 24
@goto st_case_24
@case 25
@goto st_case_25
@case 26
@goto st_case_26
@case 27
@goto st_case_27
@case 28
@goto st_case_28
@case 29
@goto st_case_29
@case 30
@goto st_case_30
@case 42
@goto st_case_42
@case 31
@goto st_case_31
@case 32
@goto st_case_32
@case 33
@goto st_case_33
@case 34
@goto st_case_34
@case 35
@goto st_case_35
@case 36
@goto st_case_36
@case 37
@goto st_case_37
@case 38
@goto st_case_38
@case 39
@goto st_case_39
@case 40
@goto st_case_40

end
@goto st_out
@label ctr2
begin
	input.state.linenum += 1 
end
@goto st41
@label st41
p+= 1;
	if p == pe 
	@goto _test_eof41

end
@label st_case_41
@switch ( data[1 + p ])  begin
    @case 9
begin
@goto ctr83
end
@case 10
begin
@goto ctr2
end
@case 11
begin
@goto st2
end
@case 13
begin
@goto st3
end
@case 32
begin
@goto ctr84
end

end
if 33 <= ( data[1 + p ]) && ( data[1 + p ]) <= 126 
	begin
@goto ctr85
end

end
begin
@goto st0
end
@label st_case_0
@label st0
cs = 0;
	@goto _out
@label ctr81
begin
	input.seqname      = Ragel.@bytestring_from_mark! 
end
@goto st1
@label ctr83
begin
	Ragel.@pushmark! 
end
begin
	input.seqname      = Ragel.@bytestring_from_mark! 
end
@goto st1
@label st1
p+= 1;
	if p == pe 
	@goto _test_eof1

end
@label st_case_1
@switch ( data[1 + p ])  begin
    @case 9
begin
@goto st2
end
@case 10
begin
@goto ctr2
end
@case 11
begin
@goto st2
end
@case 13
begin
@goto st3
end
@case 32
begin
@goto st2
end

end
if 48 <= ( data[1 + p ]) && ( data[1 + p ]) <= 57 
	begin
@goto ctr4
end

end
begin
@goto st0
end
@label st2
p+= 1;
	if p == pe 
	@goto _test_eof2

end
@label st_case_2
@switch ( data[1 + p ])  begin
    @case 9
begin
@goto st2
end
@case 10
begin
@goto ctr2
end
@case 11
begin
@goto st2
end
@case 13
begin
@goto st3
end
@case 32
begin
@goto st2
end

end
begin
@goto st0
end
@label st3
p+= 1;
	if p == pe 
	@goto _test_eof3

end
@label st_case_3
if ( data[1 + p ]) == 10 
	begin
@goto ctr2
end

end
begin
@goto st0
end
@label ctr4
begin
	Ragel.@pushmark! 
end
@goto st4
@label st4
p+= 1;
	if p == pe 
	@goto _test_eof4

end
@label st_case_4
if ( data[1 + p ]) == 9 
	begin
@goto ctr5
end

end
if 48 <= ( data[1 + p ]) && ( data[1 + p ]) <= 57 
	begin
@goto st4
end

end
begin
@goto st0
end
@label ctr5
begin
	input.first        = Ragel.@int64_from_mark! 
end
@goto st5
@label st5
p+= 1;
	if p == pe 
	@goto _test_eof5

end
@label st_case_5
if 48 <= ( data[1 + p ]) && ( data[1 + p ]) <= 57 
	begin
@goto ctr7
end

end
begin
@goto st0
end
@label ctr7
begin
	Ragel.@pushmark! 
end
@goto st6
@label st6
p+= 1;
	if p == pe 
	@goto _test_eof6

end
@label st_case_6
@switch ( data[1 + p ])  begin
    @case 9
begin
@goto ctr8
end
@case 10
begin
@goto ctr9
end
@case 13
begin
@goto ctr10
end

end
if 48 <= ( data[1 + p ]) && ( data[1 + p ]) <= 57 
	begin
@goto st6
end

end
begin
@goto st0
end
@label ctr8
begin
	input.last         = Ragel.@int64_from_mark! 
end
@goto st7
@label st7
p+= 1;
	if p == pe 
	@goto _test_eof7

end
@label st_case_7
@switch ( data[1 + p ])  begin
    @case 9
begin
@goto ctr12
end
@case 10
begin
@goto ctr13
end
@case 13
begin
@goto ctr14
end

end
if 32 <= ( data[1 + p ]) && ( data[1 + p ]) <= 126 
	begin
@goto ctr15
end

end
begin
@goto st0
end
@label ctr12
begin
	Ragel.@pushmark! 
end
begin
	input.name         = Nullable{String}(Ragel.@bytestring_from_mark!) 
end
@goto st8
@label ctr77
begin
	input.name         = Nullable{String}(Ragel.@bytestring_from_mark!) 
end
@goto st8
@label st8
p+= 1;
	if p == pe 
	@goto _test_eof8

end
@label st_case_8
if 48 <= ( data[1 + p ]) && ( data[1 + p ]) <= 57 
	begin
@goto ctr16
end

end
begin
@goto st0
end
@label ctr16
begin
	Ragel.@pushmark! 
end
@goto st9
@label st9
p+= 1;
	if p == pe 
	@goto _test_eof9

end
@label st_case_9
@switch ( data[1 + p ])  begin
    @case 9
begin
@goto ctr17
end
@case 10
begin
@goto ctr18
end
@case 13
begin
@goto ctr19
end

end
if 48 <= ( data[1 + p ]) && ( data[1 + p ]) <= 57 
	begin
@goto st9
end

end
begin
@goto st0
end
@label ctr17
begin
	input.score        = Ragel.@int64_from_mark! 
end
@goto st10
@label st10
p+= 1;
	if p == pe 
	@goto _test_eof10

end
@label st_case_10
@switch ( data[1 + p ])  begin
    @case 43
begin
@goto ctr21
end
@case 45
begin
@goto ctr21
end

end
begin
@goto st0
end
@label ctr21
begin
	input.strand       = convert(Strand, Ragel.@char) 
end
@goto st11
@label st11
p+= 1;
	if p == pe 
	@goto _test_eof11

end
@label st_case_11
@switch ( data[1 + p ])  begin
    @case 9
begin
@goto st12
end
@case 10
begin
@goto ctr23
end
@case 13
begin
@goto st33
end

end
begin
@goto st0
end
@label st12
p+= 1;
	if p == pe 
	@goto _test_eof12

end
@label st_case_12
if 48 <= ( data[1 + p ]) && ( data[1 + p ]) <= 57 
	begin
@goto ctr25
end

end
begin
@goto st0
end
@label ctr25
begin
	Ragel.@pushmark! 
end
@goto st13
@label st13
p+= 1;
	if p == pe 
	@goto _test_eof13

end
@label st_case_13
@switch ( data[1 + p ])  begin
    @case 9
begin
@goto ctr26
end
@case 10
begin
@goto ctr27
end
@case 13
begin
@goto ctr28
end

end
if 48 <= ( data[1 + p ]) && ( data[1 + p ]) <= 57 
	begin
@goto st13
end

end
begin
@goto st0
end
@label ctr26
begin
	input.thick_first  = Ragel.@int64_from_mark! 
end
@goto st14
@label st14
p+= 1;
	if p == pe 
	@goto _test_eof14

end
@label st_case_14
if 48 <= ( data[1 + p ]) && ( data[1 + p ]) <= 57 
	begin
@goto ctr30
end

end
begin
@goto st0
end
@label ctr30
begin
	Ragel.@pushmark! 
end
@goto st15
@label st15
p+= 1;
	if p == pe 
	@goto _test_eof15

end
@label st_case_15
@switch ( data[1 + p ])  begin
    @case 9
begin
@goto ctr31
end
@case 10
begin
@goto ctr32
end
@case 13
begin
@goto ctr33
end

end
if 48 <= ( data[1 + p ]) && ( data[1 + p ]) <= 57 
	begin
@goto st15
end

end
begin
@goto st0
end
@label ctr31
begin
	input.thick_last   = Ragel.@int64_from_mark! 
end
@goto st16
@label st16
p+= 1;
	if p == pe 
	@goto _test_eof16

end
@label st_case_16
if 48 <= ( data[1 + p ]) && ( data[1 + p ]) <= 57 
	begin
@goto ctr35
end

end
begin
@goto st0
end
@label ctr35
begin
	Ragel.@pushmark! 
end
@goto st17
@label st17
p+= 1;
	if p == pe 
	@goto _test_eof17

end
@label st_case_17
@switch ( data[1 + p ])  begin
    @case 9
begin
@goto ctr36
end
@case 10
begin
@goto ctr37
end
@case 11
begin
@goto ctr38
end
@case 13
begin
@goto ctr39
end
@case 32
begin
@goto ctr38
end
@case 44
begin
@goto ctr40
end

end
if 48 <= ( data[1 + p ]) && ( data[1 + p ]) <= 57 
	begin
@goto st17
end

end
begin
@goto st0
end
@label ctr36
begin
	input.red = input.green = input.blue = (Ragel.@int64_from_mark!) / 255.0 
end
begin
	input.item_rgb     = RGB{Float32}(input.red, input.green, input.blue ) 
end
@goto st18
@label st18
p+= 1;
	if p == pe 
	@goto _test_eof18

end
@label st_case_18
@switch ( data[1 + p ])  begin
    @case 9
begin
@goto st19
end
@case 11
begin
@goto st19
end
@case 32
begin
@goto st19
end
@case 44
begin
@goto st20
end

end
if 48 <= ( data[1 + p ]) && ( data[1 + p ]) <= 57 
	begin
@goto ctr44
end

end
begin
@goto st0
end
@label ctr38
begin
	input.red = input.green = input.blue = (Ragel.@int64_from_mark!) / 255.0 
end
@goto st19
@label st19
p+= 1;
	if p == pe 
	@goto _test_eof19

end
@label st_case_19
@switch ( data[1 + p ])  begin
    @case 9
begin
@goto st19
end
@case 11
begin
@goto st19
end
@case 32
begin
@goto st19
end
@case 44
begin
@goto st20
end

end
begin
@goto st0
end
@label ctr40
begin
	input.red = input.green = input.blue = (Ragel.@int64_from_mark!) / 255.0 
end
@goto st20
@label st20
p+= 1;
	if p == pe 
	@goto _test_eof20

end
@label st_case_20
@switch ( data[1 + p ])  begin
    @case 9
begin
@goto st20
end
@case 11
begin
@goto st20
end
@case 32
begin
@goto st20
end

end
if 48 <= ( data[1 + p ]) && ( data[1 + p ]) <= 57 
	begin
@goto ctr45
end

end
begin
@goto st0
end
@label ctr45
begin
	Ragel.@pushmark! 
end
@goto st21
@label st21
p+= 1;
	if p == pe 
	@goto _test_eof21

end
@label st_case_21
@switch ( data[1 + p ])  begin
    @case 9
begin
@goto ctr46
end
@case 11
begin
@goto ctr46
end
@case 32
begin
@goto ctr46
end
@case 44
begin
@goto ctr47
end

end
if 48 <= ( data[1 + p ]) && ( data[1 + p ]) <= 57 
	begin
@goto st21
end

end
begin
@goto st0
end
@label ctr46
begin
	input.green        = (Ragel.@int64_from_mark!) / 255.0 
end
@goto st22
@label st22
p+= 1;
	if p == pe 
	@goto _test_eof22

end
@label st_case_22
@switch ( data[1 + p ])  begin
    @case 9
begin
@goto st22
end
@case 11
begin
@goto st22
end
@case 32
begin
@goto st22
end
@case 44
begin
@goto st23
end

end
begin
@goto st0
end
@label ctr47
begin
	input.green        = (Ragel.@int64_from_mark!) / 255.0 
end
@goto st23
@label st23
p+= 1;
	if p == pe 
	@goto _test_eof23

end
@label st_case_23
@switch ( data[1 + p ])  begin
    @case 9
begin
@goto st23
end
@case 11
begin
@goto st23
end
@case 32
begin
@goto st23
end

end
if 48 <= ( data[1 + p ]) && ( data[1 + p ]) <= 57 
	begin
@goto ctr51
end

end
begin
@goto st0
end
@label ctr51
begin
	Ragel.@pushmark! 
end
@goto st24
@label st24
p+= 1;
	if p == pe 
	@goto _test_eof24

end
@label st_case_24
@switch ( data[1 + p ])  begin
    @case 9
begin
@goto ctr52
end
@case 10
begin
@goto ctr53
end
@case 13
begin
@goto ctr54
end

end
if 48 <= ( data[1 + p ]) && ( data[1 + p ]) <= 57 
	begin
@goto st24
end

end
begin
@goto st0
end
@label ctr52
begin
	input.blue         = (Ragel.@int64_from_mark!) / 255.0 
end
begin
	input.item_rgb     = RGB{Float32}(input.red, input.green, input.blue ) 
end
@goto st25
@label st25
p+= 1;
	if p == pe 
	@goto _test_eof25

end
@label st_case_25
if 48 <= ( data[1 + p ]) && ( data[1 + p ]) <= 57 
	begin
@goto ctr44
end

end
begin
@goto st0
end
@label ctr44
begin
	Ragel.@pushmark! 
end
@goto st26
@label st26
p+= 1;
	if p == pe 
	@goto _test_eof26

end
@label st_case_26
@switch ( data[1 + p ])  begin
    @case 9
begin
@goto ctr56
end
@case 10
begin
@goto ctr57
end
@case 13
begin
@goto ctr58
end

end
if 48 <= ( data[1 + p ]) && ( data[1 + p ]) <= 57 
	begin
@goto st26
end

end
begin
@goto st0
end
@label ctr56
begin
	input.block_count  = Ragel.@int64_from_mark! 
end
@goto st27
@label st27
p+= 1;
	if p == pe 
	@goto _test_eof27

end
@label st_case_27
if 48 <= ( data[1 + p ]) && ( data[1 + p ]) <= 57 
	begin
@goto ctr60
end

end
begin
@goto st0
end
@label ctr60
begin
	Ragel.@pushmark! 
end
@goto st28
@label st28
p+= 1;
	if p == pe 
	@goto _test_eof28

end
@label st_case_28
@switch ( data[1 + p ])  begin
    @case 9
begin
@goto ctr61
end
@case 10
begin
@goto ctr62
end
@case 13
begin
@goto ctr63
end
@case 44
begin
@goto ctr64
end

end
if 48 <= ( data[1 + p ]) && ( data[1 + p ]) <= 57 
	begin
@goto st28
end

end
begin
@goto st0
end
@label ctr61
begin
	if isnull(input.block_sizes)
            input.block_sizes = Array(Int, 0)
        end
        push!(get(input.block_sizes), (Ragel.@int64_from_mark!))
    
end
@goto st29
@label st29
p+= 1;
	if p == pe 
	@goto _test_eof29

end
@label st_case_29
if 48 <= ( data[1 + p ]) && ( data[1 + p ]) <= 57 
	begin
@goto ctr66
end

end
begin
@goto st0
end
@label ctr66
begin
	Ragel.@pushmark! 
end
@goto st30
@label st30
p+= 1;
	if p == pe 
	@goto _test_eof30

end
@label st_case_30
@switch ( data[1 + p ])  begin
    @case 10
begin
@goto ctr67
end
@case 13
begin
@goto ctr68
end
@case 44
begin
@goto ctr69
end

end
if 48 <= ( data[1 + p ]) && ( data[1 + p ]) <= 57 
	begin
@goto st30
end

end
begin
@goto st0
end
@label ctr23
begin
	input.state.linenum += 1 
end
@goto st42
@label ctr9
begin
	input.last         = Ragel.@int64_from_mark! 
end
begin
	input.state.linenum += 1 
end
@goto st42
@label ctr13
begin
	Ragel.@pushmark! 
end
begin
	input.name         = Nullable{String}(Ragel.@bytestring_from_mark!) 
end
begin
	input.state.linenum += 1 
end
@goto st42
@label ctr18
begin
	input.score        = Ragel.@int64_from_mark! 
end
begin
	input.state.linenum += 1 
end
@goto st42
@label ctr27
begin
	input.thick_first  = Ragel.@int64_from_mark! 
end
begin
	input.state.linenum += 1 
end
@goto st42
@label ctr32
begin
	input.thick_last   = Ragel.@int64_from_mark! 
end
begin
	input.state.linenum += 1 
end
@goto st42
@label ctr37
begin
	input.red = input.green = input.blue = (Ragel.@int64_from_mark!) / 255.0 
end
begin
	input.item_rgb     = RGB{Float32}(input.red, input.green, input.blue ) 
end
begin
	input.state.linenum += 1 
end
@goto st42
@label ctr53
begin
	input.blue         = (Ragel.@int64_from_mark!) / 255.0 
end
begin
	input.item_rgb     = RGB{Float32}(input.red, input.green, input.blue ) 
end
begin
	input.state.linenum += 1 
end
@goto st42
@label ctr57
begin
	input.block_count  = Ragel.@int64_from_mark! 
end
begin
	input.state.linenum += 1 
end
@goto st42
@label ctr62
begin
	if isnull(input.block_sizes)
            input.block_sizes = Array(Int, 0)
        end
        push!(get(input.block_sizes), (Ragel.@int64_from_mark!))
    
end
begin
	input.state.linenum += 1 
end
@goto st42
@label ctr67
begin
	if isnull(input.block_firsts)
            input.block_firsts = Array(Int, 0)
        end
        push!(get(input.block_firsts), (Ragel.@int64_from_mark!))
    
end
begin
	input.state.linenum += 1 
end
@goto st42
@label ctr78
begin
	input.name         = Nullable{String}(Ragel.@bytestring_from_mark!) 
end
begin
	input.state.linenum += 1 
end
@goto st42
@label st42
p+= 1;
	if p == pe 
	@goto _test_eof42

end
@label st_case_42
@switch ( data[1 + p ])  begin
    @case 9
begin
@goto ctr86
end
@case 10
begin
@goto ctr23
end
@case 11
begin
@goto st32
end
@case 13
begin
@goto st33
end
@case 32
begin
@goto ctr87
end

end
if 33 <= ( data[1 + p ]) && ( data[1 + p ]) <= 126 
	begin
@goto ctr88
end

end
begin
@goto st0
end
@label ctr72
begin
	input.seqname      = Ragel.@bytestring_from_mark! 
end
@goto st31
@label ctr86
begin
	yield = true
        # // fbreak causes will cause the pushmark action for the next seqname
        # // to be skipped, so we do it here
        Ragel.@pushmark!
        begin
	p+= 1; cs = 31; @goto _out

end

    
end
begin
	Ragel.@pushmark! 
end
begin
	input.seqname      = Ragel.@bytestring_from_mark! 
end
@goto st31
@label st31
p+= 1;
	if p == pe 
	@goto _test_eof31

end
@label st_case_31
@switch ( data[1 + p ])  begin
    @case 9
begin
@goto st32
end
@case 10
begin
@goto ctr23
end
@case 11
begin
@goto st32
end
@case 13
begin
@goto st33
end
@case 32
begin
@goto st32
end

end
if 48 <= ( data[1 + p ]) && ( data[1 + p ]) <= 57 
	begin
@goto ctr4
end

end
begin
@goto st0
end
@label st32
p+= 1;
	if p == pe 
	@goto _test_eof32

end
@label st_case_32
@switch ( data[1 + p ])  begin
    @case 9
begin
@goto st32
end
@case 10
begin
@goto ctr23
end
@case 11
begin
@goto st32
end
@case 13
begin
@goto st33
end
@case 32
begin
@goto st32
end

end
begin
@goto st0
end
@label ctr10
begin
	input.last         = Ragel.@int64_from_mark! 
end
@goto st33
@label ctr14
begin
	Ragel.@pushmark! 
end
begin
	input.name         = Nullable{String}(Ragel.@bytestring_from_mark!) 
end
@goto st33
@label ctr19
begin
	input.score        = Ragel.@int64_from_mark! 
end
@goto st33
@label ctr28
begin
	input.thick_first  = Ragel.@int64_from_mark! 
end
@goto st33
@label ctr33
begin
	input.thick_last   = Ragel.@int64_from_mark! 
end
@goto st33
@label ctr39
begin
	input.red = input.green = input.blue = (Ragel.@int64_from_mark!) / 255.0 
end
begin
	input.item_rgb     = RGB{Float32}(input.red, input.green, input.blue ) 
end
@goto st33
@label ctr54
begin
	input.blue         = (Ragel.@int64_from_mark!) / 255.0 
end
begin
	input.item_rgb     = RGB{Float32}(input.red, input.green, input.blue ) 
end
@goto st33
@label ctr58
begin
	input.block_count  = Ragel.@int64_from_mark! 
end
@goto st33
@label ctr63
begin
	if isnull(input.block_sizes)
            input.block_sizes = Array(Int, 0)
        end
        push!(get(input.block_sizes), (Ragel.@int64_from_mark!))
    
end
@goto st33
@label ctr68
begin
	if isnull(input.block_firsts)
            input.block_firsts = Array(Int, 0)
        end
        push!(get(input.block_firsts), (Ragel.@int64_from_mark!))
    
end
@goto st33
@label ctr79
begin
	input.name         = Nullable{String}(Ragel.@bytestring_from_mark!) 
end
@goto st33
@label st33
p+= 1;
	if p == pe 
	@goto _test_eof33

end
@label st_case_33
if ( data[1 + p ]) == 10 
	begin
@goto ctr23
end

end
begin
@goto st0
end
@label ctr87
begin
	yield = true
        # // fbreak causes will cause the pushmark action for the next seqname
        # // to be skipped, so we do it here
        Ragel.@pushmark!
        begin
	p+= 1; cs = 34; @goto _out

end

    
end
begin
	Ragel.@pushmark! 
end
@goto st34
@label st34
p+= 1;
	if p == pe 
	@goto _test_eof34

end
@label st_case_34
@switch ( data[1 + p ])  begin
    @case 9
begin
@goto ctr72
end
@case 10
begin
@goto ctr23
end
@case 11
begin
@goto st32
end
@case 13
begin
@goto st33
end
@case 32
begin
@goto st34
end

end
if 33 <= ( data[1 + p ]) && ( data[1 + p ]) <= 126 
	begin
@goto st35
end

end
begin
@goto st0
end
@label ctr85
begin
	Ragel.@pushmark! 
end
@goto st35
@label ctr88
begin
	yield = true
        # // fbreak causes will cause the pushmark action for the next seqname
        # // to be skipped, so we do it here
        Ragel.@pushmark!
        begin
	p+= 1; cs = 35; @goto _out

end

    
end
begin
	Ragel.@pushmark! 
end
@goto st35
@label st35
p+= 1;
	if p == pe 
	@goto _test_eof35

end
@label st_case_35
if ( data[1 + p ]) == 9 
	begin
@goto ctr75
end

end
if 32 <= ( data[1 + p ]) && ( data[1 + p ]) <= 126 
	begin
@goto st35
end

end
begin
@goto st0
end
@label ctr75
begin
	input.seqname      = Ragel.@bytestring_from_mark! 
end
@goto st36
@label st36
p+= 1;
	if p == pe 
	@goto _test_eof36

end
@label st_case_36
if 48 <= ( data[1 + p ]) && ( data[1 + p ]) <= 57 
	begin
@goto ctr4
end

end
begin
@goto st0
end
@label ctr69
begin
	if isnull(input.block_firsts)
            input.block_firsts = Array(Int, 0)
        end
        push!(get(input.block_firsts), (Ragel.@int64_from_mark!))
    
end
@goto st37
@label st37
p+= 1;
	if p == pe 
	@goto _test_eof37

end
@label st_case_37
@switch ( data[1 + p ])  begin
    @case 10
begin
@goto ctr23
end
@case 13
begin
@goto st33
end

end
if 48 <= ( data[1 + p ]) && ( data[1 + p ]) <= 57 
	begin
@goto ctr66
end

end
begin
@goto st0
end
@label ctr64
begin
	if isnull(input.block_sizes)
            input.block_sizes = Array(Int, 0)
        end
        push!(get(input.block_sizes), (Ragel.@int64_from_mark!))
    
end
@goto st38
@label st38
p+= 1;
	if p == pe 
	@goto _test_eof38

end
@label st_case_38
@switch ( data[1 + p ])  begin
    @case 9
begin
@goto st29
end
@case 10
begin
@goto ctr23
end
@case 13
begin
@goto st33
end

end
if 48 <= ( data[1 + p ]) && ( data[1 + p ]) <= 57 
	begin
@goto ctr60
end

end
begin
@goto st0
end
@label ctr15
begin
	Ragel.@pushmark! 
end
@goto st39
@label st39
p+= 1;
	if p == pe 
	@goto _test_eof39

end
@label st_case_39
@switch ( data[1 + p ])  begin
    @case 9
begin
@goto ctr77
end
@case 10
begin
@goto ctr78
end
@case 13
begin
@goto ctr79
end

end
if 32 <= ( data[1 + p ]) && ( data[1 + p ]) <= 126 
	begin
@goto st39
end

end
begin
@goto st0
end
@label ctr84
begin
	Ragel.@pushmark! 
end
@goto st40
@label st40
p+= 1;
	if p == pe 
	@goto _test_eof40

end
@label st_case_40
@switch ( data[1 + p ])  begin
    @case 9
begin
@goto ctr81
end
@case 10
begin
@goto ctr2
end
@case 11
begin
@goto st2
end
@case 13
begin
@goto st3
end
@case 32
begin
@goto st40
end

end
if 33 <= ( data[1 + p ]) && ( data[1 + p ]) <= 126 
	begin
@goto st35
end

end
begin
@goto st0
end
@label st_out
@label _test_eof41
cs = 41; @goto _test_eof
@label _test_eof1
cs = 1; @goto _test_eof
@label _test_eof2
cs = 2; @goto _test_eof
@label _test_eof3
cs = 3; @goto _test_eof
@label _test_eof4
cs = 4; @goto _test_eof
@label _test_eof5
cs = 5; @goto _test_eof
@label _test_eof6
cs = 6; @goto _test_eof
@label _test_eof7
cs = 7; @goto _test_eof
@label _test_eof8
cs = 8; @goto _test_eof
@label _test_eof9
cs = 9; @goto _test_eof
@label _test_eof10
cs = 10; @goto _test_eof
@label _test_eof11
cs = 11; @goto _test_eof
@label _test_eof12
cs = 12; @goto _test_eof
@label _test_eof13
cs = 13; @goto _test_eof
@label _test_eof14
cs = 14; @goto _test_eof
@label _test_eof15
cs = 15; @goto _test_eof
@label _test_eof16
cs = 16; @goto _test_eof
@label _test_eof17
cs = 17; @goto _test_eof
@label _test_eof18
cs = 18; @goto _test_eof
@label _test_eof19
cs = 19; @goto _test_eof
@label _test_eof20
cs = 20; @goto _test_eof
@label _test_eof21
cs = 21; @goto _test_eof
@label _test_eof22
cs = 22; @goto _test_eof
@label _test_eof23
cs = 23; @goto _test_eof
@label _test_eof24
cs = 24; @goto _test_eof
@label _test_eof25
cs = 25; @goto _test_eof
@label _test_eof26
cs = 26; @goto _test_eof
@label _test_eof27
cs = 27; @goto _test_eof
@label _test_eof28
cs = 28; @goto _test_eof
@label _test_eof29
cs = 29; @goto _test_eof
@label _test_eof30
cs = 30; @goto _test_eof
@label _test_eof42
cs = 42; @goto _test_eof
@label _test_eof31
cs = 31; @goto _test_eof
@label _test_eof32
cs = 32; @goto _test_eof
@label _test_eof33
cs = 33; @goto _test_eof
@label _test_eof34
cs = 34; @goto _test_eof
@label _test_eof35
cs = 35; @goto _test_eof
@label _test_eof36
cs = 36; @goto _test_eof
@label _test_eof37
cs = 37; @goto _test_eof
@label _test_eof38
cs = 38; @goto _test_eof
@label _test_eof39
cs = 39; @goto _test_eof
@label _test_eof40
cs = 40; @goto _test_eof
@label _test_eof
begin
end
if p == eof 
	begin
@switch cs  begin
    @case 42
begin
	yield = true
        # // fbreak causes will cause the pushmark action for the next seqname
        # // to be skipped, so we do it here
        Ragel.@pushmark!
        begin
	p+= 1; cs = 0; @goto _out

end

    
end

	break;
	
end
end

end
@label _out
begin
end
end
end
    end,
    begin
        # TODO: If I'm going to do actual destructive parsing, I
        # need to be able to do some setup here.
        accept_state!(input, output)
    end)



end # module BEDParserImpl


# This inexplicably doesn't work, which is why I qualify BEDParser below.
#using BEDParserImpl

@doc """
An iterator over entries in a BED file or stream.
""" ->
type BEDIterator <: IntervalStream{BEDMetadata}
    parser::BEDParserImpl.BEDParser
    nextitem::Nullable{BEDInterval}
end


@doc """
Parse a BED file.

# Arguments
  * `filename::String`: Path of the BED file.
  * `memory_map::Bool`: If true, attempt to memory map the file on supported
    platforms. (Default: `false`)

# Returns
An iterator over `BEDInterval`s contained in the file.
""" ->
function read(filename::String, ::Type{BED}; memory_map::Bool=false)
    it = BEDIterator(BEDParserImpl.BEDParser(filename, memory_map),
                       Nullable{BEDInterval}())
    return it
end


@doc """
Parse a BED file.

# Arguments
  * `input::IO`: Input stream containing BED data.

# Returns
An iterator over `BEDInterval`s contained in the file.
""" ->
function read(input::IO, ::Type{BED})
    return BEDIterator(BEDParserImpl.BEDParser(input), Nullable{BEDInterval}())
end


function start(it::BEDIterator)
    advance!(it)
    return nothing
end


function advance!(it::BEDIterator)
    isdone = !BEDParserImpl.advance!(it.parser)
    if isdone
        it.nextitem = Nullable{BEDInterval}()
    else
        it.nextitem = BEDParserImpl.takevalue!(it.parser)
    end
end


function next(it::BEDIterator, state::Nothing)
    item = get(it.nextitem)
    advance!(it)
    return item, nothing
end


function done(it::BEDIterator, state::Nothing)
    return isnull(it.nextitem)
end

