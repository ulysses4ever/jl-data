# Number of postags:
const NPOSTAG = 45                     # hardcoding the ptb postag count for now

# Feature specifications:

# Individual dense features are represented with strings like "s1w".
typealias DFeature AbstractString

# DFvec is a String vector specifying a set of dense features.
typealias DFvec{T<:DFeature} Vector{T}

# Individual sparse features are specified using a vector of feature
# names indicating a conjunction, e.g. ["s0w", "s0p"]
typealias SFeature{T<:AbstractString} Vector{T}

# SFVec is an vector of SFeatures specifying a set of sparse features.
typealias SFvec{T<:SFeature} Vector{T}

# Fvec is a union of DFvec and SFvec, which specify dense and sparse
# features respectively.  The user controls what kind of features are
# generated by using the appropriate type of feature vector.
typealias Fvec Union{DFvec,SFvec}


"""

    features(p::Parser, s::Sentence, feats, [x, idx])

Return a feature vector given a [`Parser`](@ref) state, a
[`Sentence`](@ref), and an [`Fvec`](@ref) feature specification
vector.  The last two arguments (optional) can provide a preallocated
output array and an offset position in that array.

Primitive features are represented by strings of the following form:

    [sn]\d?([hlr]\d?)*[wvcpdLabAB]

The meaning of each character is described below. The letter i
represents an optional single digit integer.

|char|meaning|
|:---|:------|
|si|i'th stack word, default i=0 means top|
|ni|i'th buffer word, default i=0 means first|
|hi|i'th degree head, default i=1 means direct head|
|li|i'th leftmost child, default i=1 means the leftmost child|
|ri|i'th rightmost child, default i=1 means the rightmost child|
|w|word|
|v|word vector|
|c|context vector|
|p|postag|
|d|distance to the right using encoding: 1,2,3,4,5-10,10+|
|L|dependency label (0 is ROOT or NONE)|
|a|number of left children.|
|b|number of right children.|
|A|set of left dependency labels|
|B|set of right dependency labels|

For example "sp" or "s0p" indicate the postag of the top stack word,
"n0lL" means the dependency label of the leftmost child of the first
buffer word, "s1d" is the s0s1 distance, "s0d" is the s0n0 distance.

The returned feature vector can be dense (`Vector{Float}`) or sparse
(`Vector{Int}` indicating non-zero positions in a sparse binary
vector).  The choice is marked by the type of the `feats` argument:
for dense output it should be a `Vector{String}`, for sparse output it
should be a `Vector{Vector{String}}`:

    ["s0v","n0lp","n1p"]  # dense feature spec
    [["sw"],["sw","sp"]]  # sparse feature spec

This allows sparse feature specifications to contain elements with
multiple primitive features indicating conjunctions. Some other
notable differences between dense and sparse features are:

* Dense vectors do not support "word", sparse vectors do not support "word vector" or "context vector".
* Sparse vectors represent number of children exactly, dense vectors use the encoding 0,1,...,8,9+.

"""
function features(p::Parser, s::Sentence, feats::DFvec,
                  x::AbstractArray=Array(wtype(s),flen(p,s,feats),1), 
                  xcol::Integer=1)
    if xcol > size(x,2); error("xcol > size(x,2)"); end
    wrows = wdim(s)             # first half word, second half context
    xrows = size(x,1)
    xtype = eltype(x)
    x1 = one(xtype)
    x[:,xcol] = zero(xtype)     # :1800
    nx = 0                      # last entry in x
    nv = wrows >> 1             # size of word/context vector, assumes word vec and context vec concatenated
    nd = p.ndeps
    np = NPOSTAG
    nw = p.nword
    ldep,rdep,lset,rset = getdeps(p)
    for f in feats
        a = getanchor(f,p,ldep,rdep)
        fn = f[end]               # 23
        if fn == 'v'        # 293
            (a>0) && copy!(x, (xcol-1)*xrows+nx+1, s.wvec, (a-1)*wrows+1, nv) # :7976
            nx += nv
        elseif fn == 'c'    # 123
            (a>0) && copy!(x, (xcol-1)*xrows+nx+1, s.wvec, (a-1)*wrows+nv+1, nv) # :8873
            nx += nv
        elseif fn == 'p'    # 4
            (a>0) && (s.postag[a] > np) && error("postag out of bound") # 147
            (a>0) && (x[nx+s.postag[a], xcol] = x1) # 126
            nx += np
        elseif fn == 'd'                 # 3
            d = getrdist(f,p)
            (a>0) && (d>0) && (x[nx+(d>10?6:d>5?5:d), xcol] = x1) # 232
            nx += 6
        elseif fn == 'L'
            (a>0) && (p.deprel[a] > nd) && error("deprel out of bound") # 110
            (a>0) && (x[nx+1+p.deprel[a], xcol] = x1) # 41 first bit for deprel=0 (ROOT)
            nx += (nd+1)
        elseif fn == 'a'
            (a>0) && (lcnt=(isassigned(ldep,a) ? length(ldep[a]) : 0); x[nx+1+(lcnt>9?9:lcnt), xcol] = x1) # 155 0-9
            nx += 10
        elseif fn == 'b'
            (a>0) && (rcnt=(isassigned(rdep,a) ? length(rdep[a]) : 0); x[nx+1+(rcnt>9?9:rcnt), xcol] = x1) # 28  0-9
            nx += 10
        elseif fn == 'A'
            (a>0) && copy!(x, (xcol-1)*xrows+nx+1, Array{wtype(s)}(lset[a]), 1, nd) # :4245
            nx += nd
        elseif fn == 'B'
            (a>0) && copy!(x, (xcol-1)*xrows+nx+1, Array{wtype(s)}(rset[a]), 1, nd) # :126
            nx += nd
        else
            error("Unknown feature $(fn)") # 3
        end
    end
    nx == xrows || error("Bad feature vector length")
    return x
end

function flen(p::Parser, s::Sentence, feats::DFvec)
    nx = 0
    nw = wdim(s) >> 1
    nd = p.ndeps
    for f in feats
        nx += flen1(f[end], nw, nd) # 1129
    end
    return nx
end

function flen1(c::Char, nw::Integer=100, nd::Integer=11, np::Integer=45)
    (c == 'v' ? nw :
     c == 'c' ? nw :
     c == 'p' ? np :
     c == 'd' ? 6 :
     c == 'L' ? (nd+1) :        # ROOT is not included in nd
     c == 'a' ? 10 :
     c == 'b' ? 10 :
     c == 'A' ? nd :
     c == 'B' ? nd :
     error("Unknown feature character $c"))
end

# Utility functions to calculate the size of the feature matrix

xsize(p::Parser, s::Sentence, f::Fvec)=(flen(p,s,f),nmoves(p,s))
xsize(p::Parser, c::Corpus, f::Fvec)=(flen(p,c[1],f),nmoves(p,c))
xsize{T<:Parser}(p::Vector{T}, c::Corpus, f::Fvec)=xsize(p[1],c,f)
ysize(p::Parser, s::Sentence)=(nmoves(p),nmoves(p,s))
ysize(p::Parser, c::Corpus)=(nmoves(p),nmoves(p,c))
ysize{T<:Parser}(p::Vector{T}, c::Corpus)=ysize(p[1],c)

function getdeps{T<:Parser}(p::T)
    nw = p.nword
    nd = p.ndeps
    dr = p.deprel
    ldep = Array(Any,nw)
    rdep = Array(Any,nw)
    lset = Array(Any,nw)
    rset = Array(Any,nw)
    @inbounds for d=1:nw
        h=Int(p.head[d])
        if h==0
            continue
        elseif d<h
            if !isassigned(ldep,h)
                ldep[h]=[d]
                lset[h]=falses(nd)
                lset[h][dr[d]]=true
            else
                push!(ldep[h],d)
                lset[h][dr[d]]=true
            end
        elseif d>h
            if !isassigned(rdep,h)
                rdep[h]=[d]
                rset[h]=falses(nd)
                rset[h][dr[d]]=true
            else
                unshift!(rdep[h],d)
                rset[h][dr[d]]=true
            end
        else
            error("h==d")
        end
    end
    return (ldep,rdep,lset,rset)
end    

function getrdist(f::AbstractString, p::Parser)
    if f[1]=='s'
        if isdigit(f[2]); i=f[2]-'0'; else; i=0; end
            if i>0
                d = p.stack[p.sptr - i + 1] - a
            elseif p.wptr <= p.nword
                d = p.wptr - a
            end
        
    else
        return 0 # dist only defined for stack words
    end
end

function getanchor(f::AbstractString, p::Parser, ldep, rdep)
    f1 = f[1]; f2 = f[2]
    if isdigit(f2)
        i = f2 - '0'            # index
        n = 3                   # next character
    else
        i = 0
        n = 2
    end
    a = 0                       # target word
    if f1 == 's'
        if (p.sptr - i >= 1) # 25
            a = p.stack[p.sptr - i]             # 456
        end
    elseif f1 == 'n'
        if p.wptr + i <= p.nword
            a = p.wptr + i
        end
    else 
        error("feature string should start with [sn]")
    end
    if a==0; return 0; end
    while n < length(f)
        f1 = f[n]; f2 = f[n+1]
        if isdigit(f2)
            i = f2 - '0'
            n = n+2
        else
            i = 1
            n = n+1
        end
        if i <= 0
            error("hlr indexing is one based") # 3 [lrh] is one based, [sn] was zero based
        end
        if f1 == 'l'                              # 2
            if a > p.wptr; error("buffer words other than n0 do not have ldeps"); end # 252
            if isassigned(ldep,Int(a)) && i <= length(ldep[a])
                a = ldep[a][i]
            else
                return 0
            end
        elseif f1 == 'r'
            if a >= p.wptr; error("buffer words do not have rdeps"); end
            if isassigned(rdep,Int(a)) && i <= length(rdep[a])
                a = rdep[a][i]
            else
                return 0
            end
        elseif f1 == 'h'
            for j=1:i       # 5
                a = convert(Int,p.head[a]) # 147
                if a == 0
                    return 0
                end
            end
        else 
            break
        end
    end
    if n != length(f); error("n!=length(f)"); end
    return a
end    

# It does not cost anything to increase the height of a
# SparseMatrixCSC, so we'll just use a large fixed height
# (bad idea?)

SFmax = (1<<30)
flen(p::Parser, s::Sentence, feats::SFvec)=SFmax

# We will also use a global dictionary to look up feature-value pairs
# (another bad idea?) (especially for multi-threaded operation!)

SFhash = Dict{Any,Int}()

# All problem variables: NPOSTAG, SFhash, SFmax etc. are Corpus
# variables! TODO: define corpus type to have these. Have parser point
# to sentence and sentence point to corpus?

# Sparse feature extractor:

function features(p::Parser, s::Sentence, feats::SFvec, rowval::Vector{Int}=Array(Int, length(feats)), idx=0)
    if length(rowval) < idx + length(feats); error("features: $((length(rowval),idx,length(feats)))"); end
    for i=1:length(feats)
        f = feats[i]
        v = Array(Any, length(f))                             # TODO: get rid of alloc here
        for j=1:length(f); v[j] = features1(p,s,f[j]); end # 422
        rowval[idx+i] = get!(SFhash, (f,v), 1+length(SFhash)) # 779
    end
    sort!(view(rowval, (idx+1):(idx+length(feats)))) # 10
    if rowval[idx+length(feats)] >= SFmax; error("SFmax exceeded"); end
    return rowval
end


# Here is where the actual feature lookup happens.  Similar to the
# dense lookup.  But does not have to convert everything to a number,
# can return strings etc.  Returns 'nothing' if target word does not
# exist or the feature is not available.

function features1(p::Parser, s::Sentence, f::String)
    if !in(f[1], "sn"); error("feature string should start with [sn]"); end
    (i,n) = isdigit(f[2]) ? (f[2] - '0', 3) : (0, 2) # target index and start of feature spec
    (a,d) = (0,0)           # target word position and right distance
    if ((f[1] == 's') && (p.sptr - i >= 1))
        a = p.stack[p.sptr - i]                    # target word is in the stack
        d = (i>0 ? (p.stack[p.sptr - i + 1] - a) : # distance between two stack words
             p.wptr <= p.nword ? (p.wptr - a) : 0) # distance between top of stack and top of buffer, 0 if buffer empty
    elseif ((f[1] == 'n') && (p.wptr + i <= p.nword))
        a = p.wptr + i          # target word is in the buffer
    end
    (a == 0) && (return nothing) # target word invalid

    # if next character is in "hlr" treat current (a) as an anchor and
    # find the appropriate head, left, right as the actual target
    while (fn=f[n];in(fn, "hlr"))
        d = 0                   # only stack words get distance
        (i,n) = isdigit(f[n+1]) ? (f[n+1] - '0', n+2) : (1, n+1)
        if i <= 0; error("hlr indexing is one based"); end # l1 is the leftmost child, h1 is the direct head etc.
        a == 0 && break
        if fn == 'l'
            if a > p.wptr; error("buffer words other than n0 do not have ldeps"); end
#TODO            j = p.lcnt[a] - i + 1 # leftmost child at highest index
#TODO            a = (j > 0) ? p.ldep[a,j] : 0
        elseif fn == 'r'
            if a >= p.wptr; error("buffer words do not have rdeps"); end
#TODO            j = p.rcnt[a] - i + 1
#TODO            a = (j > 0) ? p.rdep[a,j] : 0
        else # if fn == 'h'
            for j=1:i
                a = p.head[a]
                a == 0 && break
            end
        end
    end
    (a == 0) && (return nothing)

    # At this point (a) should be the target word position and we
    # should only have one character left specifying a feature
    if n != length(f); error(); end
    fn = f[n]
    ((fn == 'w') ? s.form[a] :
     (fn == 'p') ? s.postag[a] :
     (fn == 'd') ? (d>10 ? 6 : d>5 ? 5 : d>0 ? d : nothing) :
     (fn == 'L') ? p.deprel[a] :
     # TODO:
     (fn == 'a') ? 0 : # p.lcnt[a] :
     (fn == 'b') ? 0 : # p.rcnt[a] :
     (fn == 'A') ? [] : # unique(sort(p.deprel[vec(p.ldep[a,1:p.lcnt[a]])])) :
     (fn == 'B') ? [] : # unique(sort(p.deprel[vec(p.rdep[a,1:p.rcnt[a]])])) :
     error("Unknown feature letter $fn"))
end


