using JuMP

# type DummyNLPSolver <: MathProgBase.AbstractMathProgSolver
# end
# type DummyNLPModel <: MathProgBase.AbstractMathProgModel
# end
# MathProgBase.model(s::DummyNLPSolver) = DummyNLPModel()
# function MathProgBase.loadnonlinearproblem!(m::DummyNLPModel, numVar, numConstr, x_l, x_u, g_lb, g_ub, sense, d::MathProgBase.AbstractNLPEvaluator)
#     MathProgBase.initialize(d, [:ExprGraph])
#     println("objexpr = $(MathProgBase.obj_expr(d))")
#     println("isobjlinear(d,1) = $(MathProgBase.isobjlinear(d))")
#     println("isconstrlinear(d,1) = $(MathProgBase.isconstrlinear(d,1))")
#     println("isconstrlinear(d,2) = $(MathProgBase.isconstrlinear(d,2))")
#     println("isconstrlinear(d,3) = $(MathProgBase.isconstrlinear(d,3))")
#     println("constr_expr(d,1) = $(MathProgBase.constr_expr(d,1))")
#     println("constr_expr(d,2) = $(MathProgBase.constr_expr(d,2))")
#     println("constr_expr(d,3) = $(MathProgBase.constr_expr(d,3))")
# end
# #MathProgBase.setwarmstart!(m::DummyNLPModel,x) = nothing
# #MathProgBase.optimize!(m::DummyNLPModel) = nothing
# #MathProgBase.status(m::DummyNLPModel) = :Optimal
# #MathProgBase.getobjval(m::DummyNLPModel) = NaN
# #MathProgBase.getsolution(m::DummyNLPModel) = [1.0,1.0]
# MathProgBase.setvartype!(m::DummyNLPModel, vartype) = nothing

# JuMP version of bonminEx1_Nonlinear.osil
m = Model()
@defVar(m, 0 <= x0 <= 1, Bin)
@defVar(m, x1 >= 0)
@defVar(m, x2 >= 0)
@defVar(m, 0 <= x3 <= 5, Int)
@setObjective(m, Min, x0 - x1 - x2)
#@setNLObjective(m, Min, x1/x2)
@addNLConstraint(m, (x1 - 0.5)^2 + (x2 - 0.5)^2 <= 0.25)
@addConstraint(m, x0 - x1 <= 0)
@addConstraint(m, x1 + x2 + x3 <= 2)
@addNLConstraint(m, 1 <= log(x1/x2))


A = JuMP.prepConstrMatrix(m)
d = JuMP.JuMPNLPEvaluator(m, A)
MathProgBase.initialize(d, [:ExprGraph]);
MathProgBase.obj_expr(d)
MathProgBase.constr_expr(d, 1)
MathProgBase.constr_expr(d, 2)
MathProgBase.constr_expr(d, 3)
MathProgBase.constr_expr(d, 4)


using Compat

osnl_binary = @compat Dict(
    :+     => "plus",
    :.+    => "plus",
    :-     => "minus",
    :.-    => "minus",
    :*     => "times",
    :.*    => "times",
    :/     => "divide",
    :./    => "divide",
    :div   => "quotient",
    :÷     => "quotient",
    #:.÷    => "quotient", # 0.4 only?
    :rem   => "rem",
    :^     => "power",
    :.^    => "power",
    :log   => "log")

osnl_unary = @compat Dict(
    :-     => "negate",
    :√     => "sqrt",
    :ceil  => "ceiling",
    :log   => "ln",
    :log10 => "log10",
    :asin  => "arcsin",
    :asinh => "arcsinh",
    :acos  => "arccos",
    :acosh => "arccosh",
    :atan  => "arctan",
    :atanh => "arctanh",
    :acot  => "arccot",
    :acoth => "arccoth",
    :asec  => "arcsec",
    :asech => "arcsech",
    :acsc  => "arccsc",
    :acsch => "arccsch")

for op in [:abs, :sqrt, :floor, :factorial, :exp, :sign, :erf,
           :sin, :sinh, :cos, :cosh, :tan, :tanh,
           :cot, :coth, :sec, :sech, :csc, :csch]
    osnl_unary[op] = string(op)
end

# ternary :ifelse => "if" ?
# comparison ops

osil_vartypes = @compat Dict(:Cont => "C", :Int => "I", :Bin => "B",
    :SemiCont => "D", :SemiInt => "J", :Fixed => "C")
# assuming lb == ub for all occurrences of :Fixed vars

using LightXML

xdoc = XMLDocument()

xroot = create_root(xdoc, "osil")
set_attribute(xroot, "xmlns", "os.optimizationservices.org")
set_attribute(xroot, "xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance")
set_attribute(xroot, "xsi:schemaLocation", "os.optimizationservices.org " *
    "http://www.optimizationservices.org/schemas/2.0/OSiL.xsd")

instanceHeader = new_child(xroot, "instanceHeader")
add_text(new_child(instanceHeader, "description"),
    "generated by OptimizationServices.jl on " *
    strftime("%Y/%m/%d at %H:%M:%S", time()))

instanceData = new_child(xroot, "instanceData")

variables = new_child(instanceData, "variables")
numVars  = d.m.numCols
varNames = d.m.colNames
varCat   = d.m.colCat
varLower = d.m.colLower
varUpper = d.m.colUpper
set_attribute(variables, "numberOfVariables", "$numVars")
for i = 1:numVars
    vari = new_child(variables, "var")
    set_attribute(vari, "name", varNames[i])
    set_attribute(vari, "type", osil_vartypes[varCat[i]])
    if isfinite(varLower[i])
        set_attribute(vari, "lb", varLower[i])
    end
    if isfinite(varUpper[i])
        set_attribute(vari, "ub", varUpper[i])
    end
end
numConstr = length(d.m.linconstr) + length(d.m.quadconstr) + length(d.m.nlpdata.nlconstr)
# JuMP's getNumConstraints returns only the number of linear constraints!

objectives = new_child(instanceData, "objectives")
set_attribute(objectives, "numberOfObjectives", "1") # can MathProgBase do multi-objective problems?
obj = new_child(objectives, "obj")
set_attribute(obj, "maxOrMin", lowercase(string(d.m.objSense)))
set_attribute(obj, "numberOfObjCoef", "0")
# TODO get coefficients for linear objectives, constraints




free(xdoc)

