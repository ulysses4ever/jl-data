using JuMP

# type DummyNLPSolver <: MathProgBase.AbstractMathProgSolver
# end
# type DummyNLPModel <: MathProgBase.AbstractMathProgModel
# end
# MathProgBase.model(s::DummyNLPSolver) = DummyNLPModel()
# function MathProgBase.loadnonlinearproblem!(m::DummyNLPModel, numVar, numConstr, x_l, x_u, g_lb, g_ub, sense, d::MathProgBase.AbstractNLPEvaluator)
#     MathProgBase.initialize(d, [:ExprGraph])
#     println("objexpr = $(MathProgBase.obj_expr(d))")
#     println("isobjlinear(d,1) = $(MathProgBase.isobjlinear(d))")
#     println("isconstrlinear(d,1) = $(MathProgBase.isconstrlinear(d,1))")
#     println("isconstrlinear(d,2) = $(MathProgBase.isconstrlinear(d,2))")
#     println("isconstrlinear(d,3) = $(MathProgBase.isconstrlinear(d,3))")
#     println("constr_expr(d,1) = $(MathProgBase.constr_expr(d,1))")
#     println("constr_expr(d,2) = $(MathProgBase.constr_expr(d,2))")
#     println("constr_expr(d,3) = $(MathProgBase.constr_expr(d,3))")
# end
# #MathProgBase.setwarmstart!(m::DummyNLPModel,x) = nothing
# #MathProgBase.optimize!(m::DummyNLPModel) = nothing
# #MathProgBase.status(m::DummyNLPModel) = :Optimal
# #MathProgBase.getobjval(m::DummyNLPModel) = NaN
# #MathProgBase.getsolution(m::DummyNLPModel) = [1.0,1.0]
# MathProgBase.setvartype!(m::DummyNLPModel, vartype) = nothing

# JuMP version of bonminEx1_Nonlinear.osil
m = Model()
@defVar(m, 0 <= x0 <= 1, Bin)
@defVar(m, x1 >= 0)
@defVar(m, x2 >= 0)
@defVar(m, 0 <= x3 <= 5, Int)
@setObjective(m, Min, x0 - x1 - x2)
#@setNLObjective(m, Min, x1/x2)
@addNLConstraint(m, (x1 - 0.5)^2 + (x2 - 0.5)^2 <= 0.25)
@addConstraint(m, x0 - x1 <= 0)
@addConstraint(m, x1 + x2 + x3 <= 2)
@addNLConstraint(m, 1 <= log(x1/x2))


A = JuMP.prepConstrMatrix(m)
d = JuMP.JuMPNLPEvaluator(m, A)
MathProgBase.initialize(d, [:ExprGraph]);
MathProgBase.obj_expr(d)
MathProgBase.constr_expr(d, 1)
MathProgBase.constr_expr(d, 2)
MathProgBase.constr_expr(d, 3)
MathProgBase.constr_expr(d, 4)


using Compat

jl2osnl_varargs = @compat Dict(
    :+     => "sum",
    :*     => "prod")

jl2osnl_binary = @compat Dict(
    :+     => "plus",
    :.+    => "plus",
    :-     => "minus",
    :.-    => "minus",
    :*     => "times",
    :.*    => "times",
    :/     => "divide",
    :./    => "divide",
    :div   => "quotient",
    :÷     => "quotient",
    #:.÷    => "quotient", # 0.4 only?
    :rem   => "rem",
    :^     => "power",
    :.^    => "power",
    :log   => "log")

jl2osnl_unary = @compat Dict(
    :-     => "negate",
    :√     => "sqrt",
    :ceil  => "ceiling",
    :log   => "ln",
    :log10 => "log10",
    :asin  => "arcsin",
    :asinh => "arcsinh",
    :acos  => "arccos",
    :acosh => "arccosh",
    :atan  => "arctan",
    :atanh => "arctanh",
    :acot  => "arccot",
    :acoth => "arccoth",
    :asec  => "arcsec",
    :asech => "arcsech",
    :acsc  => "arccsc",
    :acsch => "arccsch")

for op in [:abs, :sqrt, :floor, :factorial, :exp, :sign, :erf,
           :sin, :sinh, :cos, :cosh, :tan, :tanh,
           :cot, :coth, :sec, :sech, :csc, :csch]
    jl2osnl_unary[op] = string(op)
end

# ternary :ifelse => "if" ?
# comparison ops

jl2osil_vartypes = @compat Dict(:Cont => "C", :Int => "I", :Bin => "B",
    :SemiCont => "D", :SemiInt => "J", :Fixed => "C")
# assuming lb == ub for all occurrences of :Fixed vars

using LightXML

xdoc = XMLDocument()

xroot = create_root(xdoc, "osil")
set_attribute(xroot, "xmlns", "os.optimizationservices.org")
set_attribute(xroot, "xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance")
set_attribute(xroot, "xsi:schemaLocation", "os.optimizationservices.org " *
    "http://www.optimizationservices.org/schemas/2.0/OSiL.xsd")

instanceHeader = new_child(xroot, "instanceHeader")
add_text(new_child(instanceHeader, "description"),
    "generated by OptimizationServices.jl on " *
    strftime("%Y/%m/%d at %H:%M:%S", time()))

instanceData = new_child(xroot, "instanceData")

variables = new_child(instanceData, "variables")
numVars  = d.m.numCols
varNames = d.m.colNames
varCat   = d.m.colCat
varLower = d.m.colLower
varUpper = d.m.colUpper
set_attribute(variables, "numberOfVariables", "$numVars")
for i = 1:numVars
    vari = new_child(variables, "var")
    set_attribute(vari, "name", varNames[i])
    set_attribute(vari, "type", jl2osil_vartypes[varCat[i]])
    set_attribute(vari, "lb", varLower[i]) # lb defaults to 0 if not specified!
    if isfinite(varUpper[i])
        set_attribute(vari, "ub", varUpper[i])
    end
end
numConstr = length(d.m.linconstr) + length(d.m.quadconstr) + length(d.m.nlpdata.nlconstr)
# JuMP's getNumConstraints returns only the number of linear constraints!

if true # switch this to disable assertions
    macro assertform(x, y)
        msg = "$x expected to be $y, was :"
        :($x == $y ? nothing : error($msg * string($x)))
    end
else
    macro assertform(x, y)
    end
end

#=
function linexpr2sparsevec(ex)
    # convert a linear expression with possibly unordered and/or duplicated
    # indices into a sparse vector representation with sorted, strictly
    # increasing indices by combining duplicates
    # returns (idx::Vector{Int}, vals::Vector{Float64}, constant::Float64)
    @assertform ex.head :call
    exargs = ex.args
    @assertform exargs[1] :+
    nelem = length(exargs) - 1
    idxorig = Array(Int, nelem)
    valorig = Array(Float64, nelem)
    for i = 1:nelem
        (idxorig[i], valorig[i]) = elem2pair(exargs[i+1])
    end
    idx = Array(Int, nelem) # preallocate
    val = Array(Float64, nelem) # preallocate
    constant = 0.0
    ndupes = 0
    permvec = sortperm(idxorig)

end
=#

function addObjCoef!(obj, elem::Expr, constant, numconstants)
    # add an objective coefficient from elem to obj,
    # where elem is of the form :(val * x[idx])
    @assertform elem.head :call
    elemargs = elem.args
    @assertform elemargs[1] :*
    @assertform length(elemargs) 3
    elemarg3 = elemargs[3]
    @assertform elemarg3.head :ref
    @assertform elemarg3.args[1] :x
    coef = new_child(obj, "coef")
    set_attribute(coef, "idx", elemarg3.args[2] - 1) # OSiL is 0-based
    add_text(coef, string(elemargs[2]))
    # keep a running total for constant offset
    return (constant, numconstants)
end
function addObjCoef!(obj, elem::Float64, constant, numconstants)
    # for anything not an Expr, add it to running total for constant offset
    # currently restricting to ::Float64 for testing, could loosen that later
    return (constant + elem, numconstants + 1)
end

objectives = new_child(instanceData, "objectives")
set_attribute(objectives, "numberOfObjectives", "1") # can MathProgBase do multi-objective problems?
obj = new_child(objectives, "obj")
set_attribute(obj, "maxOrMin", lowercase(string(d.m.objSense)))
# need to create an OsilMathProgModel type with state, set sense during loadnonlinearproblem!
# then implement MathProgBase.getsense for reading it
objexpr = MathProgBase.obj_expr(d)
if MathProgBase.isobjlinear(d)
    @assertform objexpr.head :call
    objexprargs = objexpr.args
    @assertform objexprargs[1] :+
    (constant, numconstants) = (0.0, 0)
    for i = 2:length(objexprargs)
        # TODO: check if we need to do anything about duplicates or sorting!
        (constant, numconstants) =
            addObjCoef!(obj, objexprargs[i], constant, numconstants)
    end
    set_attribute(obj, "numberOfObjCoef", length(objexprargs)-numconstants-1)
    if constant != 0.0
        set_attribute(obj, "constant", constant)
    end
else
    set_attribute(obj, "numberOfObjCoef", "0")
    # nonlinear objective goes in nonlinearExpressions, <nl idx="-1">
end


# writeproblem for nonlinear?


free(xdoc)

