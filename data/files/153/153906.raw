using JuMP

# type DummyNLPSolver <: MathProgBase.AbstractMathProgSolver
# end
# type DummyNLPModel <: MathProgBase.AbstractMathProgModel
# end
# MathProgBase.model(s::DummyNLPSolver) = DummyNLPModel()
# function MathProgBase.loadnonlinearproblem!(m::DummyNLPModel, numVar, numConstr, x_l, x_u, g_lb, g_ub, sense, d::MathProgBase.AbstractNLPEvaluator)
#     MathProgBase.initialize(d, [:ExprGraph])
#     println("objexpr = $(MathProgBase.obj_expr(d))")
#     println("isobjlinear(d,1) = $(MathProgBase.isobjlinear(d))")
#     println("isconstrlinear(d,1) = $(MathProgBase.isconstrlinear(d,1))")
#     println("isconstrlinear(d,2) = $(MathProgBase.isconstrlinear(d,2))")
#     println("isconstrlinear(d,3) = $(MathProgBase.isconstrlinear(d,3))")
#     println("constr_expr(d,1) = $(MathProgBase.constr_expr(d,1))")
#     println("constr_expr(d,2) = $(MathProgBase.constr_expr(d,2))")
#     println("constr_expr(d,3) = $(MathProgBase.constr_expr(d,3))")
# end
# #MathProgBase.setwarmstart!(m::DummyNLPModel,x) = nothing
# #MathProgBase.optimize!(m::DummyNLPModel) = nothing
# #MathProgBase.status(m::DummyNLPModel) = :Optimal
# #MathProgBase.getobjval(m::DummyNLPModel) = NaN
# #MathProgBase.getsolution(m::DummyNLPModel) = [1.0,1.0]
# MathProgBase.setvartype!(m::DummyNLPModel, vartype) = nothing

# JuMP version of bonminEx1_Nonlinear.osil
m = Model()
@defVar(m, 0 <= x0 <= 1, Bin)
@defVar(m, x1 >= 0)
@defVar(m, x2 >= 0)
@defVar(m, 0 <= x3 <= 5, Int)
@setObjective(m, Min, x0 - x1 - x2)
#@setNLObjective(m, Min, x1/x2)
@addNLConstraint(m, (x1 - 0.5)^2 + (x2 - 0.5)^2 <= 0.25)
@addConstraint(m, x0 - x1 <= 0)
@addConstraint(m, x1 + x2 + x3 <= 2)
@addNLConstraint(m, 1 <= log(x1/x2))


#A = JuMP.prepConstrMatrix(m)
#d = JuMP.JuMPNLPEvaluator(m, A)
d = JuMP.JuMPNLPEvaluator(m, JuMP.prepConstrMatrix(m))
MathProgBase.initialize(d, [:ExprGraph]);
MathProgBase.obj_expr(d)
MathProgBase.constr_expr(d, 1)
MathProgBase.constr_expr(d, 2)
MathProgBase.constr_expr(d, 3)
MathProgBase.constr_expr(d, 4)


using LightXML

xdoc = XMLDocument()

xroot = create_root(xdoc, "osil")
set_attribute(xroot, "xmlns", "os.optimizationservices.org")
set_attribute(xroot, "xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance")
set_attribute(xroot, "xsi:schemaLocation", "os.optimizationservices.org " *
    "http://www.optimizationservices.org/schemas/2.0/OSiL.xsd")

instanceHeader = new_child(xroot, "instanceHeader")
add_text(new_child(instanceHeader, "description"),
    "generated by OptimizationServices.jl on " *
    strftime("%Y/%m/%d at %H:%M:%S", time()))

instanceData = new_child(xroot, "instanceData")

variables = new_child(instanceData, "variables")
numVars  = d.m.numCols
varNames = d.m.colNames
varCat   = d.m.colCat
varLower = d.m.colLower
varUpper = d.m.colUpper
set_attribute(variables, "numberOfVariables", "$numVars")
for i = 1:numVars
    vari = new_child(variables, "var")
    set_attribute(vari, "name", varNames[i])
    set_attribute(vari, "type", jl2osil_vartypes[varCat[i]])
    set_attribute(vari, "lb", varLower[i]) # lb defaults to 0 if not specified!
    if isfinite(varUpper[i])
        set_attribute(vari, "ub", varUpper[i])
    end
end
numConstr = length(d.m.linconstr) + length(d.m.quadconstr) + length(d.m.nlpdata.nlconstr)
# JuMP's getNumConstraints returns only the number of linear constraints!

using OptimizationServices

function addObjCoef!(obj, elem::Expr)
    # add an objective coefficient from elem to obj
    (idx, val) = elem2pair(elem)
    coef = new_child(obj, "coef")
    set_attribute(coef, "idx", idx-1) # OSiL is 0-based
    add_text(coef, string(val))
end

objectives = new_child(instanceData, "objectives")
set_attribute(objectives, "numberOfObjectives", "1") # can MathProgBase do multi-objective problems?
obj = new_child(objectives, "obj")
set_attribute(obj, "maxOrMin", lowercase(string(d.m.objSense)))
# need to create an OsilMathProgModel type with state, set sense during loadnonlinearproblem!
# then implement MathProgBase.getsense for reading it
objexpr = MathProgBase.obj_expr(d)
nlobj = false
if MathProgBase.isobjlinear(d)
    @assertform objexpr.head :call
    objexprargs = objexpr.args
    @assertform objexprargs[1] :+
    for i = 2:length(objexprargs)-1
        # TODO: check if we need to do anything about duplicates or sorting!
        addObjCoef!(obj, objexprargs[i])
    end
    numconstants = 0
    elem = objexprargs[end]
    if isa(elem, Expr)
        addObjCoef!(obj, elem)
    else
        # constant - assume there's at most one, and it's always at the end
        if elem != 0.0
            set_attribute(obj, "constant", elem)
            numconstants = 1
        end
    end
    set_attribute(obj, "numberOfObjCoef", length(objexprargs)-numconstants-1)
else
    nlobj = true
    set_attribute(obj, "numberOfObjCoef", "0")
    # nonlinear objective goes in nonlinearExpressions, <nl idx="-1">
end

function constr2bounds(ex::Expr, sense::Symbol, rhs::Float64)
    # return (lb, ub) for a 3-term constraint expression
    if sense == :(<=)
        return (-Inf, rhs)
    elseif sense == :(>=)
        return (rhs, Inf)
    elseif sense == :(==)
        return (rhs, rhs)
    else
        error("Unknown constraint sense $sense")
    end
end
function constr2bounds(lhs::Float64, lsense::Symbol, ex::Expr, rsense::Symbol, rhs::Float64)
    # return (lb, ub) for a 5-term range constraint expression
    if lsense == :(<=) && rsense == :(<=)
        return (lhs, rhs)
    else
        error("Unknown constraint sense $lhs $lsense $ex $rsense $rhs")
    end
end

# create constraints section with bounds during loadnonlinearproblem!
# assume no constant attributes on constraints

# TODO: compare Array{Bool} vs. BitArray here
indicator = fill!(Array(Bool, numVars), false)
densevals = Array(Float64, numVars)
# assume linear constraints are all at start
row = 1
while MathProgBase.isconstrlinear(d, row)
    constrexpr = MathProgBase.constr_expr(d, row)
    @assertform constrexpr.head :comparison
    #(lhs, rhs) = constr2bounds(constrexpr.args...)
    constrlinpart = constrexpr.args[end - 2]
    @assertform constrlinpart.head :call
    constrlinargs = constrlinpart.args
    @assertform constrlinargs[1] :+
    for i = 2:length(constrlinargs)
        (col, val) = elem2pair(constrlinargs[i])
        if indicator[col]
            densevals[col] += val
        else
            indicator[col] = true
            densevals[col] = val
        end
    end
    for col = 1:numVars
        if indicator[col]
            # populate linearConstraintCoefficients here


            # cleanup
            indicator[col] = false # for BitArrays, set to zero all at once?
        end
    end
    row += 1
end
numLinConstr = row - 1


#=
# first pass through linear constraints:
# get column indices and nonzero values in each row,
# do not sort or merge duplicate indices
colcounts = zeros(Int, numVars)
rowstarts_csr = [1]
colinds_csr = Int[]
nzvals_csr = Float64[]
row = 1
# assume linear constraints are all at start
while MathProgBase.isconstrlinear(d, row)
    constrexpr = MathProgBase.constr_expr(d, row)
    @assertform constrexpr.head :comparison
    #(lhs, rhs) = constr2bounds(constrexpr.args...)
    constrlinpart = constrexpr.args[end - 2]
    @assertform constrlinpart.head :call
    constrlinargs = constrlinpart.args
    @assertform constrlinargs[1] :+
    # TODO: compare to JuMP approach of using a BitArray
    # or Array{Bool} here to combine duplicates before transposing
    for i = 2:length(constrlinargs)
        (col, val) = elem2pair(constrlinargs[i])
        colcounts[col] += 1
        push!(colinds_csr, col)
        push!(nzvals_csr, val)
    end
    push!(rowstarts_csr, rowstarts_csr[end] + length(constrlinargs) - 1)
    row += 1
end
numLinConstr = row - 1

# transpose from csr to csc (including duplicate indices)
rowinds_csc = Array(Int, rowstarts_csr[end] - 1)
nzvals_csc = Array(Float64, rowstarts_csr[end] - 1)
colstarts_csc = Array(Int, numVars + 1)
colstarts_csc[1] = 1
for col = 1:numVars
    colstarts_csc[col + 1] = colstarts_csc[col] + colcounts[col]
end
@assert rowstarts_csr[end] == colstarts_csc[end]
fill!(colcounts, 0)
for row = 1:numLinConstr
    for i = rowstarts_csr[row] : rowstarts_csr[row+1]-1
        col = colinds_csr[i]
        rowinds_csc[colstarts_csc[col] + colcounts[col]] = row
        nzvals_csc[colstarts_csc[col] + colcounts[col]] = nzvals_csr[i]
        colcounts[col] += 1
    end
end

# populate linearConstraintCoefficients, checking for and combining duuplicates
=#




# writeproblem for nonlinear?


free(xdoc)

