#Library related to Generation of Initial Solution
#Copyright(c) 2015: Kally Chung

#01...orderD( cardD )
#02...findDemRec( offer, valPA, cardValP, currValP, optDem, diff, currInd, 
#                 valueBin )
#03...convDem( valP, cardValP, optDem )
#04...findDemand( indD, DA, DS, cardP, PA, PE, availP )
#05...assignSetS( indD, setSDem, cardSetS, prob )



include( "IO_MCITW-1P.jl" )
include( "verification.jl" )

function orderD( cardD )
#orderD
#======#
#given a number, return an array with sorted numbers
#
#    input: int cardD
#   output: array sortedD

  sortedD = zeros( Int, cardD)  #output

  aux = zeros( Int, cardD)  #keep which number is available or not
                            #{0-available, 1-already selected}
  count = 0   #count how many numbers have been sorted
  num = 0     #number selected

  #checking process
  if ( cardD <= 0 )
    println( "cardD -> invalid number " )
  end
  
  #selection process
  while( count != (cardD-1) )
    num = rand( 1:cardD )
    if ( aux[ num ] == 0 )
      count +=  1
      sortedD[ count ] = num
      aux[ num ] = 1
    end
  end
  
  #selection process for the last number
  for i in 1:cardD
    if ( aux[i] == 0 )
      sortedD[ cardD ] = i
      break
    end
  end

  return sortedD
end

function findDemRec( offer, valPA, cardValP, currValP, optDem, diff, currInd, valueBin )
#findDemRec
#==========#
#recursive function to find a set of pickups to fullfill offer
#
#    input: int offer -------------> DA
#           array(int) valPA ------> array containing PA's from available pickups
#           int cardValP ----------> number of available pickups
#           array(bool) currValP --> array containing which pickups are being
#                                    considered
#           array(bool) optDem-----> array containing the pickups that will be 
#                                    the demand
#           int diff --------------> difference between offer and sum of PA's
#           int currInd -----------> current index in the recursion
#           bool valueBin ---------> which value is been considered {0,1}
#
#   output: array optDem-----------> array updated containing the solution
#           int diff---------------> difference between offer and sum of PA's
  
  #update array currValP
  currValP[ currInd ] = valueBin
  
  #check if array currValP is a better option than the current one
  if ( currInd == cardValP )
    aux = dot(currValP, valPA)
    aux = offer - aux
    
    #update array currValP case a better option has been found
    if ( ( aux < diff ) && ( aux >= 0 ) )
      for i in 1:cardValP
        optDem[i] = currValP[i]
      end
      diff = aux
    end
    
    return optDem, diff
  else
    #proceeding with the recursion
    (optDem, diff) = findDemRec( offer, valPA, cardValP, currValP, optDem, diff, currInd + 1, 0 )
    (optDem, diff) = findDemRec( offer, valPA, cardValP, currValP, optDem, diff, currInd + 1, 1 )
  end
end

function convDem( valP, cardValP, optDem )
#convDem
#=======#
#convert bool solution from recursive solution into puckups indexes
#
#    input: array(int) valP ------> array containing valids pinckups' indexes
#           int cardValP ---------> valids pickups cardinality
#           array(bool) optDem ---> bool array containing the pickups to 
#                                   fullfill offer
#
#   output: array(int) setSDem ---> array with the pickups indexes to fullfill 
#                                   offer
  
  cardSetS = countnz( optDem )
  setSDem = zeros( Int, cardSetS )
  aux = 1
  for ind in 1:cardValP
    if ( optDem[ ind ] == 1 )
      setSDem[ aux ] = valP[ ind ]
      aux += 1
    end
  end
  
  return setSDem
end

function findDemand( indD, DA, DS, cardP, PA, PE, availP )
#findDemand
#==========#
#look out for a set of pickups to fullfill offer
#
#    input: int indD -------------> delivery index
#           array(int) DA --------> array containing deliveries' amount
#           array(int) DS --------> array containing deliveries' start time of
#                                   the time window
#           int cardP ------------> pickup cardinality
#           array(int) PA --------> array containing pickups' amount
#           array(int) PE --------> array containing pickups' end time of the
#                                   time window
#           array(bool) availP ---> array containing available pickups, which 
#                                   hasn't been assigned
#
#   output: array(int) setSDem ---> array with the pickups to fullfill offer

  #getting the inputs for the recursive function to find set P to fullfill offer
  #offer, valPA, cardValP, currValP, optDem, diff
  offer = DA[ indD ]
  cardValP = 0;
  for j in 1:cardP
    if ( ( PA[j] <= offer ) && ( PE[j] >= DS[ indD ] ) && ( availP[j] == 1 ) )
      cardValP += 1
    end
  end
  valP = zeros( Int, cardValP )
  valPA = zeros( Int, cardValP )
  aux = 1
  for j in 1:cardP
    if ( ( PA[j] <= offer ) && ( PE[j] >= DS[ indD ] ) && ( availP[j] == 1 ) )
      valP[ aux ] = j
      valPA[ aux ] = PA[j]
      aux += 1
    end
  end
  
  #starting recursive function
  currValP = zeros( Int, cardValP )
  optDem = zeros( Int, cardValP )
  diff = offer
  (solArray, solDiff) = findDemRec( offer, valPA, cardValP, currValP, optDem, diff, 1, 0 )
  (solArray, solDiff) = findDemRec( offer, valPA, cardValP, currValP, solArray, solDiff, 1, 1 )
  
  #converting the solution obtained by recursive function
  setSDem = convDem( valP, cardValP, optDem )
  
  return setSDem
end

function assignSetS( indD, setSDem, cardSetS, prob )
#assignSetS
#==========#
#given set S of pickups, assign delivery and pickups from S
#
#    input: int indD -------------> delivery index
#           array(int) setSDem ---> array containing set S of pickups
#           int cardSetS ---------> set S cardinality
#           type prob ------------> parameters of the problem considered
#
#   output: int timeD ------------> delivery D_indD assignment
#           array(int) timeS -----> set S assignment

  #determine timeD
  aux = 0
  timeS = zeros( Int, cardSetS )
  for ind in 1:cardSetS
    aux = setSDem[ ind ]
    timeS[ ind ] = prob.PE[ aux ]
  end
  aux = min( timeS )
  timeD = min( aux, prob.DS[ indD ] )
  
  #determine timeS
  for ind in 1:cardSetS
    aux = setSDem[ ind ]
    timeS[ ind ] = min( timeD, prob.PE[ aux ]
  end
  
  return timeD, timeS
end

function calcCosts( prob, indD, timeD, setSDem, timeS, cardSetS )

  aux = 0
  auxTCost = zeros( Int, cardSetS )
  auxICost = zeros( Int, cardSetS )
  optCdock = 0
  trspCost = 0
  invCost = 0
  
  for k in 1:cardC
    auxICost[k] = prob.CCost[k] * DA[ indD ] * ( cardT - timeD + 1 ) 
    auxTCost[k] = prob.DD[ indD, k ]
    
    for ind in 1:cardSetS
      aux = setSDem[ ind ]
      auxICost[k] -= prob.CCost[k] * prob.PA[ aux ] * ( cardT - timeS[ aux ] + 1 )
      auxTCost[k] += prob.PD[ aux, k ]
    end
  end
  
  ( aux, optCdock ) = findmin( auxICost + auxTCost )
  trspCost = auxTCost[ optCdock ]
  invCost = auxICost[ optCdock ]
  
  auxInvent = zeros( Int, prob.cardT )
  #update inventory level
  aux = prob.DA[ indD ]
  for t in timeD:(prob.cardT)
    auxInvent[t] += aux
  end
  
  for ind in 1:cardSetS
    aux = prob.PA[ ind ]
    for t in timeS[ ind ]:(prob.cardT)
      auxInvent[t] -= aux
    end
  end
  
  #update solution
  #update sol.feas
  sol.trspCost += trspCost
  sol.invCost += invCost
  sol.solX[ indD, optCdock, timeD ] = 1
  for ind in 1:cardSetS
    sol.solY[ setSDem[ind], optCdock, timeS[ind] ] = 1
  end
  for t in 1:(prob.cardT)
    sol.solZ[ optCdock, t ] += auxInvent[t]
  end
  
end
