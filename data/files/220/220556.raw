#optProblem
#==========#
#model the problem MCITW-1P and solve it
#
#Copyright(c) 2015: Kally Chung

#calling libraries
using JuMP, Cbc, MathProgBase
# using JuMP, CPLEX, MathProgBase

# include ( "Tests/00-0instanceMCITW-1P.dat" )
# include ( "test_data.jl" )

#calling solver
m = Model(solver=CbcSolver(seconds=7200, maxNodes=10000000, logLevel=1, ratioGap=0.0001))
# m = Model(solver=CplexSolver(CPX_PARAM_TILIM = 7200, CPX_PARAM_MEMORYEMPHASIS = 1, CPX_PARAM_TRELIM = 4500))

#defining variables
@defVar( m, x[ 1:cardD, 1:cardC, 1:cardT ], Bin )
@defVar( m, y[ 1:cardP, 1:cardC, 1:cardT ], Bin )
@defVar( m, z[ 1:cardC, 1:cardT ] >= 0 ) #check this line
@defVar( m, costTransp )
@defVar( m, costInv )

#setting objective function
@setObjective( m, Min, costTransp + costInv )

#adding constraints
#...each delivery, if it occurs, must occur within its specified time window
for i in 1:cardD
  @addConstraint( m, sum{ x[i,k,t], k = 1:cardC, t = DS[i]:DE[i] } <= 1 )
  @addConstraint( m, sum{ x[i,k,t], k = 1:cardC, t = 1:(DS[i]-1) } + sum{ x[i,k,t], k = 1:cardC, t = (1+DE[i]):cardT } == 0 )
end

#adding constraints
#...each pickup is fullfilled within its specified time window
for j in 1:cardP
  @addConstraint( m, sum{ y[j,k,t], k = 1:cardC, t = PS[j]:PE[j] } == 1 )
  @addConstraint( m, sum{ y[j,k,t], k = 1:cardC, t = 1:(PS[j]-1) } + sum{ y[j,k,t], k = 1:cardC, t = (PE[j]+1):cardT } == 0 )
end

#adding constraints
#...inventory level and upper bound of z[k,t]
for k in 1:cardC
  for t in 1:cardT
    if ( t == 1 )
      @addConstraint( m, z[ k, 1] - sum{ DA[i]*x[i,k,1], i = 1:cardD } + sum{ PA[j]*y[j,k,1], j = 1:cardP } == 0 )
    else
      @addConstraint( m, z[k,t] - z[k, t-1] - sum{DA[i]*x[i,k,t], i = 1:cardD} + sum{ PA[j]*y[j,k,t], j = 1:cardP } == 0 )
    end
    
    @addConstraint( m, z[k,t] <= CCap[k] )
  end
end

#adding constraints
#...transportation cost
@addConstraint( m, sum{ DD[i,k]*x[i,k,t], i = 1:cardD, k = 1:cardC, t = 1:cardT } + sum{ PD[j,k]*y[j,k,t], j = 1:cardP, k = 1:cardC, t = 1:cardT } - costTransp == 0 )

#adding constraints
#...inventory cost
@addConstraint( m, sum{ CCost[k] * z[k,t], k = 1:cardC, t = 1:cardT } - costInv == 0 )

#if you want to check the model
#print(m)

# #set initial solution
# setValue( x[1,3,19], 1 )
# setValue( x[2,2,13], 1 )
# setValue( x[3,3,16], 1 )
# setValue( x[4,2,21], 1 )
# setValue( x[5,3,17], 1 )
# setValue( x[6,3,14], 1 )
# setValue( x[7,2,11], 1 )
# setValue( x[8,2, 9], 1 )
# 
# setValue( y[ 1,2,21], 1 )
# setValue( y[ 2,3,19], 1 )
# setValue( y[ 3,3,14], 1 )
# setValue( y[ 4,2,11], 1 )
# setValue( y[ 5,3,14], 1 )
# setValue( y[ 6,3,19], 1 )
# setValue( y[ 7,3,16], 1 )
# setValue( y[ 8,2,12], 1 )
# setValue( y[ 9,2,13], 1 )
# setValue( y[10,2, 9], 1 )
# setValue( y[11,2,13], 1 )
# setValue( y[12,3,16], 1 )
# setValue( y[13,2,11], 1 )
# setValue( y[14,2, 9], 1 )
# setValue( y[15,3,17], 1 )
# setValue( y[16,2,21], 1 )
# setValue( y[17,3,17], 1 )
# setValue( y[18,3,14], 1 )
# setValue( y[19,2,13], 1 )
# setValue( y[20,3,18], 1 )
# setValue( y[21,2, 9], 1 )
# 
# setValue( z[1, 1],  0 )
# setValue( z[1, 2],  0 )
# setValue( z[1, 3],  0 )
# setValue( z[1, 4],  0 )
# setValue( z[1, 5],  0 )
# setValue( z[1, 6],  0 )
# setValue( z[1, 7],  0 )
# setValue( z[1, 8],  0 )
# setValue( z[1, 9],  0 )
# setValue( z[1,10],  0 )
# setValue( z[1,11],  0 )
# setValue( z[1,12],  0 )
# setValue( z[1,13],  0 )
# setValue( z[1,14],  0 )
# setValue( z[1,15],  0 )
# setValue( z[1,16],  0 )
# setValue( z[1,17],  0 )
# setValue( z[1,18],  0 )
# setValue( z[1,19],  0 )
# setValue( z[1,20],  0 )
# setValue( z[1,21],  0 )
# setValue( z[1,22],  0 )
# setValue( z[1,23],  0 )
# setValue( z[1,24],  0 )
# 
# setValue( z[2, 1],  0 )
# setValue( z[2, 2],  0 )
# setValue( z[2, 3],  0 )
# setValue( z[2, 4],  0 )
# setValue( z[2, 5],  0 )
# setValue( z[2, 6],  0 )
# setValue( z[2, 7],  0 )
# setValue( z[2, 8],  0 )
# setValue( z[2, 9],  2 )
# setValue( z[2,10],  2 )
# setValue( z[2,11], 16 )
# setValue( z[2,12], 14 )
# setValue( z[2,13], 14 )
# setValue( z[2,14], 14 )
# setValue( z[2,15], 14 )
# setValue( z[2,16], 14 )
# setValue( z[2,17], 14 )
# setValue( z[2,18], 14 )
# setValue( z[2,19], 14 )
# setValue( z[2,20], 14 )
# setValue( z[2,21], 17 )
# setValue( z[2,22], 17 )
# setValue( z[2,23], 17 )
# setValue( z[2,24], 17 )
# 
# setValue( z[3, 1],  0 )
# setValue( z[3, 2],  0 )
# setValue( z[3, 3],  0 )
# setValue( z[3, 4],  0 )
# setValue( z[3, 5],  0 )
# setValue( z[3, 6],  0 )
# setValue( z[3, 7],  0 )
# setValue( z[3, 8],  0 )
# setValue( z[3, 9],  0 )
# setValue( z[3,10],  0 )
# setValue( z[3,11],  0 )
# setValue( z[3,12],  0 )
# setValue( z[3,13],  0 )
# setValue( z[3,14],  0 )
# setValue( z[3,15],  0 )
# setValue( z[3,16],  1 )
# setValue( z[3,17], 33 )
# setValue( z[3,18],  1 )
# setValue( z[3,19],  2 )
# setValue( z[3,20],  2 )
# setValue( z[3,21],  2 )
# setValue( z[3,22],  2 )
# setValue( z[3,23],  2 )
# setValue( z[3,24],  2 )
# 
# setValue( costTransp, 37444 )
# setValue( costInv, 9229 )

# sol = Solution( 0, 0, 0, 0, getValue(x), getValue(y), getValue(z) )
# prob = readProblem( "test_anotherData.jl" )
# computeCosts!( prob, sol )
# printSol(prob,sol)

#off to go
tic()
status = solve(m)
eTime = toc()

#printing the solution
#use ">" in linux
if status == :Infeasible
  println("Solver couldn't find solution!")
end

bound = MathProgBase.getobjbound(getInternalModel(m))
absolgap = getObjectiveValue(m) - bound
relatgap = absolgap/getObjectiveValue(m)

println( "elapsed Time: ", eTime )
println( "Objective Value: ", getObjectiveValue(m) )
println( "" )
println( "lower bound: ", bound )
println( "absol.gap: ", absolgap )
println( "relat.gap: ", relatgap )
println( "" )
println( "costTransp =  ", getValue(costTransp) )
println( "costInv: ", getValue(costInv) )
println( "" )

# X = zeros(Int, cardD, cardC, cardT)
# Y = zeros(Int, cardP, cardC, cardT)
# Z = zeros(Int, cardC, cardT)

sol = Solution( 0, 0, 0, 0, zeros( Int, cardD, cardC, cardT), zeros( Int, cardP, cardC, cardT), zeros( Int, cardC, cardT) )
# prob = readProblem( "test_data.jl" )

for i in 1:cardD
  for k in 1:cardC
    for t in 1:cardT
      if ( getValue( x[i,k,t] ) > 0 )
        println( "x[",i,",",k,",",t,"] = ", getValue(x[i,k,t]) )
        sol.solX[i,k,t] = iround( getValue(x[i,k,t]) )
      end
    end
  end
end
println( "" )
for j in 1:cardP
  for k in 1:cardC
    for t in 1:cardT
      if ( getValue( y[j,k,t] ) > 0 )
        println( "y[",j,",",k,",",t,"] = ", getValue(y[j,k,t]) )
        sol.solY[j,k,t] = iround( getValue(y[j,k,t]) )
      end
    end
  end
end
println( "" )
for k in 1:cardC
  for t in 1:cardT
    println( "z[",k,",",t,"] = ", getValue(z[k,t]) )
    sol.solZ[k,t] = iround( getValue(z[k,t]) )
  end
end

computeCosts!( prob, sol )
sol.feas = checkFeas( prob, sol )
aux = sol.trspCost + sol.invCost
println( "" )
println( "Total Cost: $aux" )
printSol(prob,sol)
