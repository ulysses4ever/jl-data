#Library related to Generation of Initial Solution
#Copyright(c) 2015: Kally Chung

#01...orderD( cardD )
#02...findDemRec( offer, valPA, cardValP, currValP, optDem, diff, currInd, 
#                 valueBin )
#03...
#04...
#05...
#06...
#07...

include( "IO_MCITW-1P.jl" )
include( "verification.jl" )
include( "searching.jl" )

function swapPickups( prob, sol )

  aux1 = 0
  aux2 = 0
  
  solNew = copy(sol)
  
  #choosing a pair of deliveries
  indP = rand( 1:prob.cardP, 2 )
  while ( length(indP) != length( unique( indP ) ) ) 
    indP[2] = rand( 1:prob.cardP )
  end
  println("indP = $indP")
  
  #swaping the crossdocks and the times of indP, updating varZ
  aux1 = searchPickupSol( prob, solNew, indP[1] )
  aux2 = searchPickupSol( prob, solNew, indP[2] )
  
  while ( aux1[1] == aux2[1] )
    indP = rand( 1:prob.cardP, 2 )
    while ( length(indP) != length( unique( indP ) ) ) 
      indP[2] = rand( 1:prob.cardP )
    end
    
    aux1 = searchPickupSol( prob, solNew, indP[1] )
    aux2 = searchPickupSol( prob, solNew, indP[2] )
  end
  
  solNew.solY[ indP[1], aux1[1], aux1[2] ] = 0;
  solNew.solY[ indP[2], aux2[1], aux2[2] ] = 0;
  
  if ( ( aux1[1] != 0 ) && ( aux2[1] != 0 ) )
    if ( aux2[2] < PS[ indP[1] ] )
      aux2[2] = PS[ indP[1] ]
    elseif ( aux2[2] > PE[ indP[1] ] )
      aux2[2] = PE[ indP[1] ]
    end
    
    if ( aux1[2] < PS[ indP[2] ] )
      aux1[2] = PS[ indP[2] ]
    elseif ( aux1[2] > PE[ indP[2] ] )
      aux1[2] = PE[ indP[2] ]
    end
    
    solNew.solY[ indP[1], aux2[1], aux2[2] ] = 1;
    solNew.solY[ indP[2], aux1[1], aux1[2] ] = 1;
  
  elseif ( ( aux1[1] == 0 ) && ( aux2[1] != 0 ) )
    if ( aux2[2] < PS[ indP[1] ] )
      aux2[2] = PS[ indP[1] ]
    elseif ( aux2[2] > PE[ indP[1] ] )
      aux2[2] = PE[ indP[1] ]
    end
    
    solNew.solY[ indP[1], aux2[1], aux2[2] ] = 1;
  
  elseif ( ( aux1[1] != 0 ) && ( aux2[1] == 0 ) )
    if ( aux1[2] < PS[ indP[2] ] )
      aux1[2] = PS[ indP[2] ]
    elseif ( aux1[2] > PE[ indP[2] ] )
      aux1[2] = PE[ indP[2] ]
    end
    
    solNew.solY[ indP[2], aux1[1], aux1[2] ] = 1;
    
  end

  computeCosts!( prob, solNew )
  solNew.feas = checkFeas( prob, solNew )
  
  return solNew
  #if necessary, repairing sol
  
  #checking sol factibility
  
end

function swapDelivs( prob, sol )

  aux1 = 0
  aux2 = 0
  
  solNew = copy(sol)
  
  #choosing a pair of pickups
  indD = rand( 1:prob.cardD, 2 )
  while ( length(indD) != length( unique( indD ) ) ) 
    indD[2] = rand( 1:prob.cardD )
  end
  println("indD = $indD")
  
  #swaping the crossdocks and the times of indD, updating sol
  aux1 = searchDelivSol( prob, solNew, indD[1] )
  aux2 = searchDelivSol( prob, solNew, indD[2] )
  
  while ( aux1[1] == aux2[1] )
    indD = rand( 1:prob.cardD, 2 )
    while ( length(indD) != length( unique( indD ) ) ) 
      indD[2] = rand( 1:prob.cardD )
    end
    
    aux1 = searchDelivSol( prob, solNew, indD[1] )
    aux2 = searchDelivSol( prob, solNew, indD[2] )
  end
  
  solNew.solX[ indD[1], aux1[1], aux1[2] ] = 0;
  solNew.solX[ indD[2], aux2[1], aux2[2] ] = 0;
  
  if ( ( aux1[1] != 0 ) && ( aux2[1] != 0 ) )
    if ( aux2[2] < DS[ indD[1] ] )
      aux2[2] = DS[ indD[1] ]
    elseif ( aux2[2] > DE[ indD[1] ] )
      aux2[2] = DE[ indD[1] ]
    end
    
    if ( aux1[2] < DS[ indD[2] ] )
      aux1[2] = DS[ indD[2] ]
    elseif ( aux1[2] > DE[ indD[2] ] )
      aux1[2] = DE[ indD[2] ]
    end
    
    solNew.solX[ indD[1], aux2[1], aux2[2] ] = 1;
    solNew.solX[ indD[2], aux1[1], aux1[2] ] = 1;
  
  elseif ( ( aux1[1] == 0 ) && ( aux2[1] != 0 ) )
    if ( aux2[2] < DS[ indD[1] ] )
      aux2[2] = DS[ indD[1] ]
    elseif ( aux2[2] > DE[ indD[1] ] )
      aux2[2] = DE[ indD[1] ]
    end
    
    solNew.solX[ indD[1], aux2[1], aux2[2] ] = 1;
  
  elseif ( ( aux1[1] != 0 ) && ( aux2[1] == 0 ) )
    if ( aux1[2] < DS[ indD[2] ] )
      aux1[2] = DS[ indD[2] ]
    elseif ( aux1[2] > DE[ indD[2] ] )
      aux1[2] = DE[ indD[2] ]
    end
    
    solNew.solX[ indD[2], aux1[1], aux1[2] ] = 1;
    
  end

  computeCosts!( prob, solNew )
  solNew.feas = checkFeas( prob, solNew )
  
  return solNew
  #if necessary, repairing sol
  
  #checking sol factibility
  
end

function addDeliv( prob, sol )
  
  aux = 0
  numUnfDeliv = 0
  
  solNew = copy(sol)
   
  for i in 1:prob.cardD
    aux = 0
    for k in 1:prob.cardC
      for t in 1:prob.cardT
        if ( sol.solX[ i,k,t ] == 1 )
          aux = 1
        end
      end
    end
    if ( aux == 0 )
      numUnfDeliv += 1
    end
  end
  unfDeliv = zeros( Int, numUnfDeliv )
  
  aux2 = 1
  for i in 1:prob.cardD
    aux = 0
    for k in 1:prob.cardC
      for t in 1:prob.cardT
        if ( sol.solX[ i,k,t ] == 1 )
          aux = 1
        end
      end
    end
    if ( aux == 0 )
      unfDeliv[ aux2 ] = i
      aux2 += 1
    end
  end
  
  println("unfDeliv = $unfDeliv")
  aux = rand( 1:length(unfDeliv) )
  indD = unfDeliv[ aux ]
  println("indD = $indD")
  
  aux = rand( 1:prob.cardC )
  println("aux = $aux")
  numUnfDeliv = rand( prob.DS[indD]:prob.DE[indD] )
  println("numUnfDeliv = $numUnfDeliv")
  
  solNew.solX[ indD, aux, numUnfDeliv ] = 1
  
  computeCosts!( prob, solNew )
  solNew.feas = checkFeas( prob, solNew )
  
  return solNew
  
end