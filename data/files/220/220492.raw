#Library related to verification functions
#Copyright(c) 2015: Kally Chung

#01...checkFeas( sol )
#02...checkFeasDelivTW( prob, sol, indD )
#03...checkFeasPickupTW( prob, sol, indP )
#04...checkFeasInventory( prob, sol, indC )
#05...checkInventoryLevel( prob, sol )
#06...checkCostsGIS( prob, sol )
#

include( "IO_MCITW-1P.jl" )

function checkFeas( prob, sol )
#checkFeasDelivTW
#================#
#given a solution, check feasibility verifying deliveries, pickups and inventory
#
#    input: type prob ------------> parameters of the problem considered
#           type sol -------------> current solution for the problem considered
#
#   output: int feas ------------> 0 if infeasible, 1 otherwise

  #initializing auxiliar variables
  auxFeas = 0
  feas = 1

  #check inventory level
  for k in 1:(prob.cardC)
    auxFeas = checkFeasInventory( prob, sol, k )
    if ( auxFeas == -3 )
#       println("checkFeasInventory - inventory limits exceeds capacity")
      return auxFeas
    elseif ( auxFeas == -4 )
#       println("checkFeasInventory - inventory limits negative")
      return auxFeas
    end
  end
  
  #check deliveries
  for i in 1:(prob.cardD)
    auxFeas = checkFeasDelivTW( prob, sol, i )
    if ( auxFeas == -1 )
#       println("checkFeasDelivTW - fullfilled delivery")
      return auxFeas
    elseif ( auxFeas == -2 )
#       println("checkFeasDelivTW - delivery TW")
      return auxFeas
    end
  end
  
  #check pickups
  for j in 1:(prob.cardP)
    auxFeas = checkFeasPickupTW( prob, sol, j )
    if ( auxFeas == 0 )
#       println("checkFeasPickupTW - unassigned pickup")
      feas = 0
    elseif (  auxFeas == -2  )
#       println("checkFeasPickupTW - pickup TW")
      return auxFeas
    end
  end
  
  return feas
  
end

function checkFeasDelivTW( prob, sol, indD )
#checkFeasDelivTW
#================#
#given a delivery index, check feasibility related to your time window
#
#    input: type prob ------------> parameters of the problem considered
#           type sol -------------> current solution for the problem considered
#           int indD -------------> delivery index
#
#   output: bool feas ------------> 0 if infeasible, 1 otherwise
# 

  #initializing auxiliar variables
  auxWithin = 0
  auxOut = 0
  
  #check out of the time window
  auxTime = prob.DS[ indD ]-1
  for t in 1:auxTime
    for k in 1:(prob.cardC)
      auxOut += sol.solX[ indD, k, t ]
    end
  end
  if ( auxOut > 0 )
    return -2
  end
  
  #check within time window
  for t in (prob.DS[ indD ]):(prob.DE[ indD ])
    for k in 1:(prob.cardC)
      auxWithin += sol.solX[ indD, k, t ]
    end
  end
  if ( auxWithin > 1 )
    return -1
  end

  #check out of the time window
  auxTime = prob.DE[ indD ]+1
  for t in auxTime:(prob.cardT)
    for k in 1:(prob.cardC)
      auxOut += sol.solX[ indD, k, t ]
    end
  end
  if ( auxOut > 0 )
    return -2
  end
  
  return 1
end

function checkFeasPickupTW( prob, sol, indP )
#checkFeasPickupTW
#=================#
#given a pickup index, check feasibility related to your time window
#
#    input: type prob ------------> parameters of the problem considered
#           type sol -------------> current solution for the problem considered
#           int indP -------------> pickup index
#
#   output: bool feas ------------> 0 if infeasible, 1 otherwise
# 

  #initializing auxiliar variables
  auxWithin = 0
  auxOut = 0
  
  #check out of the time window
  auxTime = prob.PS[ indP ]-1
  for t in 1:auxTime
    for k in 1:(prob.cardC)
      auxOut += sol.solY[ indP, k, t ]
    end
  end
  if ( auxOut > 0 )
    return -2
  end
  
  #check within time window
  for t in (prob.PS[ indP ]):(prob.PE[ indP ])
    for k in 1:(prob.cardC)
      auxWithin += sol.solY[ indP, k, t ]
    end
  end
  if ( auxWithin != 1 )
    return 0
  end

  #check out of the time window
  auxTime = prob.PE[ indP ]+1
  for t in auxTime:(prob.cardT)
    for k in 1:(prob.cardC)
      auxOut += sol.solY[ indP, k, t ]
    end
  end
  if ( auxOut > 0 )
    return -2
  end
  
  return 1
end

function checkFeasInventory( prob, sol, indC )
#checkFeasInventory
#==================#
#given a cdock index, check feasibility related to your inventory limits
#
#    input: type prob ------------> parameters of the problem considered
#           type sol -------------> current solution for the problem considered
#           int indC -------------> crossdock index
#
#   output: bool feas ------------> 0 if infeasible, 1 otherwise

  #initializing auxiliar variables
  
  #check inventory limits
  for t in 1:(prob.cardT)
    if ( sol.solZ[ indC, t ] > prob.CCap[ indC ] )
      return -3
    end
    if  ( sol.solZ[ indC, t ] < 0 )
      return -4
    end
  end
  
  return 1
end

function checkInventoryLevel( prob, sol )
#checkInventoryLevel
#===================#
#check if solZ is accurate
#
#    input: type prob ------------> parameters of the problem considered
#           type sol -------------> current solution for the problem considered
#
#   output: bool accur ------------> 0 if is incorrect, 1 otherwise

  #initializing auxiliar variables
  auxArray = zeros( Int, prob.cardC, prob.cardT )
  auxC = 0
  auxT = 0
  
  #delivery
  for i in 1:(prob.cardD)
    auxC = 0
    auxT = 0  
    for k in 1:(prob.cardC)
      for t in 1:(prob.cardT)
        if ( sol.solX[ i,k,t ] == 1 )
          auxC = k
          auxT = t
        end
      end
    end
    
    if ( auxC != 0 )
      for t in auxT:(prob.cardT)
        auxArray[ auxC, t ] += prob.DA[i]
      end
    end
  end
  
  #pickup
  for j in 1:(prob.cardP)
    auxC = 0
    auxT = 0  
    for k in 1:(prob.cardC)
      for t in 1:(prob.cardT)
        if ( sol.solY[ j,k,t ] == 1 )
          auxC = k
          auxT = t
        end
      end
    end
    
    if ( auxC != 0 )
      for t in auxT:(prob.cardT)
        auxArray[ auxC, t ] -= prob.PA[j]
      end
    end
  end
  
  #compare auxArray with solZ
  for k in 1:cardC
    for t = 1:cardT
      if ( auxArray[ k,t ] != sol.solZ[ k,t ] )
        return false
      end
    end
  end
  return true
  
end

#Question: Is the inventory level at indC over the capacity?
#Answer: true if it's capacity exceed
#        false if inventory level is "feasible"
function checkCapacExceed( prob, sol, indC )
#checkInventoryLevel
#===================#
#check if solZ is accurate
#
#    input: type prob ------------> parameters of the problem considered
#           type sol -------------> current solution for the problem considered
#
#   output: bool accur ------------> 0 if is incorrect, 1 otherwise

  for t in 1:prob.cardT
    if ( sol.solZ[indC,t] > prob.CCap[indC] )
      return true #capacity exceed
    end
  end
  
  return false
end

#Question: Is the inventory level at indC negative?
#Answer: true if it's negative
#        false if inventory level is "feasible"
function checkNegLevel( prob, sol, indC )
#checkInventoryLevel
#===================#
#check if solZ is accurate
#
#    input: type prob ------------> parameters of the problem considered
#           type sol -------------> current solution for the problem considered
#
#   output: bool accur ------------> 0 if is incorrect, 1 otherwise

  for t in 1:prob.cardT
    if ( sol.solZ[indC,t] < 0 )
      return true
    end
  end
  
  return false
end

function checkCostsGIS( prob, sol )
#checkCostsGIS
#=============#
#check if all the costs are accurate
#
#    input: type prob ------------> parameters of the problem considered
#           type sol -------------> current solution for the problem considered
#
#   output: bool accur -----------> 0 if is incorrect, 1 otherwise

  #initializing variables
  trspCost = 0
  invCost = 0
  penCost = 0
  
  #transportation cost
  for i in 1:(prob.cardD)
    for k in 1:(prob.cardC)
      for t in 1:(prob.cardT)
        if ( sol.solX[ i,k,t ] == 1 )
          trspCost += prob.DD[ i, k ]
        end
      end
    end
  end
  for j in 1:(prob.cardP)
    for k in 1:(prob.cardC)
      for t in 1:(prob.cardT)
        if ( sol.solY[ j,k,t ] == 1 )
          trspCost += prob.PD[ j, k ]
        end
      end
    end
  end
  if ( trspCost != sol.trspCost )
    println( "trspCost is not accurate." )
    return false
  end
  
  #inventory cost
  for k in 1:(prob.cardC)
    for t in 1:prob.cardT
      invCost += prob.CCost[k] * sol.solZ[ k, t ]
    end
  end
  if ( invCost != sol.invCost )
    println( "invCost is not accurate." )
    return false
  end

  #penalty cost
  auxBin = 0
  for j in 1:(prob.cardP)
    auxBin = 0
    for k in 1:(prob.cardC)
      for t in 1:(prob.cardT)
        if ( sol.solY[ j,k,t ] == 1 )
          auxBin = 1
        end
      end
    end
    if ( auxBin == 0 )
      penCost += 1
    end
  end
  if ( penCost != sol.penCost )
    println( "penCost is not accurate." )
    return false
  end

  #if all costs are accurate
  return true
  
end