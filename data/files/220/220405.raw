#Library related to Generation of Initial Solution
#Copyright(c) 2015: Kally Chung

#01...orderD( cardD )
#02...findDemRec( offer, valPA, cardValP, currValP, optDem, diff, currInd, 
#                 valueBin )
#03...
#04...
#05...
#06...
#07...

include( "IO_MCITW-1P.jl" )
include( "verification.jl" )
include( "searching.jl" )

function swapPickups( prob, sol )

  aux1 = 0
  aux2 = 0
  
  solNew = copy(sol)
  
  #choosing a pair of deliveries
  indP = rand( 1:prob.cardP, 2 )
  while ( length(indP) != length( unique( indP ) ) ) 
    indP[2] = rand( 1:prob.cardP )
  end
  println("indP = $indP")
  
  #swaping the crossdocks and the times of indP, updating varZ
  aux1 = searchPickupSol( prob, solNew, indP[1] )
  aux2 = searchPickupSol( prob, solNew, indP[2] )
  
  while ( aux1[1] == aux2[1] )
    indP = rand( 1:prob.cardP, 2 )
    while ( length(indP) != length( unique( indP ) ) ) 
      indP[2] = rand( 1:prob.cardP )
    end
    
    aux1 = searchPickupSol( prob, solNew, indP[1] )
    aux2 = searchPickupSol( prob, solNew, indP[2] )
  end
  
  solNew.solY[ indP[1], aux1[1], aux1[2] ] = 0;
  solNew.solY[ indP[2], aux2[1], aux2[2] ] = 0;
  
  if ( ( aux1[1] != 0 ) && ( aux2[1] != 0 ) )
    if ( aux2[2] < PS[ indP[1] ] )
      aux2[2] = PS[ indP[1] ]
    elseif ( aux2[2] > PE[ indP[1] ] )
      aux2[2] = PE[ indP[1] ]
    end
    
    if ( aux1[2] < PS[ indP[2] ] )
      aux1[2] = PS[ indP[2] ]
    elseif ( aux1[2] > PE[ indP[2] ] )
      aux1[2] = PE[ indP[2] ]
    end
    
    solNew.solY[ indP[1], aux2[1], aux2[2] ] = 1;
    solNew.solY[ indP[2], aux1[1], aux1[2] ] = 1;
  
  elseif ( ( aux1[1] == 0 ) && ( aux2[1] != 0 ) )
    if ( aux2[2] < PS[ indP[1] ] )
      aux2[2] = PS[ indP[1] ]
    elseif ( aux2[2] > PE[ indP[1] ] )
      aux2[2] = PE[ indP[1] ]
    end
    
    solNew.solY[ indP[1], aux2[1], aux2[2] ] = 1;
  
  elseif ( ( aux1[1] != 0 ) && ( aux2[1] == 0 ) )
    if ( aux1[2] < PS[ indP[2] ] )
      aux1[2] = PS[ indP[2] ]
    elseif ( aux1[2] > PE[ indP[2] ] )
      aux1[2] = PE[ indP[2] ]
    end
    
    solNew.solY[ indP[2], aux1[1], aux1[2] ] = 1;
    
  end

  computeCosts!( prob, solNew )
  solNew.feas = checkFeas( prob, solNew )
  
  return solNew
  #if necessary, repairing sol
  
  #checking sol factibility
  
end

function swapDelivs( prob, sol )

  aux1 = 0
  aux2 = 0
  
  solNew = copy(sol)
  
  #choosing a pair of pickups
  indD = rand( 1:prob.cardD, 2 )
  while ( length(indD) != length( unique( indD ) ) ) 
    indD[2] = rand( 1:prob.cardD )
  end
  println("indD = $indD")
  
  #swaping the crossdocks and the times of indD, updating sol
  aux1 = searchDelivSol( prob, solNew, indD[1] )
  aux2 = searchDelivSol( prob, solNew, indD[2] )
  
  while ( aux1[1] == aux2[1] )
    indD = rand( 1:prob.cardD, 2 )
    while ( length(indD) != length( unique( indD ) ) ) 
      indD[2] = rand( 1:prob.cardD )
    end
    
    aux1 = searchDelivSol( prob, solNew, indD[1] )
    aux2 = searchDelivSol( prob, solNew, indD[2] )
  end
  
  
  
  solNew.solX[ indD[1], aux1[1], aux1[2] ] = 0;
  solNew.solX[ indD[2], aux2[1], aux2[2] ] = 0;
  
  if ( ( aux1[1] != 0 ) && ( aux2[1] != 0 ) )
    if ( aux2[2] < DS[ indD[1] ] )
      aux2[2] = DS[ indD[1] ]
    elseif ( aux2[2] > DE[ indD[1] ] )
      aux2[2] = DE[ indD[1] ]
    end
    
    if ( aux1[2] < DS[ indD[2] ] )
      aux1[2] = DS[ indD[2] ]
    elseif ( aux1[2] > DE[ indD[2] ] )
      aux1[2] = DE[ indD[2] ]
    end
    
    solNew.solX[ indD[1], aux2[1], aux2[2] ] = 1;
    solNew.solX[ indD[2], aux1[1], aux1[2] ] = 1;
  
  elseif ( ( aux1[1] == 0 ) && ( aux2[1] != 0 ) )
    if ( aux2[2] < DS[ indD[1] ] )
      aux2[2] = DS[ indD[1] ]
    elseif ( aux2[2] > DE[ indD[1] ] )
      aux2[2] = DE[ indD[1] ]
    end
    
    solNew.solX[ indD[1], aux2[1], aux2[2] ] = 1;
  
  elseif ( ( aux1[1] != 0 ) && ( aux2[1] == 0 ) )
    if ( aux1[2] < DS[ indD[2] ] )
      aux1[2] = DS[ indD[2] ]
    elseif ( aux1[2] > DE[ indD[2] ] )
      aux1[2] = DE[ indD[2] ]
    end
    
    solNew.solX[ indD[2], aux1[1], aux1[2] ] = 1;
    
  end

  computeCosts!( prob, solNew )
  
  solNew.feas = checkFeas( prob, solNew )
  
  return solNew
  #if necessary, repairing sol
  
  #checking sol factibility
  
end