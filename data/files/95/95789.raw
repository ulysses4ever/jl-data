import GLPK


# From https://github.com/mlubin/jlSimplex
function LPDataFromMPS(mpsfile::String) 

    lp = GLPK.Prob()
    ret = GLPK.read_mps(lp,GLPK.MPS_FILE,C_NULL,mpsfile)
    @assert ret == 0
    nrow::Int = GLPK.get_num_rows(lp)
    nrow = nrow - 1 # glpk puts the objective row in the constraint matrix, dunno why... 
    ncol::Int = GLPK.get_num_cols(lp)
    
    index1 = Array(Int32,nrow)
    coef1 = Array(Float64,nrow)
    
    
    starts = Array(Int64,ncol+1)
    idx = Array(Int64,0)
    elt = Array(Float64,0)
    nnz = 0

    c = Array(Float64,ncol)
    xlb = Array(Float64,ncol)
    xub = Array(Float64,ncol)
    l = Array(Float64,nrow)  
    u = Array(Float64,nrow)
    for i in 1:ncol
        c[i] = GLPK.get_obj_coef(lp,i)
        t = GLPK.get_col_type(lp,i)
        if t == GLPK.FR
            xlb[i] = typemin(Float64)
            xub[i] = typemax(Float64)
        elseif t == GLPK.UP
            xlb[i] = typemin(Float64)
            xub[i] = GLPK.get_col_ub(lp,i)
        elseif t == GLPK.LO
            xlb[i] = GLPK.get_col_lb(lp,i)
            xub[i] = typemax(Float64)
        elseif t == GLPK.DB || t == GLPK.FX
            xlb[i] = GLPK.get_col_lb(lp,i)
            xub[i] = GLPK.get_col_ub(lp,i)
        end
    end

    objname = GLPK.get_obj_name(lp)
    GLPK.create_index(lp)
    objrow = GLPK.find_row(lp,objname)

    for i in 1:nrow
        reali = i
        if (i >= objrow)
            reali += 1
        end
        t = GLPK.get_row_type(lp,reali)
        if t == GLPK.UP
            l[i] = typemin(Float64)
            u[i] = GLPK.get_row_ub(lp,reali)
        elseif t == GLPK.LO
            l[i] = GLPK.get_row_lb(lp,reali)
            u[i] = typemax(Float64)
        elseif t == GLPK.DB || t == GLPK.FX
            l[i] = GLPK.get_row_lb(lp,reali)
            u[i] = GLPK.get_row_ub(lp,reali)
        end
    end

    
    sel = Array(Bool,nrow)
    for i in 1:ncol
        starts[i] = nnz+1
        nnz1 = GLPK.get_mat_col(lp,i,index1,coef1)
        sel[:] = false
        for k in 1:nnz1
            if (index1[k] != objrow)
                sel[k] = true
            end
            if (index1[k] > objrow)
                index1[k] -= 1
            end
        end
        nnz1 = sum(sel)
        idx = [idx,index1[sel]]
        elt = [elt,coef1[sel]]
        nnz += nnz1
    end
    starts[ncol+1] = nnz+1

    A = SparseMatrixCSC(nrow,ncol,starts,idx,elt)

    return c,xlb,xub,l,u,A

end

@assert length(ARGS) == 1
c,xlb,xub,l,u,A = LPDataFromMPS(ARGS[1])

using InteriorPoint
using MathProgBase

m = MathProgBase.model(InteriorPointSolver())
MathProgBase.loadproblem!(m, A, xlb, xub, c, l, u, :Min)
MathProgBase.optimize!(m)
println(MathProgBase.getobjval(m))