#############################################################################
# InteriorPoint.jl
# Pure-Julia interior point solver for linear programs
# By Iain Dunning
# http://github.com/IainNZ/InteriorPoint.jl
#############################################################################

function solveIP(data::InteriorPointModel)
    # This implementation is based on the description in 
    # "Numerical Optimization" by Nocedal and Wright
    
    # Convert data to standard form
    # TODO: For now just assume Ax=b,x>=0
    A = copy(data.A)
    m, n = size(A)
    b = copy(data.rowlb)
    c = copy(data.obj)

    # Determine an initial solution
    x, λ, s = find_initial_solution(A,b,c)
    dump(x)
    dump(λ)
    dump(s)
    dump(dot(x,c))

    for iteration = 1:10
        println("Iteratoin $iteration")

        # Form left-hand-side
        # TODO: Don't form this left-hand-side :)
        lhs = [zeros(n,n)          A'    eye(n,n);
                        A  zeros(m,m)  zeros(m,n);
                 diagm(s)  zeros(n,m)    diagm(x)]

        # Factor left-hand-side
        # TODO: Write my own Cholesky code?? D:
        lhs_fact = lufact!(lhs)

        # Solve for affine-scaling directions
        r_b = A*x - b
        r_c = A'*λ + s - c
        ans = lhs_fact \ vcat(-r_c, -r_b, -x.*s)
        Δ_x_aff = ans[1:n]
        Δ_λ_aff = ans[n+1:n+m]
        Δ_s_aff = ans[n+m+1:n+m+n]

        # Calculate affine-scaling step length
        α_pri_aff = 1.0
        for i = 1:n
            if Δ_x_aff[i] < 0.0
                α_pri_aff  = min(α_pri_aff,  -x[i] / Δ_x_aff[i])
            end
        end
        α_dual_aff = 1.0
        for i = 1:m
            if Δ_s_aff[i] < 0.0
                α_dual_aff = min(α_dual_aff, -s[i] / Δ_s_aff[i])
            end
        end
        μ = 1/n * dot(x, s)
        μ_aff = 1/n * dot(x .+ α_pri_aff * Δ_x_aff, s .+ α_dual_aff * Δ_s_aff)

        # Calculate centering parameter
        σ = (μ_aff / μ) ^ 3

        # Re-solve for actual directions
        ans = lhs_fact \ vcat(-r_c, -r_b, -x.*s .- Δ_x_aff.*Δ_s_aff .+ σ*μ)
        Δ_x = ans[1:n]
        Δ_λ = ans[n+1:n+m]
        Δ_s = ans[n+m+1:n+m+n]

        # Calculate step lengths
        eta = 0.9
        α_pri_max = Inf
        for i = 1:n
            if Δ_x[i] < 0.0
                α_pri_max  = min(α_pri_max,  -x[i] / Δ_x[i])
            end
        end
        α_dual_max = Inf
        for i = 1:m
            if Δ_s[i] < 0.0
                α_dual_max  = min(α_dual_max,  -s[i] / Δ_s[i])
            end
        end
        α_pri  = min(1.0, α_pri_max)
        α_dual = min(1.0, α_dual_max)

        # Update current solution
        x .+= α_pri  * Δ_x
        λ .+= α_dual * Δ_λ
        s .+= α_dual * Δ_s
        dump(x)
        dump(λ)
        dump(s)
        dump(dot(x,c))

        if abs(dot(c,x) - dot(b,λ)) < 1e-4
            println("UNDER TOL, YAY")
            break
        end
    end
end


# find_initial_solution
# Finds a "good" starting point that approximately satisfies the primal and
# dual constraints, has positive x and s, and doesn't have components that
# are "too large".
# TODO: Reorganize so not using inverse
function find_initial_solution(A,b,c)
    # Solve min dot(x,x) s.t. A x = b
    x_tilde = A' * inv( A * A' ) * b
    # Solve min dot(s,s) s.t. A'λ + s = c
    λ_tilde = inv( A * A' ) * A * c
    s_tilde = c - A' * λ_tilde

    # Some components of x,s maybe be negative. Add constant offset to all
    # elements to ensure non-negativity
    δ_x = max(-3/2 * minimum(x_tilde), 0)
    δ_s = max(-3/2 * minimum(s_tilde), 0)
    x_hat = x_tilde .+ δ_x
    s_hat = s_tilde .+ δ_s

    # Now ensure that the components are not too close to zero and not too
    # dissimilar, add two more scalars and return our starting point
    δ_hat_x = 1/2 * dot(x_hat, s_hat) / sum(s_hat)
    δ_hat_s = 1/2 * dot(x_hat, s_hat) / sum(x_hat)
    return x_hat .+ δ_hat_x,  λ_tilde,  s_hat .+ δ_hat_s
end
