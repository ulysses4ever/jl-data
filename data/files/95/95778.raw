const PRE_EQ_TOL     = 1e-10
const PRE_REL_EQ_TOL = 1e-6

function presolve(data_in::InteriorPointModel)
    
    data = InteriorPointModel(  copy(data_in.A),
                                copy(data_in.collb), copy(data_in.colub),
                                copy(data_in.obj),
                                copy(data_in.rowlb), copy(data_in.rowub),
                                data_in.sense, data_in.objval,
                                copy(data_in.x), copy(data_in.dual))
    m, n = size(data.A)

    var_removed = zeros(Bool, n)
    var_changed =  ones(Bool, n)

    con_removed = zeros(Bool, m)
    con_changed =  ones(Bool, m)

    any_change  = true
    iterations  = 0
    while any_change
        any_change = false
        iterations += 1

        # PASS 1
        # Check if variable bounds are at equality - if so, eliminate
        # them from the constraints
        any_change |= presolve_eliminate_variables(data, 
                        var_changed, var_removed,
                        con_changed, con_removed)
        #var_changed = zeros(Bool, m.numCols)
        break

        # PASS 2
        # Turn singleton constraints into variable bounds
        #any_change |= presolve_singleton_cons(m, 
        #                var_changed, var_removed,
        #                con_changed, con_removed)

        # PASS 3
        # Infer upper bounds on variables from constraint RHS
        #any_change |= presolve_rhs_tighten(m, 
        #                var_changed, var_removed,
        #                con_changed, con_removed)
        #con_changed = zeros(Bool, length(m.linconstr))
        
    end

    num_removed = 0
    for j = 1:n
        var_removed[j] && (num_removed += 1)
    end
    println(n)
    println(num_removed)

    num_con_removed = 0
    for i = 1:m
        con_removed[i] && (num_con_removed += 1)
    end
    println(m)
    println(num_con_removed)

    readline()

    #presolve_finish(m, con_removed, var_removed)

    return data
end

#############################################################################
# PASS 1
# Check if bounds are at equality - if so, eliminate them
# from the constraints
function presolve_eliminate_variables(data::InteriorPointModel,
                                        var_changed, var_removed,
                                        con_changed, con_removed)
    m, n = size(data.A)
    any_change = false
    
    for j = 1:n
        (!var_changed[j] || var_removed[j]) && continue
       
        # Check equality of bounds
        if abs(data.colub[j] - data.collb[j]) < PRE_EQ_TOL
            # Bounds are equal - remove this variable
            var_removed[j] = true
            updates = presolve_remove_col(data, j, data.collb[j], con_removed)
            for i in updates
                con_changed[i] = true
                any_change = true
            end
        end
    end

    return any_change
end

#############################################################################

function presolve_remove_col(data::InteriorPointModel,
                             j::Int, new_value::Float64,
                             con_removed::Vector{Bool})
    m, n = size(data.A)
    con_changed = Int[]

    for i = 1:m
        # Don't consider this constraint at all if its already dead
        con_removed[i] && continue
        coeff = data.A[i,j]
        # If nonzero, we need to do something too
        coeff == 0.0 && continue
        # Remove it from the constraints and update the bounds
        data.rowlb[i] -= coeff * new_value
        data.rowub[i] -= coeff * new_value
        data.A[i,j] = 0.0
        push!(con_changed, i)
        # Check if this constraint is dead
        any_nonzero = false
        for k = 1:n
            if data.A[i,k] != 0.0
                any_nonzero = true
                break
            end
        end
        # If it is all zeros, remove it
        con_removed[i] = !any_nonzero
    end
    # Finally check objective
    data.obj_constant += data.obj[j] * new_value
    data.obj[j] = 0.0

    return con_changed
end
