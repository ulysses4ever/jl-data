var functor = require("./functor");
var trig = require("./trig");
var point = require("./point");


pointX(d,i) = d[1];

pointY(d,i) = d[2];

#=
 * Computes the 2D convex hull of a set of points using the monotone chain
 * algorithm:
 * http:#en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain)
 *
 * The runtime of this algorithm is O(n log n), where n is the number of input
 * points. However in practice it outperforms other O(n log n) hulls.
 *
 * @param data [[x1, y1], [x2, y2], ...]
 * @returns polygon [[x1, y1], [x2, y2], ...]
 =#
function convexhull(data::Array, fx::Function=pointX, fy::Function=pointY) {
    T = typeof(data).parameters[1]
    # Hull of < 3 points is not well-defined
    (length(data) < 3) &&  return T[]

      n             = length(data)
      points        = [] # of the form [[x0, y0, 0], ..., [xn, yn, n]]
      flippedPoints = []

    for i = 1 : n
      push!(points,[fx(data[i], i), fy(data[i], i), i]);
    end

    # sort ascending by x-coord first, y-coord second
    sort!(points, hullOrder)

    # we flip bottommost points across y axis so we can use the upper hull routine on both
    for (i = 0; i < n; i++)
      flippedPoints.push([points[i][1], -points[i][2]]);
    end

    upper = hullUpper(points),
    lower = hullUpper(flippedPoints);

    # construct the polygon, removing possible duplicate endpoints
    skipLeft  = is(lower[0], upper[0])
    skipRight = is(lower[length(lower) - 1], upper[length(upper) - 1])
    polygon   = []

    # add upper hull in r->l order
    # then add lower hull in l->r order
    for i = length(upper):-1:1
      push(polygon, data[points[upper[i]][3]]);
    end

    for i = skipLeft : length(lower) - skipRight
      push!(polygon, data[points[lower[i]][3]])
    end

    if (polygon) { polygon.push(polygon[0]); }
    return polygon;
  }

  hull.x = function (v) {
    return arguments.length ? (x = v, hull) : x;
  };

  hull.y = function (v) {
    return arguments.length ? (y = v, hull) : y;
  };

  return hull;
}

# finds the 'upper convex hull' (see wiki link above)
# assumes points arg has >=3 elements, is sorted by x, unique in y
# returns array of indices into points in left to right order
function hullUpper(points) {
  var n = points.length,
      hull = [0, 1],
      hs = 2; # hull size

  for (var i = 2; i < n; i++) {
    while (hs > 1 &&
           trig.cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0) {
      --hs;
    }
    hull[hs++] = i;
  }

  # we slice to make sure that the points we 'popped' from hull don't stay behind
  return hull.slice(0, hs);
}

# comparator for ascending sort by x-coord first, y-coord second
function hullOrder(a, b) {
  return a[0] - b[0] || a[1] - b[1];
}
