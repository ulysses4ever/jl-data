#!/usr/bin/env julia
###############################################################################
# @file assembler.jl
# @date Oct 18, 2014
#
# @author Milos Subotic <milos.subotic.sm@gmail.com>
# @license MIT
#
# @brief Assembler.
#
# @version: 1.0
# Changelog:
# 1.0 - Initial version.
#
###############################################################################

tic()

###############################################################################

const program_name = "assembler.jl"

const predicate_table = (Char => String)[
	'e' => "P_EQUAL",
	'd' => "P_DIFFERENT",
	'b' => "P_BELOW",
	'a' => "P_ABOVE",
	'z' => "P_ZERO",
	'c' => "P_CARRY"
]

args_types = String[
	"none",
	"instr_addr",
	"reg_and_const",
	"two_regs",
	"three_regs"
]

const opcodes_and_args_types = (String => String)[
	"nop" => "none",
	"jmp" => "instr_addr",
	"ld_const" => "reg_and_const",
	"mov" => "two_regs",
	"add" => "three_regs",
	"sub" => "three_regs"
]

const registers_number = 16
const max_const = 255

template = "
-------------------------------------------------------------------------------
-- This file is generated by $program_name
-- Command line arguments were: {ARGS}
-------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

use work.instruction_set.all;

entity instruction_rom is
	port (
		i_addr        : in  t_instr_addr;
		o_instruction : out t_instruction
	);
end entity instruction_rom;

architecture instruction_rom_arch of instruction_rom is

	type t_instructions is array (0 to instructions_number-1) of t_instruction;
	
	constant rom : t_instructions := (
{instructions}
		others => nop
	);
	
begin

	o_instruction <= rom(to_integer(i_addr));

end architecture instruction_rom_arch;

"

###############################################################################

function print_and_exit(args...)
	println(args...)
	exit(1)
end

usage = "Usage:
	$program_name INPUT_FILE.asm OUTPUT_FILE.vhd
"

if length(ARGS) < 2
	print_and_exit(usage)
end

input_file_name = ARGS[1]
output_file_name = ARGS[2]

input_file = try
	open(input_file_name)
catch e
	if e.errnum == 2
		print_and_exit("$program_name: error: $input_file_name: No such file or directory")
	elseif e.errnum == 13
		print_and_exit("$program_name: error: $input_file_name: Permission denied")
	end
end

label_to_addr = (String => Int)[]
args_parsers_table = (String => Function)[]

function check_register(line_num, s)
	if int(s) >= registers_number
		print_and_exit("$input_file_name:$line_num: error: non-existing register %$s")
	end
end

function check_const(line_num, s)
	if int(s) > max_const
		print_and_exit("$input_file_name:$line_num: error: constant %$s is too big")
	end
end

args_parsers_table["none"] = function(line_num, opcode, args)
	if args ≠ nothing
		print_and_exit("$input_file_name:$line_num: error: instruction \"$opcode\" does not have arguments")
	end
end

args_parsers_table["instr_addr"] = function(line_num, opcode, args)
	m = match(r"^(\w+)$", args)
	if m == nothing
		print_and_exit("$input_file_name:$line_num: error: wrong arguments \"$args\" for instruction \"$opcode\"")
	else
		label = m.captures[1]
		return function()
			if !haskey(label_to_addr, label)
				print_and_exit("$input_file_name:$line_num: error: label \"$label\" not defined")
			else
				return string(label_to_addr[label])
			end
		end
	end
end

args_parsers_table["reg_and_const"] = function(line_num, opcode, args)
	# TODO Hex numbers also.
	m = match(r"^%(\d+)=(\d+)$", args)
	if m == nothing
		print_and_exit("$input_file_name:$line_num: error: wrong arguments \"$args\" for instruction \"$opcode\"")
	else
		dest = m.captures[1]
		constant = m.captures[2]
		check_register(line_num, dest)
		check_const(line_num, constant)
		return function()
			return "$dest, $constant"
		end
	end
end

args_parsers_table["two_regs"] = function(line_num, opcode, args)
	m = match(r"^%(\d+)=%(\d+)$", args)
	if m == nothing
		print_and_exit("$input_file_name:$line_num: error: wrong arguments \"$args\" for instruction \"$opcode\"")
	else
		dest = m.captures[1]
		src1 = m.captures[2]
		check_register(line_num, dest)
		check_register(line_num, src1)
		return function()
			return "$dest, $src1"
		end
	end
end

args_parsers_table["three_regs"] = function(line_num, opcode, args)
	m = match(r"^%(\d+)=%(\d+),%(\d+)$", args)
	if m == nothing
		print_and_exit("$input_file_name:$line_num: error: wrong arguments \"$args\" for instruction \"$opcode\"")
	else
		dest = m.captures[1]
		src1 = m.captures[2]
		src2 = m.captures[3]
		check_register(line_num, dest)
		check_register(line_num, src1)
		check_register(line_num, src2)
		return function()
			return "$dest, $src1, $src2"
		end
	end
end

if sort(args_types) ≠ sort(collect(keys(args_parsers_table)))
	print_and_exit("$program_name: internal error: args_types and args_parsers_table are not sync")
end

const opcodes_and_args_parsers = (String => Function)[]

for (opcode, args_type) in opcodes_and_args_types
	if ! haskey(args_parsers_table, args_type)
		print_and_exit("$program_name: internal error: args type \"$args_type\" parser not implemented")
	end
	opcodes_and_args_parsers[opcode] = args_parsers_table[args_type]
end

addr = 0
unfinished_output_lines = Function[]

for (line_num, line) in enumerate(readlines(input_file))

	m = match(r"^((\w+):)?(\s*(\((\w+)\)\s+)?(\w+)(\s+([=,%\w]+))?)?\s*(//\s*(.*)\s*)?$", line)
	if m ≠ nothing
		label = m.captures[2]
		predicate = m.captures[5]
		opcode = m.captures[6]
		args = m.captures[8]
		comment = m.captures[10]
		if comment == nothing
			comment = ""
		else
			comment = "// " * comment
		end

		if label ≠ nothing
			if haskey(label_to_addr, label)
				print_and_exit("$input_file_name:$line_num: error: duplicated label \"$label\" 
$input_file_name:$line_num: note: already exists on line ", label_to_addr[label])
			else
				label_to_addr[label] = addr
			end

			o = "-- $label:"
			if opcode ≠ nothing
				o *= " @line $line_num @addr $a $comment"
			end
			o *= "\n"
			append!(unfinished_output_lines, Function[()-> o])	
			
		end

		if opcode ≠ nothing

			out_predicate = ""
			if predicate ≠ nothing
				for c in predicate
					if !(c in keys(predicate_table))
						print_and_exit("$input_file_name:$line_num: error: non-existing predicate flag \"$c\"")
					else
						if out_predicate == ""
							out_predicate *= ", "
						else
							out_predicate *= " or "
						end
						out_predicate *= predicate_table[c]
					end
				end
			end

			if !haskey(opcodes_and_args_parsers, opcode)
				print_and_exit("$input_file_name:$line_num: error: non-existing opcode \"$opcode\"")
			end
		
			parser = opcodes_and_args_parsers[opcode]
			finish_args = parser(line_num, opcode, args)
			a = addr
			finish_instruction = function()
				return "\t\t$opcode(" * finish_args() * out_predicate * 
					"), -- @line $line_num @addr $a $comment\n"
			end
			append!(unfinished_output_lines, Function[finish_instruction])

			addr += 1
		end

	end
end

close(input_file)

output_lines = map((f) -> f(), unfinished_output_lines)

output_file = try
	open(output_file_name, "w")
catch e
	if e.errnum == 2
		print_and_exit("$program_name: error: $input_file_name: No such file or directory")
	elseif e.errnum == 13
		print_and_exit("$program_name: error: $input_file_name: Permission denied")
	end
end

# TODO Python's format
s = replace(template, "{ARGS}", join(ARGS, " "))
s = replace(s, "{instructions}", join(output_lines, ""))

write(output_file, s)

close(output_file)

###############################################################################

toc()

###############################################################################

