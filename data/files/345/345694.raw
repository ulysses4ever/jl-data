module SortedVectors

#To test

#-----------------------------------------------------------
#PURPOSE
#	Colin T. Bowers module for the SortedVector and SortedUniqueVector type
#NOTES
#	Module currently assumes vectors are sorted on "isless". Could potentially extend entire module to general orderings (see type Ordering)
#	intersect on two sorted vectors returns all elements common from BOTH vectors. Note that intersect on two regular vectors only returns common elements from the first vector. In this module, intersect and union are both symmetric functions (unlike Base version)
#	Indexing into a SortedVectorType does not create a new SortedVectorType but rather just results in a regular vector. This is deliberate as it means we don't need to check for monotinicity when indexing with any arbitrary vector of integers.
#	If you have a SortedVector{Int} or SortedUniqueVector{Int} then you can only deleteat! on index, NOT on element-value. For all other types, you can deleteat! on element value as well as index.
#LICENSE
#	MIT License (see github repository for more detail: https://github.com/colintbowers/SortedVectors.jl.git)
#-----------------------------------------------------------

#Load any entire modules that are needed (use using ModuleName1, ModuleName2, etc)
#(none currently needed)

#Load any specific functions that are needed (use import ModuleName1.FunctionName1, ModuleName2.FunctionName2, etc)
import 	Base.string,
		Base.show,
		Base.getindex,
		Base.length,
		Base.size,
		Base.sizeof,
		Base.eltype,
		Base.first,
		Base.last,
		Base.endof,
		Base.copy,
		Base.deepcopy,
		Base.issorted,
		Base.search,
		Base.searchsorted,
		Base.searchsortedfirst,
		Base.searchsortedlast,
		Base.searchindex,
		Base.in,
		Base.==,
		Base.!=,
		Base.pop!,
		Base.shift!,
		Base.push!,
		Base.unshift!,
		Base.deleteat!,
		Base.empty!,
		Base.insert!,
		Base.intersect,
		Base.union,
		Base.setdiff,
		Base.setdiff!,
		Base.unique


#Specify the variables/functions to export (use export FunctionName1, FunctionName2, etc)
export  SortedVectorType,
		SortedVector,
		SortedUniqueVector,
		searchfirst,
		searchlast,
		deletenotat!,
		insertIndex,
		intersectIndex,
		unionIndex,
		isunique,
		isuniquesort,
		uniquesort!,
		unique!,
		trimRange,
		trim,
		trim!,
		constructMesh,
		meshIndex,
		mesh





#----------------------------------------------------------
#TYPE
#	SortedVector
#	SortedUniqueVector
#FIELDS
#	x::Vector{T}: This field contains the sorted vector (and unique in case of SortedUniqueVector) of element type T<:Any
#PURPOSE
#	This type implements a vector whose elements are guaranteed to be sorted, and a vector whose elements are guaranteed to be sorted and unique. Methods defined on this type exploit this feature for performance gains.
#INNER CONSTRUCTOR
#	(x::Vector{T}; alreadySorted::Bool=false): Inner constructor checks whether the input vector is sorted, and sorts it if it is not. This check can be skipped via a keyword argument.
#	(x::Vector{T}; alreadySorted::Bool=false, alreadyUnique::Bool=false): Inner constructor checks whether the input vector is sorted and unique, and sorts it if it is not, and then forces uniqueness if not. These checks can be skipped via keyword arguments.
#OUTER CONSTRUCTOR
#	There are two outer constructors that match the inner constructors that allow the user to skip specifying the type explicitly (instead it is inferred from eltype of the input vector)
#	(T::DataType): Initiates an empty SortedVector or SortedUniqueVector of type T
#METHODS
#	There are many
#NOTES
#----------------------------------------------------------
#-------- TYPE DEFINITION -----------
#Abstract super-type
abstract SortedVectorType{T}
#SortedVector
immutable SortedVector{T} <: SortedVectorType{T}
	x::Vector{T}
	function SortedVector{T}(x::Vector{T}; alreadySorted::Bool=false)
		!(method_exists(isless, (T, T))) && error("isless is not defined for Type " * string(T) * ", so SortedVector is not feasible.")
		if alreadySorted == false
			if issorted(x) == false
				sort!(x)
			end
		end
		new(x)
	end
end
#SortedUniqueVector
immutable SortedUniqueVector{T} <: SortedVectorType{T}
	x::Vector{T}
	function SortedUniqueVector{T}(x::Vector{T}; alreadySorted::Bool=false, alreadyUnique::Bool=false)
		!(method_exists(isless, (T, T))) && error("isless is not defined for Type " * string(T) * ", so SortedUniqueVector is not feasible.")
		if alreadySorted == false
			if issorted(x) == false
				sort!(x)
			end
		end
		if alreadyUnique == false
			if isuniquesort(x) == false
				uniquesort!(x)
			end
		end
		new(x)
	end
end
#SortedVector constructors
SortedVector{T}(x::Vector{T}; alreadySorted::Bool=false) = SortedVector{eltype(x)}(x, alreadySorted=alreadySorted)
SortedVector(T::DataType) = SortedVector(Array(T, 0), alreadySorted=true)
SortedVector(s::SortedVector) = s
SortedVector(s::SortedUniqueVector) = SortedVector(s, alreadySorted=true)
#SortedUniqueVector constructors
SortedUniqueVector{T}(x::Vector{T}; alreadySorted::Bool=false, alreadyUnique::Bool=false) = SortedUniqueVector{eltype(x)}(x, alreadySorted=alreadySorted, alreadyUnique=alreadyUnique)
SortedUniqueVector(T::DataType) = SortedUniqueVector(Array(T, 0), alreadySorted=true, alreadyUnique=true)
SortedUniqueVector(s::SortedUniqueVector) = s
SortedUniqueVector(s::SortedVector) = SortedUniqueVector(s, alreadySorted=true)
#-------------------------------------
#-------- ONE-LINE METHODS ----
Base.string(s::SortedVectorType) = string(s.x)
Base.show(s::SortedVectorType) = show(s.x)
Base.getindex(s::SortedVectorType, i::Int) = s.x[i]
Base.getindex(s::SortedVectorType, r::UnitRange) = s.x[r]
Base.getindex(s::SortedVectorType, iVec::Vector{Int}) = s.x[iVec]
Base.getindex(s::SortedVectorType, inds::IntSet) = s.x[collect(inds)]
#Base.getindex(s::SortedVectorType, iAny) = s.x[iAny] #Duck-typing for other cases
Base.length(s::SortedVectorType) = length(s.x)
Base.size(s::SortedVectorType) = length(s)
Base.size(s::SortedVectorType, i::Int) = (i != 1) ? error("SortedVector is a vector") : length(s)
Base.sizeof(s::SortedVectorType) = sum([ sizeof(s.x[n]) for n = 1:length(s.x) ])
Base.eltype(s::SortedVectorType) = eltype(s.x)
Base.first(s::SortedVectorType) = first(s.x)
Base.last(s::SortedVectorType) = last(s.x)
Base.endof(s::SortedVectorType) = endof(s.x)
Base.copy(s::SortedVector) = SortedVector(copy(s.x), alreadySorted=true)
Base.copy(s::SortedUniqueVector) = SortedUniqueVector(copy(s.x), alreadySorted=true, alreadyUnique=true)
Base.deepcopy(s::SortedVector) = SortedVector(deepcopy(s.x), alreadySorted=true)
Base.deepcopy(s::SortedUniqueVector) = SortedUniqueVector(deepcopy(s.x), alreadySorted=true, alreadyUnique=true)
Base.issorted(s::SortedVectorType) = issorted(s.x) #Useful in case there is potential for someone to have messed with the internals
#searchsorted is multi-line as it incorporates an error trap for SortedUniqueVector type
Base.searchsortedfirst{T}(s::SortedVectorType{T}, a::T) = searchsortedfirst(s.x, a)
Base.searchsortedlast{T}(s::SortedVectorType{T}, a::T) = searchsortedlast(s.x, a)
Base.search{T}(s::SortedVectorType{T}, a::T) = searchsorted(s, a)
searchfirst{T}(s::SortedVectorType{T}, a::T) = searchsortedfirst(s, a)
searchlast{T}(s::SortedVectorType{T}, a::T) = searchsortedlast(s, a)
#Base.in{T<:OrderedSet}(s::SortedVectorType{T}, a::T) = error("To avoid method ambiguities the in function can not be called on SortedVector types containing OrderedSet types")
Base.in{T}(a::T, s::SortedVectorType{T}) = !(isempty(search(s, a)))
Base.pop!(s::SortedVectorType) = pop!(s.x)
Base.shift!(s::SortedVectorType) = shift!(s.x)
Base.deleteat!(s::SortedVectorType, i::Int) = deleteat!(s.x, i)
Base.deleteat!(s::SortedVectorType, r::UnitRange) = deleteat!(s.x, r)
Base.deleteat!(s::SortedVectorType, iVec::Vector{Int}) = deleteat!(s.x, iVec)
Base.deleteat!(s::SortedVectorType, inds::IntSet) = deleteat!(s.x, collect(inds))
Base.deleteat!{T}(s::SortedVectorType{T}, a::T) = deleteat!(s, search(s, a))
Base.deleteat!{T}(s::SortedVectorType{T}, a::Vector{T}) = [ deleteat!(s, a[n]) for n = 1:length(a) ]
Base.empty!(s::SortedVectorType) = deleteat!(s, UnitRange(1, length(s)))
==(s1::SortedVectorType, s2::SortedVectorType) = (s1.x == s2.x)
!=(s1::SortedVectorType, s2::SortedVectorType) = (s1.x != s2.x)
#-------------------------------------
#-------- MULTI-LINE METHODS -----------
#searchsorted
Base.searchsorted{T}(s::SortedVector{T}, a::T) = searchsorted(s.x, a)
function Base.searchsorted{T}(s::SortedUniqueVector{T}, a::T)
	r = searchsorted(s.x, a)
	(r.start < r.stop) ? error("SortedUniqueVector is not unique") : return(r)
end
#searchindex
function Base.searchindex{T}(s::SortedUniqueVector{T}, a::T)
	r = searchsorted(s, a) #includes check of r.start < r.stop
	r.start > r.stop && return(-1)
	return(r.start)
end
#push!
function push!{T}(s::SortedVector{T}, a::T)
	if s == 0
		push!(s.x, a)
	else
		a < s[end] && error("push! operation would violate sort order")
		push!(s.x, a)
	end
end
function push!{T}(s::SortedUniqueVector{T}, a::T)
	if s == 0
		push!(s.x, a)
	else
		a <= s[end] && error("push! operation would violate sort order")
		push!(s.x, a)
	end
end
#unshift!
function unshift!{T}(s::SortedVector{T}, a::T)
	if s == 0
		unshift!(s.x, a)
	else
		a > s[1] && error("unshift! operation would violate sort order")
		unshift!(s.x, a)
	end
end
function unshift!{T}(s::SortedUniqueVector{T}, a::T)
	if s == 0
		unshift!(s.x, a)
	else
		a >= s[1] && error("unshift! operation would violate sort order")
		unshift!(s.x, a)
	end
end
#insertIndex
function insertIndex{T}(s::SortedVector{T}, a::T)
	if length(s) == 0
		return(1)
	else
		if a < s.x[1]
			return(1)
		elseif a >= s.x[end]
			return(length(s)+1)
		else
			return(searchlast(s, a)+1) #In presence of duplicates, insert after the duplicates
		end
	end
end
function insertIndex{T}(s::SortedUniqueVector{T}, a::T)
	if length(s) == 0
		return(1)
	else
		if a < s.x[1]
			return(1)
		elseif a > s.x[end]
			return(length(s)+1)
		else
			r = search(s, a)
			!(isempty(r)) && error("Unable to insert into SortedUniqueVector as it would create duplicate")
			return(r.start)
		end
	end
end
#insert!
function Base.insert!{T}(s::SortedVectorType{T}, a::T)
	i = insertIndex(s, a)
	insert!(s.x, i, a)
	return(i)
end
Base.insert!{T}(s::SortedVectorType{T}, a::Vector{T}) = [ insert!(s, a[n]) for n = 1:length(a) ]
#intersectIndex, intersect
function intersectIndex{T}(x::SortedVector{T}, y::SortedVector{T})
	nx = 1
	ny = 1
	indsx = Array(Int, 0)
	indsy = Array(Int, 0)
	indsxRecover = Array(Int, 0)
	indsyRecover = Array(Int, 0)
	if length(x) == 0 || length(y) == 0
		return(indsx, indsy, indsxRecover, indsyRecover)
	end
	if x[end] < y[1] || y[end] < x[1]
		return(indsx, indsy, indsxRecover, indsyRecover)
	end
	c1 = 1
	while nx <= length(x) && ny <= length(y)
		if x[nx] < y[ny]
			nx += 1
		elseif x[nx] > y[ny]
			ny += 1
		else
			push!(indsx, nx)
			push!(indsxRecover, c1)
			c1 += 1
			nnx = nx + 1
			while nnx <= length(x) #This is needed in-case of duplicates
				if x[nnx] != y[ny]
					break
				else
					push!(indsx, nnx)
					push!(indsxRecover, c1)
					nnx += 1
					c1 += 1
				end
			end
			push!(indsy, ny)
			push!(indsyRecover, c1)
			c1 += 1
			nny = ny + 1
			while nny <= length(y) #This is needed in-case of duplicates
				if y[nny] != x[nx]
					break
				else
					push!(indsy, nny)
					push!(indsyRecover, c1)
					nny += 1
					c1 += 1
				end
			end
			nx = nnx
			ny = nny
		end
	end
	return(indsx, indsy, indsxRecover, indsyRecover)
end
function intersectIndex{T}(x::SortedUniqueVector{T}, y::SortedUniqueVector{T})
	nx = 1
	ny = 1
	indsx = Array(Int, 0)
	indsy = Array(Int, 0)
	if length(x) == 0 || length(y) == 0
		return(indsx, indsy)
	end
	if x[end] < y[1] || y[end] < x[1]
		return(indsx, indsy)
	end
	while nx <= length(x) && ny <= length(y)
		if x[nx] < y[ny]
			nx += 1
		elseif x[nx] > y[ny]
			ny += 1
		else
			push!(indsx, nx)
			nx += 1
			push!(indsy, ny)
			ny += 1
		end
	end
	return(indsx, indsy)
end
intersectIndex{T}(x::SortedVectorType{T}, y::SortedVectorType{T}) = intersectIndex(SortedVector(x, alreadySorted=true), SortedVector(y, alreadySorted=true))
function intersect{T}(x::SortedVector{T}, y::SortedVector{T})
	nx = 1
	ny = 1
	xy = SortedVector(T)
	if length(x) == 0 || length(y) == 0
		return(xy)
	end
	if x[end] < y[1] || y[end] < x[1]
		return(xy)
	end
	while nx <= length(x) && ny <= length(y)
		if x[nx] < y[ny]
			nx += 1
		elseif x[nx] > y[ny]
			ny += 1
		else
			push!(xy.x, x[nx])
			nnx = nx + 1
			while nnx <= length(x) #This is needed in-case of duplicates
				if x[nnx] != y[ny]
					break
				else
					push!(xy.x, x[nnx])
					nnx += 1
				end
			end
			push!(xy.x, y[ny])
			nny = ny + 1
			while nny <= length(y) #This is needed in-case of duplicates
				if y[nny] != x[nx]
					break
				else
					push!(xy.x, y[nny])
					nny += 1
				end
			end
			nx = nnx
			ny = nny
		end
	end
	return(xy)
end
function intersect{T}(x::SortedUniqueVector{T}, y::SortedUniqueVector{T})
	nx = 1
	ny = 1
	xy = SortedUniqueVector(T)
	if length(x) == 0 || length(y) == 0
		return(xy)
	end
	if x[end] < y[1] || y[end] < x[1]
		return(xy)
	end
	while nx <= length(x) && ny <= length(y)
		if x[nx] < y[ny]
			nx += 1
		elseif x[nx] > y[ny]
			ny += 1
		else
			push!(xy.x, x[nx])
			nx += 1
			ny += 1
		end
	end
	return(xy)
end
intersect{T}(x::SortedVectorType{T}, y::SortedVectorType{T}) = intersect(SortedVector(x, alreadySorted=true), SortedVector(y, alreadySorted=true))
#unionIndex, union
function unionIndex{T}(x::SortedVector{T}, y::SortedVector{T})
	nx = 1
	ny = 1
	indsxRecover = Array(Int, 0)
	indsyRecover = Array(Int, 0)
	if x[end] < y[1]
		return([1:length(x)], [length(x)+1:length(x)+length(y)])
	elseif y[end] < x[1]
		return([length(y)+1:length(y)+length(x)], [1:length(y)])
	end
	c1 = 1
	while nx <= length(x) && ny <= length(y)
		if x[nx] < y[ny]
			push!(indsxRecover, c1)
			nx += 1
			c1 += 1
		elseif x[nx] > y[ny]
			push!(indsyRecover, c1)
			ny += 1
			c1 += 1
		else
			push!(indsxRecover, c1)
			c1 += 1
			nnx = nx + 1
			while nnx <= length(x)
				if x[nnx] != y[ny]
					break
				else
					push!(indsxRecover, c1)
					nnx += 1
					c1 += 1
				end
			end
			push!(indsyRecover, c1)
			c1 += 1
			nny = ny + 1
			while nny <= length(y)
				if y[nny] != x[nx]
					break
				else
					push!(indsyRecover, c1)
					c1 += 1
					nny += 1
				end
			end
			nx = nnx
			ny = nny
		end
	end
	if nx <= length(x)
		for n = nx:length(x)
			push!(indsxRecover, c1)
			c1 += 1
		end
	elseif ny <= length(y)
		for n = ny:length(y)
			push!(indsyRecover, c1)
			c1 += 1
		end
	end
	return(indsxRecover, indsyRecover)
end
function unionIndex{T}(x::SortedUniqueVector{T}, y::SortedUniqueVector{T})
	nx = 1
	ny = 1
	indsxRecover = Array(Int, 0)
	indsyRecover = Array(Int, 0)
	if x[end] < y[1]
		return([1:length(x)], [length(x)+1:length(x)+length(y)])
	elseif y[end] < x[1]
		return([length(y)+1:length(y)+length(x)], [1:length(y)])
	end
	c1 = 1
	while nx <= length(x) && ny <= length(y)
		if x[nx] < y[ny]
			push!(indsxRecover, c1)
			nx += 1
			c1 += 1
		elseif x[nx] > y[ny]
			push!(indsyRecover, c1)
			ny += 1
			c1 += 1
		else
			push!(indsxRecover, c1)
			push!(indsyRecover, c1) #The goal of function is to return indices that can be used to index into union and return original vectors
			c1 += 1
			nx += 1
			ny += 1
		end
	end
	if nx <= length(x)
		for n = nx:length(x)
			push!(indsxRecover, c1)
			c1 += 1
		end
	elseif ny <= length(y)
		for n = ny:length(y)
			push!(indsyRecover, c1)
			c1 += 1
		end
	end

	return(indsxRecover, indsyRecover)
end
unionIndex{T}(x::SortedVectorType{T}, y::SortedVectorType{T}) = unionIndex(SortedVector(x, alreadySorted=true), SortedVector(y, alreadySorted=true))
function union{T}(x::SortedVector{T}, y::SortedVector{T})
	length(x) == 0 && return(y)
	length(y) == 0 && return(x)
	nx = 1
	ny = 1
	xy = SortedVector(T)
	if x[end] < y[1] #Special case shortcut
		[ push!(xy.x, x[n]) for n = 1:length(x) ]
		[ push!(xy.x, y[n]) for n = 1:length(y) ]
		return(xy)
	elseif y[end] < x[1]  #Special case shortcut
		[ push!(xy.x, y[n]) for n = 1:length(y) ]
		[ push!(xy.x, x[n]) for n = 1:length(x) ]
		return(xy)
	end
	while nx <= length(x) && ny <= length(y)
		if x[nx] < y[ny]
			push!(xy.x, x[nx])
			nx += 1
		elseif x[nx] > y[ny]
			push!(xy.x, y[ny])
			ny += 1
		else
			push!(xy.x, x[nx])
			nnx = nx + 1
			while nnx <= length(x)
				if x[nnx] != y[ny]
					break
				else
					push!(xy.x, x[nnx])
					nnx += 1
				end
			end
			push!(xy.x, y[ny])
			nny = ny + 1
			while nny <= length(y)
				if y[nny] != x[nx]
					break
				else
					push!(xy.x, y[nny])
					nny += 1
				end
			end
			nx = nnx
			ny = nny
		end
	end
	if nx <= length(x)
		[ push!(xy.x, x[n]) for n = nx:length(x) ]
	elseif ny <= length(y)
		[ push!(xy.x, y[n]) for n = ny:length(y) ]
	end
	return(xy)
end
function union{T}(x::SortedUniqueVector{T}, y::SortedUniqueVector{T})
	length(x) == 0 && return(y)
	length(y) == 0 && return(x)
	nx = 1
	ny = 1
	xy = SortedUniqueVector(T)
	if x[end] < y[1] #Special case shortcut
		[ push!(xy.x, x[n]) for n = 1:length(x) ]
		[ push!(xy.x, y[n]) for n = 1:length(y) ]
		return(xy)
	elseif y[end] < x[1]  #Special case shortcut
		[ push!(xy.x, y[n]) for n = 1:length(y) ]
		[ push!(xy.x, x[n]) for n = 1:length(x) ]
		return(xy)
	end
	while nx <= length(x) && ny <= length(y)
		if x[nx] < y[ny]
			push!(xy.x, x[nx])
			nx += 1
		elseif x[nx] > y[ny]
			push!(xy.x, y[ny])
			ny += 1
		else
			push!(xy.x, x[nx]) #Only push x[nx] to avoid duplication
			nx += 1
			ny += 1
		end
	end
	if nx <= length(x)
		[ push!(xy.x, x[n]) for n = nx:length(x) ]
	elseif ny <= length(y)
		[ push!(xy.x, y[n]) for n = ny:length(y) ]
	end
	return(xy)
end
union{T}(x::SortedVectorType{T}, y::SortedVectorType{T}) = union(SortedVector(x, alreadySorted=true), SortedVector(y, alreadySorted=true))
#setdiff!, setdiff (note, is essentially equivalent to complement, where x is the space, and we want the complement of y)
function setdiff!{T}(x::SortedVector{T}, y::SortedVector{T})
	nx = length(x)
	ny = length(y)
	if x[end] < y[1] || y[end] < x[1] #Special case shortcut
		return(true)
	end
	while nx >= 1 && ny >= 1
		if x[nx] > y[ny]
			nx -= 1
		elseif x[nx] < y[ny]
			ny -= 1
		else
			deleteat!(x, nx)
			nnx = nx - 1
			while nnx >= 1
				if x[nnx] != y[ny]
					break
				else
					deleteat!(x, nnx)
					nnx -= 1
				end
			end
			nx = nnx
			ny -= 1
		end
	end
	return(true)
end
function setdiff!{T}(x::SortedUniqueVector{T}, y::SortedUniqueVector{T})
	nx = length(x)
	ny = length(y)
	if x[end] < y[1] || y[end] < x[1] #Special case shortcut
		return(true)
	end
	while nx >= 1 && ny >= 1
		if x[nx] > y[ny]
			nx -= 1
		elseif x[nx] < y[ny]
			ny -= 1
		else
			deleteat!(x, nx)
			nx -= 1
			ny -= 1
		end
	end
	return(true)
end
setdiff!{T}(x::SortedVector{T}, y::SortedUniqueVector{T}) = setdiff!(x, SortedVector(y, alreadySorted=true))
setdiff!{T}(x::SortedUniqueVector{T}, y::SortedVector{T}) = setdiff!(x, SortedUniqueVector(y, alreadySorted=true)) #
function setdiff{T}(x::SortedVectorType{T}, y::SortedVectorType{T})
	xOut = deepcopy(x)
	setdiff!(xOut, y)
	return(xOut)
end
#unique!, unique, isunique (note, I deliberately choose NOT to return a SortedUniqueVector here. If the user wants that, they can do it as an additional step)
function isunique(x::SortedVector)
	for n = 2:length(x)
		if x[n] == x[n-1]
			return(false)
		end
	end
	return(true)
end
function unique!(x::SortedVector)
	for n = length(x):-1:2
		if x[n] == x[n-1]
			deleteat!(x, n)
		end
	end
	return(true)
end
function unique(x::SortedVector)
	xOut = deepcopy(x)
	unique!(xOut)
	return(xOut)
end
#deletenotat!
deletenotat!(s::SortedVectorType, r::UnitRange) = deleteat!(s, setdiffIndex(length(s), r))
deletenotat!(s::SortedVectorType, inds::IntSet) = deleteat!(s, setdiffIndex(length(s), collect(inds)))
deletenotat!(s::SortedVectorType, inds::Vector{Int}; alreadySorted::Bool=false) = deleteat!(s, setdiffIndex(length(s), inds, alreadySorted=alreadySorted))
deletenotat!(s::SortedVectorType, i::Int) = deletenotat!(s, [i], alreadySorted=true)
#trimRange, trim!, trim
function trimRange{T}(x::SortedVectorType{T}, xLB::T, xUB::T)
	length(x) == 0 && return(1:0)
	xLB > xUB && error("xLB is greater than xUB")
	xLB > x[end] && return(UnitRange(length(x)+1, length(x))) #Special-case shortcut
	xUB < x[1] && return(UnitRange(1, 0)) #Special-case shortcut
	r = UnitRange(searchfirst(x, xLB), searchlast(x, xUB))
	r.start > length(x) && return(UnitRange(length(x)+1, length(x)))
	r.stop < 1 && return(UnitRange(1, 0))
	return(r)
end
function trim!{T}(x::SortedVectorType{T}, xLB::T, xUB::T)
	r = trimRange(x, xLB, xUB)
	deletenotat!(x, r)
	return(r)
end
function trim{T}(x::SortedVectorType{T}, xLB::T, xUB::T)
	xOut = deepcopy(x)
	trim!(xOut, xLB, xUB)
	return(xOut)
end



#----------------------------------------------------------
#FUNCTION
#	constructMesh
#INPUT
#	{T1, T2}(intervalStart::T1, intervalEnd::T1, intervalLength::T2): Any types. Note, intervalLength need not be the same type as intervalStart and intervalEnd.
#PURPOSE
#	Build a mesh corresponding to a given start, end, and interval length.
#----------------------------------------------------------
function constructMesh{T1, T2}(intervalStart::T1, intervalEnd::T1, intervalLength::T2)
	intervalStart > intervalEnd && error("intervalStart must be strictly less than intervalEnd")
	intervalStart + intervalLength > intervalEnd && return(SortedUniqueVector([intervalStart, intervalEnd]))
	m = [intervalStart:intervalLength:intervalEnd]
	m[end] != intervalEnd && push!(m, intervalEnd)
	return(SortedUniqueVector(m))
end




#----------------------------------------------------------
#FUNCTION(S)
#	meshIndex
#PURPOSE
#	Obtain a set of indices corresponding to the specified mesh of the input time-series.
#----------------------------------------------------------
function meshIndex{T}(x::SortedVectorType{T}, m::SortedUniqueVector{T})
	if length(x) == 0 || length(m) == 0; error("Empty input vector"); end
	inds = Array(Int, length(m))
	nx = 1
	nm = 1
	while nx <= length(x) && nm <= length(m)
		if x[nx] > m[nm]
			inds[nm] = nx - 1
			nm += 1
		else
			nx += 1
		end
	end
	for n = nm:length(m) #This loop will only initiate if the while loop breaks because of nx. If that occurs, then this loop fills out the remainder of index with the index of last observation in x
		inds[n] = length(x)
	end
	return(inds)
end
meshIndex{T}(x::SortedVectorType{T}, m::SortedVector{T}) = meshIndex(x, SortedUniqueVector(m, alreadySorted=true))
meshIndex{T1, T2}(x::SortedVectorType{T1}, intervalLength::T2) = meshIndex(x, constructMesh(x[1], x[end], intervalLength))
meshIndex{T1, T2}(x::SortedVectorType{T1}, intervalStart::T1, intervalEnd::T1, intervalLength::T2) = meshIndex(x, constructMesh(intervalStart, intervalEnd, intervalLength))




#----------------------------------------------------------
#FUNCTION(S)
#	mesh
#INPUT
#	{T}(x::SortedVectorType{T}, m::SortedUniqueVector{T}; trimMesh::Bool=true): Get the mesh of x corresponding to m. If trimMesh=true, then m is adjusted via trimMesh!
#OUTPUT
#	Output will always be a SortedVector{T}, since even if x is SortedUniqueVector{T}, we cannot guarantee that the mesh of x will be unique.
#PURPOSE
#	Adjust x according to a mesh
#NOTES
#	Could usefully implement a mesh! version
#	If trimMesh=false, then the output vector xOut will have xOut[n] = NaN if x[n] > m[1]
#----------------------------------------------------------
mesh(x::SortedVectorType, k::Int64=1, kStart::Int64=1) = x[constructMesh(length(x), k, kStart)]
function mesh{T}(x::SortedVectorType{T}, m::SortedUniqueVector{T}; trimMesh::Bool=true)
	mC = deepcopy(m)
	if trimMesh == true
		trim!(mC, x[1], x[end])
		return(SortedVector(x[meshIndex(x, mC)], alreadySorted=true), mC)
	else
		mI = meshIndex(x, mC)
		xNew = Array(T, length(mI))
		for n = 1:length(mI)
			mI[n] == 0 ? (xNew[n] = NaN) : (xNew[n] = x[mI[n]])
		end
		return(SortedVector(xNew, alreadySorted=true), mC)
	end
end
mesh{T}(x::SortedVectorType{T}, m::SortedVector{T}) = mesh(x, SortedUniqueVector(m, alreadySorted=true))
mesh{T1, T2}(x::SortedVectorType{T1}, intervalLength::T2) = mesh(x, constructMesh(x[1], x[end], intervalLength), trimMesh=false) #mesh will already be adjusted by constructMesh
mesh{T1, T2}(x::SortedVectorType{T1}, intervalStart::T1, intervalEnd::T1, intervalLength::T2, trimMesh::Bool=true) = mesh(x, constructMesh(intervalStart, intervalEnd, intervalLength), trimMesh=trimMesh)



#----------------------------------------------------------
#FUNCTION(S)
#	isuniquesort
#INPUT
#	Function accepts:
#		(x::Vector{T}): x is assumed to be sorted in ascending order.
#OUTPUT
#	A boolean indicating whether x is unique (ie return true if no duplicates, false if duplicates)
#PURPOSE
#	Efficiently check if the input vector is sorted given the knowledge that the input is sorted
#NOTES
#	Non-exported function used in the inner constructor of a SortedUniqueVector
#----------------------------------------------------------
function isuniquesort{T}(x::Vector{T})
	for n = 2:length(x)
		if x[n] == x[n-1]
			return(false)
		end
	end
	return(true)
end


#----------------------------------------------------------
#FUNCTION(S)
#	uniquesort!
#	uniquesort
#INPUT
#	Function accepts:
#		(x::Vector{T}): x is assumed to be sorted in ascending order.
#OUTPUT
#	A unique version of x (still sorted)
#PURPOSE
#	Efficiently obtain a unique version of the input vector given the knowledge that the input is sorted
#NOTES
#	Non-exported function used in the inner constructor of SortedVector and SortedUniqueVector
#----------------------------------------------------------
function uniquesort!{T}(x::Vector{T})
	for n = length(x):-1:2
		if x[n] == x[n-1]
			deleteat!(x, n)
		end
	end
	return(x)
end
uniquesort{T}(x::Vector{T}) = uniquesort!(deepcopy(x))




#----------------------------------------------------------
#FUNCTION(S)
#	setdiffIndex
#INPUT
#	Function accepts:
#		(N::Int, inds::IntSet): Provides the complement of x on 1:N
#		(N::Int, inds::Vector{Int}; alreadySorted::Bool=false):
#		(N::Int, r::UnitRange):
#OUTPUT
#	Vector{Int} of the complement of the input
#PURPOSE
#	Function to find the complement of a set of indices
#NOTES
#	Non-exported function used to find the complement of a set of indices
#----------------------------------------------------------
function setdiffIndex(N::Int, inds::IntSet)
	indsOut = setdiff(IntSet(1:N), inds)
	return(collect(indsOut))
end
function setdiffIndex(N::Int, inds::Vector{Int}; alreadySorted::Bool=false)
	alreadySorted == false && sort!(inds)
	return(setdiffIndex(N, IntSet(inds)))
end
function setdiffIndex(N::Int, r::UnitRange)
	r.start < 1 && error("Bounds error on UnitRange")
	r.stop > N && error("Bounds error on UnitRange")
	return(setdiffIndex(N, IntSet([r.start:r.stop])))
end











end # module




