### Population MCMC using Friel's method based on power posteriors

immutable FrielMCRunner <: Lora.ParrallelMCRunner
  burnin::Int
  thinning::Int
  nsteps::Int
  r::Range{Int}
  storegradlogtarget::Bool # Indicates whether to save the gradient of the log-target in the cases it is available
  t::Vector{Float64} # temperature ladder
  swapproposal::Function

  # Note that swapproposal has been temporarily set by default to identity until a temperature density is implemented
  # swapproposal is a function f : {n}⊆N -> SxR. Some more info about f:
  # 1) n is the length of the fixed temperature ladder vector
  # 2) S and R denotes the sets of sender and receiver procs, both subsets of T(n) := {1, 2, ..., n}
  # 3) f(n) = {s_l, r_l : l ∈ T(n)} ⊆ SxR
  # 4) f can be either pure or stochastic, but in all cases must generate non-overlapping MPI-compatible pairs
  function FrielMCRunner(
    r::Range{Int},
    storegradlogtarget::Bool=false,
    t::Vector{Float64}=map(t->t^4, 0:1/10:1),
    swapproposal::Function=identity)
    burnin = first(r)-1
    thinning = r.step
    nsteps = last(r)
    @assert burnin >= 0 "Number of burn-in iterations should be non-negative."
    @assert thinning >= 1 "Thinning should be >= 1."
    @assert nsteps > burnin "Total number of MCMC iterations should be greater than number of burn-in iterations."
    @assert length(t) >= 2 "Temperature ladder must contain at least two temperatures."
    @assert t[1] == 0.0 "Temperature ladder must start at 0."
    @assert t[end] == 1.0 "Temperature ladder must end at 1."
    new(burnin, thinning, nsteps, r, storegradlogtarget, t, swapproposal)
  end
end

FrielMCRunner(
  r::Range1{Int},
  storegradlogtarget::Bool=false,
  t::Vector{Float64}=map(t->t^4, 0:1/10:1),
  swapproposal::Function=identity) =
  FrielMCRunner(first(r):1:last(r), storegradlogtarget, t, swapproposal)

FrielMCRunner(;
  burnin::Int=0,
  thinning::Int=1,
  nsteps::Int=100,
  storegradlogtarget::Bool=false,
  t::Vector{Float64}=map(t->t^4, 0:1/10:1),
  swapproposal::Function=identity) =
  FrielMCRunner((burnin+1):thinning:nsteps, storegradlogtarget, t, swapproposal)

typealias FrielMC FrielMCRunner

function run(
  mpistate::MPIState,
  m::MCLikelihoodPatch,
  s::Vector{Lora.MCSampler},
  r::FrielMC,
  t::Vector{Lora.MCTuner})

  if MPIState.procid == MPIState.rootproc
    tic()
  end

  mcmodel = MCLikelihood(x->t[mpistate.procid]*m.lik(x), m.prior, init=m.init)
  mcrunner = SerialMC(burnin=r.burnin, thinning=r.thinning, nsteps=r.nsteps, storegradlogtarget=r.storegradlogtarget)

  mcjob = MCJob(mcmodel, s[mpistate.procid], mcrunner; tuner=t[mpistate.procid], job=:plain)

  mcchain = MCChain(mcmodel.size, length(mcrunner.r); storegradlogtarget=mcrunner.storegradlogtarget)
  ds = Dict{Any, Any}("step" => collect(mcrunner.r))
end
