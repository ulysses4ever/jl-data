### Population MCMC using Friel's method based on power posteriors

immutable FrielMCRunner <: ParrallelMCRunner
  burnin::Int
  thinning::Int
  nsteps::Int
  r::Range{Int}
  storegradlogtarget::Bool # Indicates whether to save the gradient of the log-target in the cases it is available
  swapproposal::Function

  # Note that swapproposal has been temporarily set by default to identity until a temperature density is implemented
  function FrielMCRunner(r::Range{Int}, storegradlogtarget::Bool=false, swapproposal::Function=identity)
    burnin = first(r)-1
    thinning = r.step
    nsteps = last(r)
    @assert burnin >= 0 "Number of burn-in iterations should be non-negative."
    @assert thinning >= 1 "Thinning should be >= 1."
    @assert nsteps > burnin "Total number of MCMC iterations should be greater than number of burn-in iterations."
    new(burnin, thinning, nsteps, r, storegradlogtarget, swapproposal)
  end
end

FrielMCRunner(r::Range1{Int}, storegradlogtarget::Bool=false, swapproposal::Function=identity) =
  FrielMCRunner(first(r):1:last(r), storegradlogtarget::Bool, swapproposal::Function)

FrielMCRunner(;
  burnin::Int=0,
  thinning::Int=1,
  nsteps::Int=100,
  storegradlogtarget::Bool=false,
  swapproposal::Function=identity) =
  FrielMCRunner((burnin+1):thinning:nsteps, storegradlogtarget, swapproposal)

typealias FrielMC FrielMCRunner
