### Population MCMC using Friel's method based on power posteriors

immutable FrielMCRunner <: Lora.ParrallelMCRunner
  burnin::Int
  thinning::Int
  nsteps::Int
  r::Range{Int}
  temperatureladder::Vector{Float64}
  storegradlogtarget::Bool # Indicates whether to save the gradient of the log-target in the cases it is available
  swapproposal::Function

  # Note that swapproposal has been temporarily set by default to identity until a temperature density is implemented
  function FrielMCRunner(r::Range{Int},
    temperatureladder::Vector{Float64},
    storegradlogtarget::Bool=false,
    swapproposal::Function=identity)
    burnin = first(r)-1
    thinning = r.step
    nsteps = last(r)
    @assert burnin >= 0 "Number of burn-in iterations should be non-negative."
    @assert thinning >= 1 "Thinning should be >= 1."
    @assert nsteps > burnin "Total number of MCMC iterations should be greater than number of burn-in iterations."
    new(burnin, thinning, nsteps, r, temperatureladder, storegradlogtarget, swapproposal)
  end
end

FrielMCRunner(r::Range1{Int},
  temperatureladder::Vector{Float64},
  storegradlogtarget::Bool=false,
  swapproposal::Function=identity) =
  FrielMCRunner(first(r):1:last(r), temperatureladder, storegradlogtarget, swapproposal)

FrielMCRunner(;
  burnin::Int=0,
  thinning::Int=1,
  nsteps::Int=100,
  temperatureladder::Vector{Float64}=collect(0:0.1:1),
  storegradlogtarget::Bool=false,
  swapproposal::Function=identity) =
  FrielMCRunner((burnin+1):thinning:nsteps, temperatureladder, storegradlogtarget, swapproposal)

  FrielMCRunner(;
    burnin::Int=0,
    thinning::Int=1,
    nsteps::Int=100,
    temperatureladder::Function=(n, c)->map(t->t^c, 0:1/n:1),
    storegradlogtarget::Bool=false,
    swapproposal::Function=identity) =
    FrielMCRunner((burnin+1):thinning:nsteps, temperatureladder(10, 4), storegradlogtarget, swapproposal)

typealias FrielMC FrielMCRunner

function run(
  mpistate::MPIState,
  m::Lora.MCModel,
  s::Vector{Lora.MCSampler},
  r::FrielMC,
  t::Vector{Lora.MCTuner})

  if MPIState.procid == MPIState.rootproc
    tic()
  end

  mcmodel =

  mcjob = MCJob(mcmodel, s[MPIState.procid], r; tuner=t[MPIState.procid], job=:plain)

  mcchain = MCChain(m.size, length(r.r); storegradlogtarget=r.storegradlogtarget)
  ds = Dict{Any, Any}("step" => collect(r.r))
end
