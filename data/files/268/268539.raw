###################################################
## Defines the 'InstanceGraph' type
###################################################

type InstanceNode
  node_type::TypeNode
  arr_time::Int64
  departed::Bool
  matched::Bool
  dep_time::Int64

  "Constructor: reference to the node type"
  function InstanceNode(type_node::TypeNode, arr::Int64)
    obj = new()
    obj.node_type = type_node
    obj.departed = false
    obj.matched = false
    obj.arr_time = arr
    obj.dep_time = -1
    return obj
  end
end

type InstanceGraph
  type_graph::TypeGraph
  all_nodes::Array{InstanceNode,1}
  present_nodes::Array{InstanceNode,1}
  n_all::Int64
  n_present::Int64

  "Constructor: reference to the underlying type graph.
  returns an empty InstanceGraph"
  function InstanceGraph(tg::TypeGraph)
    obj = new()
    obj.type_graph = tg
    obj.all_nodes = Array(InstanceNode,0)
    obj.present_nodes = Array(InstanceNode,0)
    obj.n_all = 0
    obj.n_present = 0
    return obj
  end
end

function arrival!(pool::InstanceGraph, node::TypeNode, arr_time::Int64)
  new_node = InstanceNode(node, arr_time)
  push!(pool.all_nodes, new_node)
  push!(pool.present_nodes, new_node)
  pool.n_all += 1
  pool.n_present += 1
end

function departures!(pool::InstanceGraph, time::Int64)
  copy = pool.present_nodes[:]
  for n in copy
    if rand() < n.node_type.dep_rate
      n.departed = true
      n.dep_time = time
      deleteat!(pool.present_nodes, findin(pool.present_nodes, [n]))
      pool.n_present -= 1
    end
  end
end

"Removes from the pool the nodes corresponding to the node_ids.
Relates to how the adjacency matrix is generated"
function remove_matched!(pool::InstanceGraph, node_ids::Array{Int64,1}, time::Int64)
  for n in node_ids
    pool.present_nodes[n].matched = true
    pool.present_nodes[n].dep_time = time
  end
  deleteat!(pool.present_nodes, node_ids)
  pool.n_present -= length(node_ids)
end

function am_generator(pool::InstanceGraph)
  n = length(pool.present_nodes)
  adjacency_matrix = zeros(Int64, (n,n))
  g = pool.type_graph.graph
  for i =1:n
    id_i = pool.present_nodes[i].node_type.id
    for j =1:n
      id_j = pool.present_nodes[j].node_type.id
      if has_edge(g, id_i, id_j) == 1 && i != j
        adjacency_matrix[i,j] = 1
      end
    end
  end
  return adjacency_matrix
end

type Edges
  n_nodes::Int64
  list::Array{Tuple{Int64,Int64}, 1}
  outgoing::Array{Array{Int64,1},1}
  ingoing::Array{Array{Int64,1},1}
end

"# returns a list of all the edges,
# and two lists of the ingoing and outgoing edges to each of the vertices"
function edge_list_generator(pool::InstanceGraph, p::Params)
  edge_list = []
  n = length(pool.present_nodes)
  g = pool.type_graph.graph
  outgoing_edges = [[] for i in 1:n]
  ingoing_edges = [[] for i in 1:n]
  non_isolated = list_non_isolated(pool)
  for i in non_isolated
    id_i = pool.present_nodes[i].node_type.id
    for j in non_isolated
      id_j = pool.present_nodes[j].node_type.id
      if p.techno == "2_cycles"
        if has_edge(g, id_i, id_j) == 1 && i != j && has_edge(g, id_j, id_i) == 1
          push!(edge_list, (i,j))
          push!(outgoing_edges[i], j)
          push!(ingoing_edges[j], i)
        end
      else
        if has_edge(g, id_i, id_j) == 1 && i != j
          push!(edge_list, (i,j))
          push!(outgoing_edges[i], j)
          push!(ingoing_edges[j], i)
        end
      end
    end
  end
  return Edges(n, edge_list, outgoing_edges, ingoing_edges)
end

function list_non_isolated(pool::InstanceGraph)
  g = pool.type_graph.graph
  n = length(pool.present_nodes)
  outgoing_edges = [[] for i in 1:n]
  ingoing_edges = [[] for i in 1:n]
  for i =1:n
    id_i = pool.present_nodes[i].node_type.id
    for j =1:n
      id_j = pool.present_nodes[j].node_type.id
      if has_edge(g, id_i, id_j) == 1 && i != j
        push!(outgoing_edges[i], j)
        push!(ingoing_edges[j], i)
      end
    end
  end
  non_isolated = []
  for i in 1:n
    if outgoing_edges[i] != [] && ingoing_edges[i] != []
      push!(non_isolated, i)
    end
  end
  return non_isolated
end
