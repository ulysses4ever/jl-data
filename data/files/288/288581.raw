[{"sections": {"Histograms": {"functionItems": {"comparehist": {"functionParams": {"H2": {"index": 1, "description": " \u2013 Second compared histogram of the same size as  H1 .", "title": "H2", "required": true, "references": ["H1"], "type": ["InputArray"], "isOutput": false}, "H1": {"index": 0, "description": " \u2013 First compared histogram.", "title": "H1", "required": true, "type": ["InputArray"], "isOutput": false}, "method": {"index": 2, "description": " \u2013 Comparison method that could be one of the following:\n\nCV_COMP_CORREL     Correlation\nCV_COMP_CHISQR     Chi-Square\nCV_COMP_INTERSECT     Intersection\nCV_COMP_BHATTACHARYYA     Bhattacharyya distance\nCV_COMP_HELLINGER     Synonym for CV_COMP_BHATTACHARYYA\n\n", "title": "method", "required": true, "references": ["CV_COMP_BHATTACHARYYA"], "type": ["int"], "isOutput": false}}, "description": "Compares two histograms.", "title": "comparehist", "outputParamTypes": {"compareHist": ["double"]}, "optionalInput": [""], "inputParamTypes": {"H2": ["InputArray"], "H1": ["InputArray"], "method": ["int"], "SparseMat&": ["const"]}, "input": ["H1", "H2", "method"], "invocation": ["cv2.compareHist"], "output": ["retval"]}, "equalizehist": {"functionParams": {"src": {"index": 0, "description": " \u2013 Source 8-bit single channel image.", "title": "src", "required": true, "type": ["InputArray"], "isOutput": false}, "dst": {"index": 1, "description": " \u2013 Destination image of the same size and type as  src .", "title": "dst", "required": false, "references": ["src"], "returnIndex": 0, "type": ["OutputArray"], "isOutput": true}}, "description": "Equalizes the histogram of a grayscale image.", "title": "equalizehist", "outputParamTypes": {"equalizeHist": ["void"]}, "optionalInput": ["dst"], "inputParamTypes": {"src": ["InputArray"], "dst": ["OutputArray"]}, "input": ["src"], "invocation": ["cv2.equalizeHist"], "output": ["dst"]}, "calcbackproject": {"functionParams": {"ranges": {"index": 3, "required": true, "title": "ranges", "description": " \u2013 Array of arrays of the histogram bin boundaries in each dimension. See  calcHist() .", "isOutput": false}, "backProject": {"references": ["images[0]"], "description": " \u2013 Destination back projection array that is a single-channel array of the same size and depth as  images[0] .", "title": "backProject"}, "hist": {"index": 2, "description": " \u2013 Input histogram that can be dense or sparse.", "title": "hist", "required": true, "type": ["InputArray"], "isOutput": false}, "uniform": {"description": " \u2013 Flag indicating whether the histogram is uniform or not (see above).", "title": "uniform"}, "channels": {"index": 1, "description": " \u2013 The list of channels used to compute the back projection. The number of channels must match the histogram dimensionality. The first array channels are numerated from 0 to  images[0].channels()-1 , the second array channels are counted from  images[0].channels()  to  images[0].channels() + images[1].channels()-1,  and so on.", "title": "channels", "required": true, "references": ["images[0].channels()-1", "images[0].channels()", "images[0].channels()", "", "+", "", "images[1].channels()-1"], "isOutput": false}, "scale": {"index": 4, "description": " \u2013 Optional scale factor for the output back projection.", "title": "scale", "required": true, "type": ["double"], "isOutput": false}, "images": {"index": 0, "description": " \u2013 Source arrays. They all should have the same depth,  CV_8U  or  CV_32F , and the same size. Each of them can have an arbitrary number of channels.", "title": "images", "required": true, "references": ["CV_8U", "CV_32F"], "isOutput": false}, "nimages": {"description": " \u2013 Number of source images.", "title": "nimages"}}, "description": "Calculates the back projection of a histogram.", "title": "calcbackproject", "outputParamTypes": {"calcBackProject": ["void"]}, "optionalInput": ["dst"], "inputParamTypes": {"backProject": ["OutputArray"], "uniform": ["bool"], "float**": ["const"], "SparseMat&": ["const"], "int*": ["const"], "hist": ["InputArray"], "scale": ["double"], "nimages": ["int"], "Mat*": ["const"]}, "input": ["images", "channels", "hist", "ranges", "scale"], "invocation": ["cv2.calcBackProject"], "output": ["dst"]}, "calchist": {"functionParams": {"hist": {"index": 5, "description": " \u2013 Output histogram, which is a dense or sparse  dims -dimensional array.", "title": "hist", "required": false, "references": ["dims"], "returnIndex": 0, "type": ["OutputArray", "SparseMat&"], "isOutput": true}, "accumulate": {"index": 6, "description": " \u2013 Accumulation flag. If it is set, the histogram is not cleared in the beginning when it is allocated. This feature enables you to compute a single histogram from several sets of arrays, or to update the histogram in time.", "title": "accumulate", "required": false, "type": ["bool"], "isOutput": false}, "mask": {"index": 2, "description": " \u2013 Optional mask. If the matrix is not empty, it must be an 8-bit array of the same size as  images[i] . The non-zero mask elements mark the array elements counted in the histogram.", "title": "mask", "required": true, "references": ["images[i]"], "type": ["InputArray"], "isOutput": false}, "uniform": {"description": " \u2013 Flag indicating whether the histogram is uniform or not (see above).", "title": "uniform"}, "histSize": {"index": 3, "required": true, "title": "histSize", "description": " \u2013 Array of histogram sizes in each dimension.", "isOutput": false}, "channels": {"index": 1, "description": " \u2013 List of the  dims  channels used to compute the histogram. The first array channels are numerated from 0 to  images[0].channels()-1 , the second array channels are counted from  images[0].channels()  to  images[0].channels() + images[1].channels()-1,  and so on.", "title": "channels", "required": true, "references": ["dims", "images[0].channels()-1", "images[0].channels()", "images[0].channels()", "", "+", "", "images[1].channels()-1"], "isOutput": false}, "dims": {"references": ["CV_MAX_DIMS"], "description": " \u2013 Histogram dimensionality that must be positive and not greater than  CV_MAX_DIMS (equal to 32 in the current OpenCV version).", "title": "dims"}, "images": {"index": 0, "description": " \u2013 Source arrays. They all should have the same depth,  CV_8U  or  CV_32F , and the same size. Each of them can have an arbitrary number of channels.", "title": "images", "required": true, "references": ["CV_8U", "CV_32F"], "isOutput": false}, "ranges": {"index": 4, "description": " \u2013 Array of the dims  arrays of the histogram bin boundaries in each dimension. When the histogram is uniform ( uniform =true), then for each dimension  i  it is enough to specify the lower (inclusive) boundary    of the 0-th histogram bin and the upper (exclusive) boundary    for the last histogram bin  histSize[i]-1 . That is, in case of a uniform histogram each of  ranges[i]  is an array of 2 elements. When the histogram is not uniform ( uniform=false ), then each of  ranges[i]  contains  histSize[i]+1  elements:   . The array elements, that are not between    and   , are not counted in the histogram.", "title": "ranges", "required": true, "references": ["dims", "uniform", "i", "histSize[i]-1", "ranges[i]", "uniform=false", "ranges[i]", "histSize[i]+1"], "isOutput": false}, "nimages": {"description": " \u2013 Number of source images.", "title": "nimages"}}, "description": "Calculates a histogram of a set of arrays.", "title": "calchist", "outputParamTypes": {"calcHist": ["void"]}, "optionalInput": ["hist", "accumulate"], "inputParamTypes": {"uniform": ["bool"], "mask": ["InputArray"], "float**": ["const"], "int*": ["const"], "hist": ["OutputArray", "SparseMat&"], "dims": ["int"], "accumulate": ["bool"], "nimages": ["int"], "Mat*": ["const"]}, "input": ["images", "channels", "mask", "histSize", "ranges"], "invocation": ["cv2.calcHist"], "output": ["hist"]}}, "title": "Histograms"}}, "title": "test"}
],[{"sections": {"Image Filtering": {"functionItems": {"copymakeborder": {"functionParams": {"src": {"index": 0, "description": " \u2013 Source image.", "title": "src", "required": true, "type": ["InputArray"], "isOutput": false}, "right": {"index": 4, "description": " \u2013 Parameter specifying how many pixels in each direction from the source image rectangle to extrapolate. For example,  top=1, bottom=1, left=1, right=1  mean that 1 pixel-wide border needs to be built.", "title": "right", "required": true, "references": ["top=1,", "", "bottom=1,", "", "left=1,", "", "right=1"], "type": ["int"], "isOutput": false}, "bottom": {"index": 2, "description": " \u2013 ", "title": "bottom", "required": true, "type": ["int"], "isOutput": false}, "dst": {"index": 6, "description": " \u2013 Destination image of the same type as  src  and the size  Size(src.cols+left+right, src.rows+top+bottom) .", "title": "dst", "required": false, "references": ["src", "Size(src.cols+left+right,", "", "src.rows+top+bottom)"], "returnIndex": 0, "type": ["OutputArray"], "isOutput": true}, "value": {"index": 7, "description": " \u2013 Border value if  borderType==BORDER_CONSTANT .", "title": "value", "required": false, "references": ["borderType==BORDER_CONSTANT"], "isOutput": false}, "borderType": {"index": 5, "description": " \u2013 Border type. See  borderInterpolate() for details.", "title": "borderType", "required": true, "type": ["int"], "isOutput": false}, "top": {"index": 1, "description": " \u2013 ", "title": "top", "required": true, "type": ["int"], "isOutput": false}, "left": {"index": 3, "description": " \u2013 ", "title": "left", "required": true, "type": ["int"], "isOutput": false}}, "description": "Forms a border around an image.", "title": "copymakeborder", "outputParamTypes": {"copyMakeBorder": ["void"]}, "optionalInput": ["dst", "value"], "inputParamTypes": {"src": ["InputArray"], "right": ["int"], "bottom": ["int"], "dst": ["OutputArray"], "Scalar&": ["const"], "borderType": ["int"], "top": ["int"], "left": ["int"]}, "input": ["src", "top", "bottom", "left", "right", "borderType"], "invocation": ["cv2.copyMakeBorder"], "output": ["dst"]}, "sobel": {"functionParams": {"src": {"index": 0, "description": " \u2013 input image.", "title": "src", "required": true, "type": ["InputArray"], "isOutput": false}, "scale": {"index": 6, "description": " \u2013 optional scale factor for the computed derivative values; by default, no scaling is applied (see  getDerivKernels() for details).", "title": "scale", "required": false, "type": ["double"], "isOutput": false}, "yorder": {"description": " \u2013 order of the derivative y.", "title": "yorder"}, "dst": {"index": 4, "description": " \u2013 output image of the same size and the same number of channels as  src .", "title": "dst", "required": false, "references": ["src"], "returnIndex": 0, "type": ["OutputArray"], "isOutput": true}, "ddepth": {"index": 1, "description": " \u2013 \noutput image depth; the following combinations of src.depth() and ddepth are supported:\n\nsrc.depth() = CV_8U, ddepth = -1/CV_16S/CV_32F/CV_64F\nsrc.depth() = CV_16U/CV_16S, ddepth = -1/CV_32F/CV_64F\nsrc.depth() = CV_32F, ddepth = -1/CV_32F/CV_64F\nsrc.depth() = CV_64F, ddepth = -1/CV_64F\n\n\n\nwhen ddepth=-1, the destination image will have the same depth as the source; in the case of 8-bit input images it will result in truncated derivatives.\n", "title": "ddepth", "required": true, "references": ["src.depth()", "ddepth", "src.depth()", "CV_8U", "ddepth", "CV_16S", "CV_32F", "CV_64F", "src.depth()", "CV_16U", "CV_16S", "ddepth", "CV_32F", "CV_64F", "src.depth()", "CV_32F", "ddepth", "CV_32F", "CV_64F", "src.depth()", "CV_64F", "ddepth", "CV_64F", "ddepth=-1"], "type": ["int"], "isOutput": false}, "borderType": {"index": 8, "description": " \u2013 pixel extrapolation method (see  borderInterpolate() for details).", "title": "borderType", "required": false, "type": ["int"], "isOutput": false}, "ksize": {"index": 5, "description": " \u2013 size of the extended Sobel kernel; it must be 1, 3, 5, or 7.", "title": "ksize", "required": false, "type": ["int"], "isOutput": false}, "xorder": {"description": " \u2013 order of the derivative x.", "title": "xorder"}, "delta": {"index": 7, "description": " \u2013 optional delta value that is added to the results prior to storing them in dst.", "title": "delta", "required": false, "references": ["dst"], "type": ["double"], "isOutput": false}}, "description": "Calculates the first, second, third, or mixed image derivatives using an extended Sobel operator.", "title": "sobel", "outputParamTypes": {"Sobel": ["void"]}, "optionalInput": ["dst", "ksize", "scale", "delta", "borderType"], "inputParamTypes": {"src": ["InputArray"], "scale": ["double"], "dst": ["OutputArray"], "delta": ["double"], "ddepth": ["int"], "borderType": ["int"], "ksize": ["int"], "dx": ["int"], "dy": ["int"]}, "input": ["src", "ddepth", "dx", "dy"], "invocation": ["cv2.Sobel"], "output": ["dst"]}, "sepfilter2d": {"functionParams": {"src": {"index": 0, "description": " \u2013 Source image.", "title": "src", "required": true, "type": ["InputArray"], "isOutput": false}, "kernelX": {"index": 2, "description": " \u2013 Coefficients for filtering each row.", "title": "kernelX", "required": true, "type": ["InputArray"], "isOutput": false}, "kernelY": {"index": 3, "description": " \u2013 Coefficients for filtering each column.", "title": "kernelY", "required": true, "type": ["InputArray"], "isOutput": false}, "ddepth": {"index": 1, "description": " \u2013 \nDestination image depth. The following combination of src.depth() and ddepth are supported:\n\nsrc.depth() = CV_8U, ddepth = -1/CV_16S/CV_32F/CV_64F\nsrc.depth() = CV_16U/CV_16S, ddepth = -1/CV_32F/CV_64F\nsrc.depth() = CV_32F, ddepth = -1/CV_32F/CV_64F\nsrc.depth() = CV_64F, ddepth = -1/CV_64F\n\n\n\nwhen ddepth=-1, the destination image will have the same depth as the source.\n", "title": "ddepth", "required": true, "references": ["src.depth()", "ddepth", "src.depth()", "CV_8U", "ddepth", "CV_16S", "CV_32F", "CV_64F", "src.depth()", "CV_16U", "CV_16S", "ddepth", "CV_32F", "CV_64F", "src.depth()", "CV_32F", "ddepth", "CV_32F", "CV_64F", "src.depth()", "CV_64F", "ddepth", "CV_64F", "ddepth=-1"], "type": ["int"], "isOutput": false}, "anchor": {"index": 5, "description": " \u2013 Anchor position within the kernel. The default value    means that the anchor is at the kernel center.", "title": "anchor", "required": false, "type": ["Point"], "isOutput": false}, "borderType": {"index": 7, "description": " \u2013 Pixel extrapolation method. See  borderInterpolate() for details.", "title": "borderType", "required": false, "type": ["int"], "isOutput": false}, "delta": {"index": 6, "description": " \u2013 Value added to the filtered results before storing them.", "title": "delta", "required": false, "type": ["double"], "isOutput": false}, "dst": {"index": 4, "description": " \u2013 Destination image of the same size and the same number of channels as  src .", "title": "dst", "required": false, "references": ["src"], "returnIndex": 0, "type": ["OutputArray"], "isOutput": true}}, "description": "Applies a separable linear filter to an image.", "title": "sepfilter2d", "outputParamTypes": {"sepFilter2D": ["void"]}, "optionalInput": ["dst", "anchor", "delta", "borderType"], "inputParamTypes": {"src": ["InputArray"], "kernelX": ["InputArray"], "kernelY": ["InputArray"], "ddepth": ["int"], "anchor": ["Point"], "borderType": ["int"], "delta": ["double"], "dst": ["OutputArray"]}, "input": ["src", "ddepth", "kernelX", "kernelY"], "invocation": ["cv2.sepFilter2D"], "output": ["dst"]}, "getgaussiankernel": {"functionParams": {"sigma": {"index": 1, "description": " \u2013 Gaussian standard deviation. If it is non-positive, it is computed from  ksize  as  sigma = 0.3*((ksize-1)*0.5 - 1) + 0.8 .", "title": "sigma", "required": true, "references": ["ksize", "sigma", "", "=", "", "0.3*((ksize-1)*0.5", "", "-", "", "1)", "", "+", "", "0.8"], "type": ["double"], "isOutput": false}, "ksize": {"index": 0, "description": " \u2013 Aperture size. It should be odd (  ) and positive.", "title": "ksize", "required": true, "type": ["int"], "isOutput": false}, "ktype": {"index": 2, "description": " \u2013 Type of filter coefficients. It can be  CV_32f  or  CV_64F .", "title": "ktype", "required": false, "references": ["CV_32f", "CV_64F"], "type": ["int"], "isOutput": false}}, "description": "Returns Gaussian filter coefficients.", "title": "getgaussiankernel", "outputParamTypes": {"getGaussianKernel": ["Mat"]}, "optionalInput": ["ktype"], "inputParamTypes": {"sigma": ["double"], "ksize": ["int"], "ktype": ["int"]}, "input": ["ksize", "sigma"], "invocation": ["cv2.getGaussianKernel"], "output": ["retval"]}, "filter2d": {"functionParams": {"src": {"index": 0, "description": " \u2013 input image.", "title": "src", "required": true, "type": ["InputArray"], "isOutput": false}, "kernel": {"index": 2, "description": " \u2013 convolution kernel (or rather a correlation kernel), a single-channel floating point matrix; if you want to apply different kernels to different channels, split the image into separate color planes using  split()  and process them individually.", "title": "kernel", "required": true, "type": ["InputArray"], "isOutput": false}, "dst": {"index": 3, "description": " \u2013 output image of the same size and the same number of channels as src.", "title": "dst", "required": false, "references": ["src"], "returnIndex": 0, "type": ["OutputArray"], "isOutput": true}, "ddepth": {"index": 1, "description": " \u2013 \ndesired depth of the destination image; if it is negative, it will be the same as src.depth(); the following combinations of src.depth() and ddepth are supported:\n\nsrc.depth() = CV_8U, ddepth = -1/CV_16S/CV_32F/CV_64F\nsrc.depth() = CV_16U/CV_16S, ddepth = -1/CV_32F/CV_64F\nsrc.depth() = CV_32F, ddepth = -1/CV_32F/CV_64F\nsrc.depth() = CV_64F, ddepth = -1/CV_64F\n\n\n\nwhen ddepth=-1, the output image will have the same depth as the source.\n", "title": "ddepth", "required": true, "references": ["src.depth()", "src.depth()", "ddepth", "src.depth()", "CV_8U", "ddepth", "CV_16S", "CV_32F", "CV_64F", "src.depth()", "CV_16U", "CV_16S", "ddepth", "CV_32F", "CV_64F", "src.depth()", "CV_32F", "ddepth", "CV_32F", "CV_64F", "src.depth()", "CV_64F", "ddepth", "CV_64F", "ddepth=-1"], "type": ["int"], "isOutput": false}, "borderType": {"index": 6, "description": " \u2013 pixel extrapolation method (see  borderInterpolate() for details).", "title": "borderType", "required": false, "type": ["int"], "isOutput": false}, "delta": {"index": 5, "description": " \u2013 optional value added to the filtered pixels before storing them in dst.", "title": "delta", "required": false, "references": ["dst"], "type": ["double"], "isOutput": false}, "anchor": {"index": 4, "description": " \u2013 anchor of the kernel that indicates the relative position of a filtered point within the kernel; the anchor should lie within the kernel; default value (-1,-1) means that the anchor is at the kernel center.", "title": "anchor", "required": false, "type": ["Point"], "isOutput": false}}, "description": "Convolves an image with the kernel.", "title": "filter2d", "outputParamTypes": {"filter2D": ["void"]}, "optionalInput": ["dst", "anchor", "delta", "borderType"], "inputParamTypes": {"src": ["InputArray"], "kernel": ["InputArray"], "dst": ["OutputArray"], "ddepth": ["int"], "borderType": ["int"], "delta": ["double"], "anchor": ["Point"]}, "input": ["src", "ddepth", "kernel"], "invocation": ["cv2.filter2D"], "output": ["dst"]}, "borderinterpolate": {"functionParams": {"borderType": {"index": 2, "description": " \u2013 Border type, one of the  BORDER_* , except for  BORDER_TRANSPARENT  and  BORDER_ISOLATED . When  borderType==BORDER_CONSTANT , the function always returns -1, regardless of  p  and  len .", "title": "borderType", "required": true, "references": ["BORDER_*", "BORDER_TRANSPARENT", "BORDER_ISOLATED", "borderType==BORDER_CONSTANT", "p", "len"], "type": ["int"], "isOutput": false}, "p": {"index": 0, "description": " \u2013 0-based coordinate of the extrapolated pixel along one of the axes, likely &lt;0 or &gt;= len .", "title": "p", "required": true, "references": ["len"], "type": ["int"], "isOutput": false}, "len": {"index": 1, "description": " \u2013 Length of the array along the corresponding axis.", "title": "len", "required": true, "type": ["int"], "isOutput": false}}, "description": "Computes the source location of an extrapolated pixel.", "title": "borderinterpolate", "outputParamTypes": {"borderInterpolate": ["int"]}, "optionalInput": [""], "inputParamTypes": {"borderType": ["int"], "p": ["int"], "len": ["int"]}, "input": ["p", "len", "borderType"], "invocation": ["cv2.borderInterpolate"], "output": ["retval"]}, "dilate": {"functionParams": {"src": {"index": 0, "description": " \u2013 input image; the number of channels can be arbitrary, but the depth should be one of CV_8U, CV_16U, CV_16S,  CV_32F` or ``CV_64F.", "title": "src", "required": true, "references": ["CV_8U", "CV_16U", "CV_16S", "CV_32F`", "", "or", "", "``CV_64F"], "type": ["InputArray"], "isOutput": false}, "dst": {"index": 2, "description": " \u2013 output image of the same size and type as src.", "title": "dst", "required": false, "references": ["src"], "returnIndex": 0, "type": ["OutputArray"], "isOutput": true}, "element": {"references": ["element=Mat()", "3", "", "x", "", "3"], "description": " \u2013 structuring element used for dilation; if  element=Mat() , a  3 x 3 rectangular structuring element is used.", "title": "element"}, "borderType": {"index": 5, "description": " \u2013 pixel extrapolation method (see  borderInterpolate() for details).", "title": "borderType", "required": false, "type": ["int"], "isOutput": false}, "iterations": {"index": 4, "description": " \u2013 number of times dilation is applied.", "title": "iterations", "required": false, "type": ["int"], "isOutput": false}, "anchor": {"index": 3, "description": " \u2013 position of the anchor within the element; default value (-1, -1) means that the anchor is at the element center.", "title": "anchor", "required": false, "references": ["(-1,", "", "-1)"], "type": ["Point"], "isOutput": false}, "borderValue": {"index": 6, "required": false, "title": "borderValue", "description": " \u2013 border value in case of a constant border (see  createMorphologyFilter() for details).", "isOutput": false}}, "description": "Dilates an image by using a specific structuring element.", "title": "dilate", "outputParamTypes": {"dilate": ["void"]}, "optionalInput": ["dst", "anchor", "iterations", "borderType", "borderValue"], "inputParamTypes": {"src": ["InputArray"], "kernel": ["InputArray"], "dst": ["OutputArray"], "Scalar&": ["const"], "borderType": ["int"], "iterations": ["int"], "anchor": ["Point"]}, "input": ["src", "kernel"], "invocation": ["cv2.dilate"], "output": ["dst"]}, "pyrdown": {"functionParams": {"src": {"index": 0, "description": " \u2013 input image.", "title": "src", "required": true, "type": ["InputArray"], "isOutput": false}, "dst": {"index": 1, "description": " \u2013 output image; it has the specified size and the same type as src.", "title": "dst", "required": false, "references": ["src"], "returnIndex": 0, "type": ["OutputArray"], "isOutput": true}, "dstsize": {"index": 2, "description": " \u2013 size of the output image; by default, it is computed as Size((src.cols+1)/2, (src.rows+1)/2), but in any case, the following conditions should be satisfied:\n\n\n", "title": "dstsize", "required": false, "references": ["Size((src.cols+1)/2,", "", "(src.rows+1)/2)"], "isOutput": false}}, "description": "Blurs an image and downsamples it.", "title": "pyrdown", "outputParamTypes": {"pyrDown": ["void"]}, "optionalInput": ["dst", "dstsize", "borderType"], "inputParamTypes": {"borderType": ["int"], "src": ["InputArray"], "dst": ["OutputArray"], "Size&": ["const"]}, "input": ["src"], "invocation": ["cv2.pyrDown"], "output": ["dst"]}, "getderivkernels": {"functionParams": {"normalize": {"index": 5, "description": " \u2013 Flag indicating whether to normalize (scale down) the filter coefficients or not. Theoretically, the coefficients should have the denominator   . If you are going to filter floating-point images, you are likely to use the normalized kernels. But if you compute derivatives of an 8-bit image, store the results in a 16-bit image, and wish to preserve all the fractional bits, you may want to set  normalize=false .", "title": "normalize", "required": false, "references": ["normalize=false"], "type": ["bool"], "isOutput": false}, "ktype": {"index": 6, "description": " \u2013 Type of filter coefficients. It can be  CV_32f  or  CV_64F .", "title": "ktype", "required": false, "references": ["CV_32f", "CV_64F"], "type": ["int"], "isOutput": false}, "ksize": {"index": 2, "description": " \u2013 Aperture size. It can be  CV_SCHARR , 1, 3, 5, or 7.", "title": "ksize", "required": true, "references": ["CV_SCHARR"], "type": ["int"], "isOutput": false}, "dx": {"index": 0, "description": " \u2013 Derivative order in respect of x.", "title": "dx", "required": true, "type": ["int"], "isOutput": false}, "dy": {"index": 1, "description": " \u2013 Derivative order in respect of y.", "title": "dy", "required": true, "type": ["int"], "isOutput": false}, "ky": {"index": 4, "description": " \u2013 Output matrix of column filter coefficients. It has the type  ktype .", "title": "ky", "required": false, "references": ["ktype"], "returnIndex": 1, "type": ["OutputArray"], "isOutput": true}, "kx": {"index": 3, "description": " \u2013 Output matrix of row filter coefficients. It has the type  ktype .", "title": "kx", "required": false, "references": ["ktype"], "returnIndex": 0, "type": ["OutputArray"], "isOutput": true}}, "description": "Returns filter coefficients for computing spatial image derivatives.", "title": "getderivkernels", "outputParamTypes": {"getDerivKernels": ["void"]}, "optionalInput": ["kx", "ky", "normalize", "ktype"], "inputParamTypes": {"normalize": ["bool"], "ktype": ["int"], "ksize": ["int"], "dx": ["int"], "dy": ["int"], "ky": ["OutputArray"], "kx": ["OutputArray"]}, "input": ["dx", "dy", "ksize"], "invocation": ["cv2.getDerivKernels"], "output": ["kx", "ky"]}, "laplacian": {"functionParams": {"src": {"index": 0, "description": " \u2013 Source image.", "title": "src", "required": true, "type": ["InputArray"], "isOutput": false}, "scale": {"index": 4, "description": " \u2013 Optional scale factor for the computed Laplacian values. By default, no scaling is applied. See  getDerivKernels() for details.", "title": "scale", "required": false, "type": ["double"], "isOutput": false}, "dst": {"index": 2, "description": " \u2013 Destination image of the same size and the same number of channels as  src .", "title": "dst", "required": false, "references": ["src"], "returnIndex": 0, "type": ["OutputArray"], "isOutput": true}, "ddepth": {"index": 1, "description": " \u2013 Desired depth of the destination image.", "title": "ddepth", "required": true, "type": ["int"], "isOutput": false}, "borderType": {"index": 6, "description": " \u2013 Pixel extrapolation method. See  borderInterpolate() for details.", "title": "borderType", "required": false, "type": ["int"], "isOutput": false}, "ksize": {"index": 3, "description": " \u2013 Aperture size used to compute the second-derivative filters. See  getDerivKernels() for details. The size must be positive and odd.", "title": "ksize", "required": false, "type": ["int"], "isOutput": false}, "delta": {"index": 5, "description": " \u2013 Optional delta value that is added to the results prior to storing them in  dst .", "title": "delta", "required": false, "references": ["dst"], "type": ["double"], "isOutput": false}}, "description": "Calculates the Laplacian of an image.", "title": "laplacian", "outputParamTypes": {"Laplacian": ["void"]}, "optionalInput": ["dst", "ksize", "scale", "delta", "borderType"], "inputParamTypes": {"src": ["InputArray"], "scale": ["double"], "dst": ["OutputArray"], "ddepth": ["int"], "borderType": ["int"], "ksize": ["int"], "delta": ["double"]}, "input": ["src", "ddepth"], "invocation": ["cv2.Laplacian"], "output": ["dst"]}, "adaptivebilateralfilter": {"functionParams": {"src": {"index": 0, "description": " \u2013 The source image", "title": "src", "required": true, "type": ["InputArray"], "isOutput": false}, "sigmaSpace": {"index": 2, "description": " \u2013 Filter sigma in the coordinate space. Larger value of the parameter means that farther pixels will influence each other (as long as their colors are close enough; see sigmaColor). Then d&gt;0, it specifies the neighborhood size regardless of sigmaSpace, otherwise d is proportional to sigmaSpace.", "title": "sigmaSpace", "required": true, "type": ["double"], "isOutput": false}, "dst": {"index": 3, "description": " \u2013 The destination image; will have the same size and the same type as src", "title": "dst", "required": false, "returnIndex": 0, "type": ["OutputArray"], "isOutput": true}, "borderType": {"index": 5, "description": " \u2013 Pixel extrapolation method.", "title": "borderType", "required": false, "type": ["int"], "isOutput": false}, "ksize": {"index": 1, "description": " \u2013 The kernel size. This is the neighborhood where the local variance will be calculated, and where pixels will contribute (in a weighted manner).", "title": "ksize", "required": true, "type": ["Size"], "isOutput": false}, "maxSigmaColor": {"description": " \u2013 Maximum allowed sigma color (will clamp the value calculated in the ksize neighborhood. Larger value of the parameter means that more dissimilar pixels will influence each other (as long as their colors are close enough; see sigmaColor). Then d&gt;0, it specifies the neighborhood size regardless of sigmaSpace, otherwise d is proportional to sigmaSpace.", "title": "maxSigmaColor"}}, "description": "Applies the adaptive bilateral filter to an image.", "title": "adaptivebilateralfilter", "outputParamTypes": {"adaptiveBilateralFilter": ["void"]}, "optionalInput": ["dst", "anchor", "borderType"], "inputParamTypes": {"src": ["InputArray"], "sigmaSpace": ["double"], "dst": ["OutputArray"], "anchor": ["Point"], "borderType": ["int"], "ksize": ["Size"], "maxSigmaColor": ["double"]}, "input": ["src", "ksize", "sigmaSpace"], "invocation": ["cv2.adaptiveBilateralFilter"], "output": ["dst"]}, "blur": {"functionParams": {"borderType": {"index": 4, "description": " \u2013 border mode used to extrapolate pixels outside of the image.", "title": "borderType", "required": false, "type": ["int"], "isOutput": false}, "src": {"index": 0, "description": " \u2013 input image; it can have any number of channels, which are processed independently, but the depth should be CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.", "title": "src", "required": true, "references": ["CV_8U", "CV_16U", "CV_16S", "CV_32F", "CV_64F"], "type": ["InputArray"], "isOutput": false}, "dst": {"index": 2, "description": " \u2013 output image of the same size and type as src.", "title": "dst", "required": false, "references": ["src"], "returnIndex": 0, "type": ["OutputArray"], "isOutput": true}, "ksize": {"index": 1, "description": " \u2013 blurring kernel size.", "title": "ksize", "required": true, "type": ["Size"], "isOutput": false}, "anchor": {"index": 3, "description": " \u2013 anchor point; default value Point(-1,-1) means that the anchor is at the kernel center.", "title": "anchor", "required": false, "references": ["Point(-1,-1)"], "type": ["Point"], "isOutput": false}}, "description": "Blurs an image using the normalized box filter.", "title": "blur", "outputParamTypes": {"blur": ["void"]}, "optionalInput": ["dst", "anchor", "borderType"], "inputParamTypes": {"borderType": ["int"], "src": ["InputArray"], "dst": ["OutputArray"], "ksize": ["Size"], "anchor": ["Point"]}, "input": ["src", "ksize"], "invocation": ["cv2.blur"], "output": ["dst"]}, "pyrup": {"functionParams": {"src": {"index": 0, "description": " \u2013 input image.", "title": "src", "required": true, "type": ["InputArray"], "isOutput": false}, "dst": {"index": 1, "description": " \u2013 output image. It has the specified size and the same type as  src .", "title": "dst", "required": false, "references": ["src"], "returnIndex": 0, "type": ["OutputArray"], "isOutput": true}, "dstsize": {"index": 2, "description": " \u2013 size of the output image; by default, it is computed as Size(src.cols*2, (src.rows*2), but in any case, the following conditions should be satisfied:\n\n\n", "title": "dstsize", "required": false, "references": ["Size(src.cols*2,", "", "(src.rows*2)"], "isOutput": false}}, "description": "Upsamples an image and then blurs it.", "title": "pyrup", "outputParamTypes": {"pyrUp": ["void"]}, "optionalInput": ["dst", "dstsize", "borderType"], "inputParamTypes": {"borderType": ["int"], "src": ["InputArray"], "dst": ["OutputArray"], "Size&": ["const"]}, "input": ["src"], "invocation": ["cv2.pyrUp"], "output": ["dst"]}, "bilateralfilter": {"functionParams": {"src": {"index": 0, "description": " \u2013 Source 8-bit or floating-point, 1-channel or 3-channel image.", "title": "src", "required": true, "type": ["InputArray"], "isOutput": false}, "dst": {"index": 4, "description": " \u2013 Destination image of the same size and type as  src .", "title": "dst", "required": false, "references": ["src"], "returnIndex": 0, "type": ["OutputArray"], "isOutput": true}, "sigmaColor": {"index": 2, "description": " \u2013 Filter sigma in the color space. A larger value of the parameter means that farther colors within the pixel neighborhood (see  sigmaSpace ) will be mixed together, resulting in larger areas of semi-equal color.", "title": "sigmaColor", "required": true, "references": ["sigmaSpace"], "type": ["double"], "isOutput": false}, "d": {"index": 1, "description": " \u2013 Diameter of each pixel neighborhood that is used during filtering. If it is non-positive, it is computed from  sigmaSpace .", "title": "d", "required": true, "references": ["sigmaSpace"], "type": ["int"], "isOutput": false}, "sigmaSpace": {"index": 3, "description": " \u2013 Filter sigma in the coordinate space. A larger value of the parameter means that farther pixels will influence each other as long as their colors are close enough (see  sigmaColor ). When  d&gt;0 , it specifies the neighborhood size regardless of  sigmaSpace . Otherwise,  d  is proportional to  sigmaSpace .", "title": "sigmaSpace", "required": true, "references": ["sigmaColor", "d&gt;0", "sigmaSpace", "d", "sigmaSpace"], "type": ["double"], "isOutput": false}}, "description": "Applies the bilateral filter to an image.", "title": "bilateralfilter", "outputParamTypes": {"bilateralFilter": ["void"]}, "optionalInput": ["dst", "borderType"], "inputParamTypes": {"src": ["InputArray"], "sigmaColor": ["double"], "d": ["int"], "sigmaSpace": ["double"], "dst": ["OutputArray"], "borderType": ["int"]}, "input": ["src", "d", "sigmaColor", "sigmaSpace"], "invocation": ["cv2.bilateralFilter"], "output": ["dst"]}, "erode": {"functionParams": {"src": {"index": 0, "description": " \u2013 input image; the number of channels can be arbitrary, but the depth should be one of CV_8U, CV_16U, CV_16S,  CV_32F` or ``CV_64F.", "title": "src", "required": true, "references": ["CV_8U", "CV_16U", "CV_16S", "CV_32F`", "", "or", "", "``CV_64F"], "type": ["InputArray"], "isOutput": false}, "dst": {"index": 2, "description": " \u2013 output image of the same size and type as src.", "title": "dst", "required": false, "references": ["src"], "returnIndex": 0, "type": ["OutputArray"], "isOutput": true}, "element": {"references": ["element=Mat()", "3", "", "x", "", "3"], "description": " \u2013 structuring element used for erosion; if  element=Mat() , a  3 x 3  rectangular structuring element is used.", "title": "element"}, "borderType": {"index": 5, "description": " \u2013 pixel extrapolation method (see  borderInterpolate() for details).", "title": "borderType", "required": false, "type": ["int"], "isOutput": false}, "iterations": {"index": 4, "description": " \u2013 number of times erosion is applied.", "title": "iterations", "required": false, "type": ["int"], "isOutput": false}, "anchor": {"index": 3, "description": " \u2013 position of the anchor within the element; default value  (-1, -1)  means that the anchor is at the element center.", "title": "anchor", "required": false, "references": ["(-1,", "", "-1)"], "type": ["Point"], "isOutput": false}, "borderValue": {"index": 6, "required": false, "title": "borderValue", "description": " \u2013 border value in case of a constant border (see createMorphologyFilter() for details).", "isOutput": false}}, "description": "Erodes an image by using a specific structuring element.", "title": "erode", "outputParamTypes": {"erode": ["void"]}, "optionalInput": ["dst", "anchor", "iterations", "borderType", "borderValue"], "inputParamTypes": {"src": ["InputArray"], "kernel": ["InputArray"], "dst": ["OutputArray"], "Scalar&": ["const"], "borderType": ["int"], "iterations": ["int"], "anchor": ["Point"]}, "input": ["src", "kernel"], "invocation": ["cv2.erode"], "output": ["dst"]}, "morphologyex": {"functionParams": {"src": {"index": 0, "description": " \u2013 Source image. The number of channels can be arbitrary. The depth should be one of CV_8U, CV_16U, CV_16S,  CV_32F` or ``CV_64F.", "title": "src", "required": true, "references": ["CV_8U", "CV_16U", "CV_16S", "CV_32F`", "", "or", "", "``CV_64F"], "type": ["InputArray"], "isOutput": false}, "dst": {"index": 3, "description": " \u2013 Destination image of the same size and type as  src .", "title": "dst", "required": false, "references": ["src"], "returnIndex": 0, "type": ["OutputArray"], "isOutput": true}, "element": {"description": " \u2013 Structuring element.", "title": "element"}, "borderType": {"index": 6, "description": " \u2013 Pixel extrapolation method. See  borderInterpolate() for details.", "title": "borderType", "required": false, "type": ["int"], "isOutput": false}, "iterations": {"index": 5, "description": " \u2013 Number of times erosion and dilation are applied.", "title": "iterations", "required": false, "type": ["int"], "isOutput": false}, "borderValue": {"index": 7, "required": false, "title": "borderValue", "description": " \u2013 Border value in case of a constant border. The default value has a special meaning. See  createMorphologyFilter() for details.", "isOutput": false}, "op": {"index": 1, "description": " \u2013 Type of a morphological operation that can be one of the following:\n\nMORPH_OPEN - an opening operation\nMORPH_CLOSE - a closing operation\nMORPH_GRADIENT - a morphological gradient\nMORPH_TOPHAT - \u201ctop hat\u201d\nMORPH_BLACKHAT - \u201cblack hat\u201d\n\n", "title": "op", "required": true, "type": ["int"], "isOutput": false}}, "description": "Performs advanced morphological transformations.", "title": "morphologyex", "outputParamTypes": {"morphologyEx": ["void"]}, "optionalInput": ["dst", "anchor", "iterations", "borderType", "borderValue"], "inputParamTypes": {"kernel": ["InputArray"], "src": ["InputArray"], "dst": ["OutputArray"], "Scalar&": ["const"], "borderType": ["int"], "iterations": ["int"], "anchor": ["Point"], "op": ["int"]}, "input": ["src", "op", "kernel"], "invocation": ["cv2.morphologyEx"], "output": ["dst"]}, "getstructuringelement": {"functionParams": {"rows": {"description": " \u2013 Height of the structuring element", "title": "rows"}, "cols": {"description": " \u2013 Width of the structuring element", "title": "cols"}, "shape": {"index": 0, "description": " \u2013 Element shape that could be one of the following:\n\nMORPH_RECT         - a rectangular structuring element:\n\n\nMORPH_ELLIPSE         - an elliptic structuring element, that is, a filled ellipse inscribed into the rectangle Rect(0, 0, esize.width, 0.esize.height)\nMORPH_CROSS         - a cross-shaped structuring element:\n\n\nCV_SHAPE_CUSTOM     - custom structuring element (OpenCV 1.x API)\n\n", "title": "shape", "required": true, "references": ["Rect(0,", "", "0,", "", "esize.width,", "", "0.esize.height)"], "type": ["int"], "isOutput": false}, "values": {"references": ["cols``*``rows", "shape=CV_SHAPE_CUSTOM"], "description": " \u2013 integer array of cols``*``rows elements that specifies the custom shape of the structuring element, when shape=CV_SHAPE_CUSTOM.", "title": "values"}, "ksize": {"index": 1, "description": " \u2013 Size of the structuring element.", "title": "ksize", "required": true, "type": ["Size"], "isOutput": false}, "anchor_x": {"description": " \u2013 x-coordinate of the anchor", "title": "anchor_x"}, "anchor_y": {"description": " \u2013 y-coordinate of the anchor", "title": "anchor_y"}, "anchor": {"index": 2, "description": " \u2013 Anchor position within the element. The default value    means that the anchor is at the center. Note that only the shape of a cross-shaped element depends on the anchor position. In other cases the anchor just regulates how much the result of the morphological operation is shifted.", "title": "anchor", "required": false, "type": ["Point"], "isOutput": false}}, "description": "Returns a structuring element of the specified size and shape for morphological operations.", "title": "getstructuringelement", "outputParamTypes": {"getStructuringElement": ["Mat"]}, "optionalInput": ["anchor"], "inputParamTypes": {"shape": ["int"], "ksize": ["Size"], "anchor": ["Point"]}, "input": ["shape", "ksize"], "invocation": ["cv2.getStructuringElement"], "output": ["retval"]}, "gaussianblur": {"functionParams": {"src": {"index": 0, "description": " \u2013 input image; the image can have any number of channels, which are processed independently, but the depth should be CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.", "title": "src", "required": true, "references": ["CV_8U", "CV_16U", "CV_16S", "CV_32F", "CV_64F"], "type": ["InputArray"], "isOutput": false}, "dst": {"index": 3, "description": " \u2013 output image of the same size and type as src.", "title": "dst", "required": false, "references": ["src"], "returnIndex": 0, "type": ["OutputArray"], "isOutput": true}, "borderType": {"index": 5, "description": " \u2013 pixel extrapolation method (see  borderInterpolate() for details).", "title": "borderType", "required": false, "type": ["int"], "isOutput": false}, "sigmaY": {"index": 4, "description": " \u2013 Gaussian kernel standard deviation in Y direction; if  sigmaY  is zero, it is set to be equal to  sigmaX, if both sigmas are zeros, they are computed from  ksize.width  and  ksize.height , respectively (see  getGaussianKernel() for details); to fully control the result regardless of possible future modifications of all this semantics, it is recommended to specify all of ksize, sigmaX, and sigmaY.", "title": "sigmaY", "required": false, "references": ["sigmaY", "sigmaX", "ksize.width", "ksize.height", "ksize", "sigmaX", "sigmaY"], "type": ["double"], "isOutput": false}, "ksize": {"index": 1, "description": " \u2013 Gaussian kernel size.  ksize.width  and  ksize.height  can differ but they both must be positive and odd. Or, they can be zero\u2019s and then they are computed from  sigma* .", "title": "ksize", "required": true, "references": ["ksize.width", "ksize.height", "sigma*"], "type": ["Size"], "isOutput": false}, "sigmaX": {"index": 2, "description": " \u2013 Gaussian kernel standard deviation in X direction.", "title": "sigmaX", "required": true, "type": ["double"], "isOutput": false}}, "description": "Blurs an image using a Gaussian filter.", "title": "gaussianblur", "outputParamTypes": {"GaussianBlur": ["void"]}, "optionalInput": ["dst", "sigmaY", "borderType"], "inputParamTypes": {"src": ["InputArray"], "dst": ["OutputArray"], "borderType": ["int"], "sigmaY": ["double"], "ksize": ["Size"], "sigmaX": ["double"]}, "input": ["src", "ksize", "sigmaX"], "invocation": ["cv2.GaussianBlur"], "output": ["dst"]}, "medianblur": {"functionParams": {"src": {"index": 0, "description": " \u2013 input 1-, 3-, or 4-channel image; when  ksize  is 3 or 5, the image depth should be CV_8U, CV_16U, or CV_32F, for larger aperture sizes, it can only be CV_8U.", "title": "src", "required": true, "references": ["ksize", "CV_8U", "CV_16U", "CV_32F", "CV_8U"], "type": ["InputArray"], "isOutput": false}, "dst": {"index": 2, "description": " \u2013 destination array of the same size and type as src.", "title": "dst", "required": false, "references": ["src"], "returnIndex": 0, "type": ["OutputArray"], "isOutput": true}, "ksize": {"index": 1, "description": " \u2013 aperture linear size; it must be odd and greater than 1, for example: 3, 5, 7 ...", "title": "ksize", "required": true, "type": ["int"], "isOutput": false}}, "description": "Blurs an image using the median filter.", "title": "medianblur", "outputParamTypes": {"medianBlur": ["void"]}, "optionalInput": ["dst"], "inputParamTypes": {"src": ["InputArray"], "dst": ["OutputArray"], "ksize": ["int"]}, "input": ["src", "ksize"], "invocation": ["cv2.medianBlur"], "output": ["dst"]}, "boxfilter": {"functionParams": {"normalize": {"index": 5, "description": " \u2013 flag, specifying whether the kernel is normalized by its area or not.", "title": "normalize", "required": false, "type": ["bool"], "isOutput": false}, "src": {"index": 0, "description": " \u2013 input image.", "title": "src", "required": true, "type": ["InputArray"], "isOutput": false}, "dst": {"index": 3, "description": " \u2013 output image of the same size and type as src.", "title": "dst", "required": false, "references": ["src"], "returnIndex": 0, "type": ["OutputArray"], "isOutput": true}, "ddepth": {"index": 1, "description": " \u2013 the output image depth (-1 to use src.depth()).", "title": "ddepth", "required": true, "references": ["src.depth()"], "type": ["int"], "isOutput": false}, "borderType": {"index": 6, "description": " \u2013 border mode used to extrapolate pixels outside of the image.", "title": "borderType", "required": false, "type": ["int"], "isOutput": false}, "ksize": {"index": 2, "description": " \u2013 blurring kernel size.", "title": "ksize", "required": true, "type": ["Size"], "isOutput": false}, "anchor": {"index": 4, "description": " \u2013 anchor point; default value Point(-1,-1) means that the anchor is at the kernel center.", "title": "anchor", "required": false, "references": ["Point(-1,-1)"], "type": ["Point"], "isOutput": false}}, "description": "Blurs an image using the box filter.", "title": "boxfilter", "outputParamTypes": {"boxFilter": ["void"]}, "optionalInput": ["dst", "anchor", "normalize", "borderType"], "inputParamTypes": {"normalize": ["bool"], "src": ["InputArray"], "dst": ["OutputArray"], "ddepth": ["int"], "borderType": ["int"], "ksize": ["Size"], "anchor": ["Point"]}, "input": ["src", "ddepth", "ksize"], "invocation": ["cv2.boxFilter"], "output": ["dst"]}, "scharr": {"functionParams": {"src": {"index": 0, "description": " \u2013 input image.", "title": "src", "required": true, "type": ["InputArray"], "isOutput": false}, "scale": {"index": 5, "description": " \u2013 optional scale factor for the computed derivative values; by default, no scaling is applied (see  getDerivKernels() for details).", "title": "scale", "required": false, "type": ["double"], "isOutput": false}, "dst": {"index": 4, "description": " \u2013 output image of the same size and the same number of channels as src.", "title": "dst", "required": false, "references": ["src"], "returnIndex": 0, "type": ["OutputArray"], "isOutput": true}, "delta": {"index": 6, "description": " \u2013 optional delta value that is added to the results prior to storing them in dst.", "title": "delta", "required": false, "references": ["dst"], "type": ["double"], "isOutput": false}, "ddepth": {"index": 1, "description": " \u2013 output image depth (see Sobel() for the list of supported combination of src.depth() and ddepth).", "title": "ddepth", "required": true, "references": ["src.depth()", "ddepth"], "type": ["int"], "isOutput": false}, "borderType": {"index": 7, "description": " \u2013 pixel extrapolation method (see  borderInterpolate() for details).", "title": "borderType", "required": false, "type": ["int"], "isOutput": false}, "dx": {"index": 2, "description": " \u2013 order of the derivative x.", "title": "dx", "required": true, "type": ["int"], "isOutput": false}, "dy": {"index": 3, "description": " \u2013 order of the derivative y.", "title": "dy", "required": true, "type": ["int"], "isOutput": false}}, "description": "Calculates the first x- or y- image derivative using Scharr operator.", "title": "scharr", "outputParamTypes": {"Scharr": ["void"]}, "optionalInput": ["dst", "scale", "delta", "borderType"], "inputParamTypes": {"src": ["InputArray"], "scale": ["double"], "dst": ["OutputArray"], "delta": ["double"], "ddepth": ["int"], "borderType": ["int"], "dx": ["int"], "dy": ["int"]}, "input": ["src", "ddepth", "dx", "dy"], "invocation": ["cv2.Scharr"], "output": ["dst"]}, "pyrmeanshiftfiltering": {"functionParams": {"src": {"index": 0, "description": " \u2013 The source 8-bit, 3-channel image.", "title": "src", "required": true, "type": ["InputArray"], "isOutput": false}, "termcrit": {"index": 5, "description": " \u2013 Termination criteria: when to stop meanshift iterations.", "title": "termcrit", "required": false, "type": ["TermCriteria"], "isOutput": false}, "sr": {"index": 2, "description": " \u2013 The color window radius.", "title": "sr", "required": true, "type": ["double"], "isOutput": false}, "dst": {"index": 3, "description": " \u2013 The destination image of the same format and the same size as the source.", "title": "dst", "required": false, "returnIndex": 0, "type": ["OutputArray"], "isOutput": true}, "sp": {"index": 1, "description": " \u2013 The spatial window radius.", "title": "sp", "required": true, "type": ["double"], "isOutput": false}, "maxLevel": {"index": 4, "description": " \u2013 Maximum level of the pyramid for the segmentation.", "title": "maxLevel", "required": false, "type": ["int"], "isOutput": false}}, "description": "Performs initial step of meanshift segmentation of an image.", "title": "pyrmeanshiftfiltering", "outputParamTypes": {"pyrMeanShiftFiltering": ["void"]}, "optionalInput": ["dst", "maxLevel", "termcrit"], "inputParamTypes": {"src": ["InputArray"], "termcrit": ["TermCriteria"], "sr": ["double"], "dst": ["OutputArray"], "sp": ["double"], "maxLevel": ["int"]}, "input": ["src", "sp", "sr"], "invocation": ["cv2.pyrMeanShiftFiltering"], "output": ["dst"]}}, "title": "Image Filtering"}}, "title": "test"}
],