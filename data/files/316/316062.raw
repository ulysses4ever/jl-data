@doc """
**Description:**

Position nodes uniformly at random in the unit square.
For every node, a position is generated by choosing each of dim
coordinates uniformly at random on the interval [0.0, 1.0).

**Parameters:**

*G:*
graph or list of nodes,
A position will be assigned to every node in G

**Return:**

*locs_x, locs_y:*
Locations of the nodes. Can be any units you want,
but will be normalized and centered anyway

**Examples:**

    julia> g = simple_house_graph()

    julia> loc_x, loc_y = random_layout(g)

""" ->
function random_layout{V}(G::AbstractGraph{V})
    rand(num_vertices(G)), rand(num_vertices(G))
end

@doc """
**Description:**

Position nodes on a circle.

**Parameters:**

*G:*
graph or list of nodes

**Returns:**

*locs_x, locs_y:*
Locations of the nodes. Can be any units you want,
but will be normalized and centered anyway

**Examples:**

    julia> g = simple_house_graph()
    julia> locs_x, locs_y = circular_layout(g)

**Notes:**

This algorithm currently only works in two dimensions and
does not try to minimize edge crossings.
""" ->
function circular_layout{V}(G::AbstractGraph{V})
    if num_vertices(G) == 1
        return 0.0, 0.0
    else
        # Discard the extra angle since it matches 0 radians.
    θ = linspace(0, 2pi, num_vertices(G) + 1)[1:end-1]
        return cos(θ), sin(θ)
    end
end
