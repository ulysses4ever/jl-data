using Mass
fname1 = "/Volumes/Drobo/exafs_data/20140719_ferrioxalate_pump_probe/20140719_ferrioxalate_pump_probe_chan1.ljh"
fname2 = "/Volumes/Drobo/exafs_data/20140720_ferrioxalate_pump_probe/20140720_ferrioxalate_pump_probe_chan1.ljh"
ljhgroup1=microcal_open([fname1, fname2])
ljhgroup1.ljhfiles[end-1].nrec = div(ljhgroup1.ljhfiles[end-1].nrec,2)
ljhgroup2 = Mass.MicrocalFiles.LJHGroup(ljhgroup1.ljhfiles)

h5 = jldopen(hdf5_name_from_ljh(ljhgroup2),"w")
close(h5)
h5 = jldopen(hdf5_name_from_ljh(ljhgroup2),"r+")

function ptm_correction(r, params, ptm, ph)
    ptm_offset, slope = params
    ph += (ptm.-ptm_offset).*ph
    return (ph,)
end
ptm_correction_step = Step(ptm_correction, "pretrigger_mean_correction", ["pretrig_mean","pulse_rms"], (), "pulse_rms_dc")

type Calibration
	features::Vector{ASCIIString}
	energies::Vector{Float64}
	estimates::Vector{Float64}
end

function calibrate(r, pulse_rms, cuts)
	println("Calibration!!!!**!!")
	good = !reinterpret(Bool, cuts)
	println(length(good))
	println(sum(good))
	println(length(pulse_rms[good]))
	(Calibration(["Zero","MnKAlpha"], [0, 5898], [0,median(pulse_rms[good])]),)
end
calibrate_step = Step(calibrate, [], ["pulse_rms","cuts"], "calibration/pulse_rms", [])

function cuts(r, lims1, lims2, vec1, vec2)
	out = Bool[lims1[1]<v<lims1[2] for v in vec1] & Bool[lims2[1]<v<lims2[2] for v in vec2]
	out = reinterpret(Int8, !out)
	return (out,)
end
cut_step = Step(cuts, ["pretrig_rms_lims", "postpeak_deriv_lims"],["pretrig_rms","postpeak_deriv"],[],"cuts")

function apply(r, cal::Calibration, pulse_rms)
	energy = pulse_rms.*(cal.energies[end]/cal.estimates[end])
	return (energy,)
end
apply_calibration_step = Step(apply, "calibration/pulse_rms", "pulse_rms", [], "energy")

g = init_channel(h5, ljhgroup2)
g["pretrigger_mean_correction"] = [2000.0, 0.1] # imagine this is generated by another step that runs only once
g["pretrig_rms_lims"] = [0,50]
g["postpeak_deriv_lims"] = [typemin(Int),1]
h5step_add(g, summarize_step)
h5step_add(g, ptm_correction_step)
h5step_add(g, cut_step)
h5step_add(g, Mass.H5Flow.ThresholdStep("pulse_rms", 400000, calibrate_step))
h5step_add(g, apply_calibration_step)
for j=1:5 update!(g,300000) end

getgood(g) = !reinterpret(Bool, g["cuts"][:])
using PyPlot
function histenergy(g)
	energy = g["energy"][:][getgood(g)]
	plt.hist(energy, [0:2:10000])
	xlabel("energy (eV)")
	ylabel("counts per 2 eV bin")
	title(name(g))
end
histenergy(g)

# pythonattrs = ["npulses", "mass_version", "timebase", "channel", "git_state", "julia_version","pulsefiles_names","pulsefile_lengths"]
# Mass.H5Flow.pythonize(g,pythonattrs,pythonattrs)