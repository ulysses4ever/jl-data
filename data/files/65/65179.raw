import Base: +, size, factor, slice
export FrontalMatrix, UpdateMatrix, factor, slice


immutable FrontalMatrix{T, S<:Integer} <: DenseArray{T,2}
    data::Matrix{T}     # dense matrix data
    rowval::Vector{S}   # row indices
end
function FrontalMatrix{T, S}(data::Matrix{T}, rowval::Vector{S})
    m, n = size(data)
    m == n || throw(DimensionMismatch(""))
    FrontalMatrix(data, rowval)
end
size(F::FrontalMatrix) = size(F.data)

# one step of Cholesky factorization
function factor{T}(F::FrontalMatrix{T})
    A = F.data
    n, = size(A)
    l = zeros(T,n)
    U = zeros(T, n-1, n-1)
    [l[i] = A[i,1]/sqrt(A[1,1]) for i = 1:n]
    for j = 2:n
        for i = 2:n
            U[i-1,j-1] = A[i,j] - A[1,j]*A[1,i]/A[1,1]
        end
    end    
    return l, UpdateMatrix(U, F.rowval[2:end])
end


immutable UpdateMatrix{T, S<:Integer} <: DenseArray{T,2}
    data::Matrix{T}
    rowval::Vector{S}
end
size(U::UpdateMatrix) = size(U.data)

# extended add
function +{T}(U1::UpdateMatrix{T}, U2::UpdateMatrix{T})
    rowval = sort(union(U1.rowval, U2.rowval))
    A = zeros(T, length(rowval), length(rowval))
    u1in = findin(rowval, U1.rowval)
    u2in = findin(rowval, U2.rowval)
    A[u1in,u1in] = U1.data
    A[u2in,u2in] = A[u2in,u2in] + U2.data
    UpdateMatrix(A, rowval)
end

# convert an update matrix to a frontal matrix
FrontalMatrix(U::UpdateMatrix) = FrontalMatrix(U.data, U.rowval)

"
Slice an update matrix according to the row indices `rowval`.
Only return the dense matrix that corresponding to
the intersection of `rowval` and `U.rowval`.
"
function slice(U::UpdateMatrix, rowval::Vector)
    new_rowval = intersect(U.rowval, rowval)
    uin = findin(U.rowval, new_rowval)
    UpdateMatrix(U.data[uin,uin], new_rowval)
end
