using DataStructures: Stack, pop!, push!

export cholesky

"""
Compute the Cholesky factorization of a given sparse symmetric
positive definite matrix `A`.
"""
function cholesky{T<:Real, S}(A::SparseMatrixCSC{T, S})
    m = A.m
    n = A.n
    m == n || throw(DimensionMismatch(""))
    g = sp2tree(A)                     # elimination tree
    uDict = Dict{Int, UpdateMatrix}()  # dictionary of update matrices
    colptr, rowval = struct_L(A)
    L_nzval = T[]                # nzval  for L
    L_rowval = S[]               # rowval for L
    L_colptr = S[1]              # colptr for L
    for j = 1:n 
        locs =  rowval[colptr[j]:colptr[j+1]-1]
        m = length(locs)
        #println("L row locs: ", locs)
        Aj = zeros(T, m, m)       # part of the frontal matrix
        for (i, k) in enumerate(locs) 
            Aj[i,1] = A[k,j]
            if i > 1; Aj[1,i] = Aj[i,1] end  
        end
        U = UpdateMatrix(Aj, locs)
        
        for child in out_neighbors(j, g)
            # form the update matrix
            try
                U = U + slice(uDict[child],locs)
                println("Update Matrix at $(child):")
                display(U.data)
             #   println("Eliminating node $(child) ...")
            catch
                println("Stack of update matrices is empty ...")
            end
        end
        # form the frontal matrix
        F = FrontalMatrix(U)
        # factorize F
        l, U = factor(F)
        uDict[j] = U
       
#        println("indices: ", U.rowval)
        append!(L_nzval, l)
        append!(L_rowval, locs)
        push!(L_colptr, L_colptr[end]+length(l))
    end
    SparseMatrixCSC(n, n, L_colptr, L_rowval, L_nzval)
end
