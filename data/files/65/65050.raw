using DataStructures: Stack, pop!, push!
export cholesky, pcholesky, SparseCholesky

immutable SparseCholesky{S<:SparseMatrixCSC}
    factors::S               # factor matrix 
    perm::Vector{Int} # permutation vector
    tree::Vector{Int}   # elimination tree
    factors_computed::Bool    # whether factors have been computed
end

"""
  `L = cholesky(A)`

Compute the Cholesky factorization of a given sparse symmetric
positive definite matrix `A`.
"""
function cholesky{T<:Real, S}(A::SparseMatrixCSC{T, S})
    m = A.m
    n = A.n
    m == n || throw(DimensionMismatch(""))
    g = sp2tree(A)                     # elimination tree
    uDict = Dict{Int, UpdateMatrix}()  # dictionary of update matrices
    colptr, rowval = struct_L(A)
    L_nzval = T[]                # nzval  for L
    L_rowval = S[]               # rowval for L
    L_colptr = S[1]              # colptr for L
    for j = 1:n
        children = out_neighbors(j,g)
        locs = rowval[colptr[j]:colptr[j+1]-1]
   
        U = UpdateMatrix(T, locs)
        for child in out_neighbors(j, g)
            # form the update matrix
            U = U + uDict[child]
        end
        F = FrontalMatrix(A, locs, j)
        
        add!(F, slice(U, locs))
        # factorize F
        l, newU = factor(F)
        uDict[j] = newU
       
        append!(L_nzval, l)
        append!(L_rowval, locs)
        push!(L_colptr, L_colptr[end]+length(l))
    end
    SparseMatrixCSC(n, n, L_colptr, L_rowval, L_nzval)
end

function pcholesky{T<:Real, S}(A::SparseMatrixCSC{T, S})
    m = A.m
    n = A.n
    m == n || throw(DimensionMismatch(""))
    g = sp2tree(A)           # elimination tree
    uDict = Dict{Int, RemoteRef}()  # a list of references of  update matrices
    colptr, rowval = struct_L(A)
    L_nzval = T[]                # nzval  for L
    L_rowval = S[]               # rowval for L
    L_colptr = S[1]              # colptr for L
    for j = 1:n
        children = out_neighbors(j, g)

        locs = @spawn rowval[colptr[j]:colptr[j+1]-1]
        #println("L row locs: ", locs)
#        F = @spawnat locs.where FrontalMatrix(A, fetch(locs), j)
        Aj = zeros(T, m, m)       # part of the frontal matrix
        for (i, k) in enumerate(fetch(locs)) 
            Aj[i,1] = A[k,j]
            if i > 1; Aj[1,i] = Aj[i,1] end
        end

        F = @spawn FrontalMatrix(Aj, fetch(locs)) 

        println("Fontal $(j) at processor $(F.where)")
        #display(fetch(F))
        for child in children
            # form the update matrix
           # try
           # display(uDict[child])
            println("uDict[$(child)] at $(uDict[child].where)")
            add!(F, slice(uDict[child],locs))
           # catch
           #     println("Stack of update matrices is empty ...")
           # end
        end
        # factorize F
        facs = factor(F)
        l, = fetch(facs)
        uDict[j] = facs
        
        #println("indices: ", U.rowval)
        append!(L_nzval, l)
        append!(L_rowval, fetch(locs))
        push!(L_colptr, L_colptr[end]+length(l))
    end
    SparseMatrixCSC(n, n, L_colptr, L_rowval, L_nzval)
end
