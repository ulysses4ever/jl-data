immutable SparseCholesky{S<:SparseMatrixCSC}
    factors::S               # factor matrix 
    perm::Vector{Int} # permutation vector
    tree::Vector{Int}   # elimination tree
    factors_computed::Bool    # whether factors have been computed
end

"""
  `L = cholesky(A)`

Compute the Cholesky factorization of a given sparse symmetric
positive definite matrix `A`.
"""
function cholesky{T<:Real, S}(A::SparseMatrixCSC{T, S})
    m = A.m
    n = A.n
    m == n || throw(DimensionMismatch(""))
    g = sp2tree(A)                                 # elimination tree
    uDict = Dict{Int, UpdateMatrix}()  # dictionary of update matrices
    colptr, rowval = struct_L(A)
    L_nzval = T[]                  # nzval  for L
    L_rowval = S[]                # rowval for L
    L_colptr = S[1]                # colptr for L
    for j = 1:n
        children = out_neighbors(j,g)
        locs = rowval[colptr[j]:colptr[j+1]-1]

        F = FrontalMatrix(A, locs, j)
        if length(children) != 0
            U = UpdateMatrix(T, locs)
            for child in children
                # form the update matrix
                U = U + uDict[child]
            end
            add!(F, slice(U, locs))
        end
        
        # factorize F
        l, newU = factor(F)
        uDict[j] = newU
       
        append!(L_nzval, l)
        append!(L_rowval, locs)
        push!(L_colptr, L_colptr[end]+length(l))
    end
    SparseMatrixCSC(n, n, L_colptr, L_rowval, L_nzval)
end

function cholesky{T<:Real, S}(A::SharedSparseMatrixCSC{T, S})
    m = A.m
    n = A.n
    m == n || throw(DimensionMismatch(""))
    g = sp2tree(A)                                 # elimination tree
    uDict = Dict{Int, RemoteRef}()  # dictionary of update matrices
    colptr, rowval = struct_L(A)
    L_nzval = T[]                  # nzval  for L
    L_rowval = S[]                # rowval for L
    L_colptr = S[1]                # colptr for L
    for j = 1:n
        children = out_neighbors(j,g)
        locs = rowval[colptr[j]:colptr[j+1]-1]

        if length(children) != 0
            U = @spawn UpdateMatrix(T, locs)
            for child in children
                # form the update matrix
                U = U + uDict[child]
            end
            F = @spawnat U.where FrontalMatrix(A, locs, j)
            add!(F, slice(U, locs))
        else
            F = @spawn FrontalMatrix(A, locs, j)
        end
        #display(fetch(F))  # factorize F
        lU = @spawnat F.where factor(F)
        uDict[j] = lU
        l = fetch(lU)[1]         
        append!(L_nzval, l)
        append!(L_rowval, locs)
        push!(L_colptr, L_colptr[end]+length(l))
    end
    SparseMatrixCSC(n, n, L_colptr, L_rowval, L_nzval)
end
