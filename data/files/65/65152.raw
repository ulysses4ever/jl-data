using Graphs: simple_adjlist, add_edge!, out_neighbors, plot
using DataStructures: IntDisjointSets, find_root, root_union!

export sp2adj, sp2tree, struct_L, plot, elimination_tree

"convert a sparse matrix A to an adjacency graph G(A)"
function sp2adj(A::SparseMatrixCSC)
    n = A.n
    g = simple_adjlist(n, is_directed = false)
    for j = 1:n
        for k = A.colptr[j]:A.colptr[j+1]-1
            i = A.rowval[k]
            if i > j
                add_edge!(g,i,j)
            end
        end
    end
    g                   
end

"convert a sparse matrix A to an elimination tree T(A)"
function sp2tree(A::SparseMatrixCSC)
    n = A.n
    parent = elimination_tree(A)
    g = simple_adjlist(n)
    for j = 1:n
        if parent[j] != 0
            add_edge!(g, parent[j], j)
        end
    end
    g
end

"""
given a SPD matrix such that `A = LL'` 
reture the structure of L as rowval and colptr. 
"""
function struct_L(A::SparseMatrixCSC)
    # currently use full matrix
    L = chol(full(A))'
    return sparse(L).colptr, sparse(L).rowval
end


"""
`elimination_tree(A)`

generates an elimination tree of the given sparse matrix `A`.

References: 
Joseph W. H. Liu, *The Role of Elimination Trees in Sparse Factorization*, 
Society for Industrial and Applied Mathematics, J. Matrix Anal. Appl. 
Vol. 11, No. 1. pp. 134-172, Jan 1990.  
"""
function elimination_tree(A::SparseMatrixCSC)
    n = A.n
    a = IntDisjointSets(n)
    real_root = Array(Int, n)
    parent = Array(Int, n)
    for i = 1:n
        @inbounds real_root[i] = i
        @inbounds parent[i] = zero(Int)
        vroot  = i
        for k = 1:i-1
            if A[i,k] != 0.0
                u = find_root(a, k)
                @inbounds t = real_root[u]
                if (parent[t] == zero(Int)) && t != i
                    @inbounds parent[t] = i
                    vroot = root_union!(a, vroot, u)
                    @inbounds real_root[vroot] = i
                end
            end
        end
    end
    parent
end

# suppose the structure of L is known.
function _etree(L::SparseMatrixCSC)
    n, = size(L)
    parent = Array(Int, n)
    for i = 1:n
        parent[i] = zero(Int)
        for k = 1:i-1
            if L[i,k] != 0.0
                if parent[k] == zero(Int); parent[k] = Int(i) end
            end
        end
    end
    return parent
end
