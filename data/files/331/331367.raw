###################################################
## Run simulation
###################################################

"""
Takes a Data object as an argument, and runs a simulation of dynamic matching where
the matching policy and other parameters are defined a Params element.
The length of the simulation is specified by the steps parameters

Returns a DataFrame object with the statistics of the simulation run.
"""
function run_dynamic(d::Data, steps::Int64, brain::Brain, parameters::Params;
        pool::InstanceGraph = InstanceGraph())
  println("Running with steps = $steps, batch = $(p.batchSize), techno = $(p.techno),
          priorities= $(p.priorities)")

  tic()
  time_tot = []
  for k in 1:steps
    #prev_state_exp = [n.node_type.id for n in pool.present_nodes]
    time_tot_tic = time()
    arriving_node_id = rand(1:d.n)
    arrival!(pool, arriving_node_id, d, k)
    if k%p.batchSize == 0
      time_tic = time()
      matched_nodes, value, solve_time = match(pool, parameters, brain)
      if length(matched_nodes) > 0
        remove_matched!(pool, matched_nodes, k)
      end
      update_weights(brain, float(value), pool.nodes)
    end
    departures!(pool, k)
    push!(time_tot, time() - time_tot_tic)
    if k%(steps/20) == 0
      print_status(pool, k, parameters)
      println("lp time: $(round(mean(time_tot),3)), pool size: $(pool.n)")
    end
  end
  toc()
  #return pool_summary(pool, steps, parameters)
end

function print_status(pool::InstanceGraph, k::Int64, p::Params)
  if p.verbose > 0
    println("It: $k, pool size: $(pool.n_present)")
  end
end

"""
Computes a summary of the simulation. Inputs a pool with all arrivals and departures,
Outputs a dataFrame with the pool summary.
"""
function pool_summary(pool::InstanceGraph, steps::Int64, p::Params)
  n_types = length(pool.nodes)
  summary = DataFrame(n_arr = zeros(Int64, n_types),
                      n_match = zeros(Int64, n_types),
                      n_dep = zeros(Int64, n_types),
                      n_inpool = zeros(Int64, n_types),
                      wait_match = zeros(Float64, n_types),
                      wait_dep = zeros(Float64, n_types),
                      )
  for n in pool.nodes
    if n.arr_time >= steps/5
      id = n.node_type.id
      summary[id, :n_arr] += 1
      if n.dep_time == -1
        wait = steps - n.arr_time
      elseif n.dep_time - n.arr_time >= 0
        wait = n.dep_time - n.arr_time
      else
        println("Error, departure before arrival: dep= $(n.dep_time), arr= $(n.arr_time)")
      end
      if n.matched
        summary[id, :n_match] += 1
        summary[id, :wait_match] += wait
      elseif n.departed
        summary[id, :n_dep] += 1
        summary[id, :wait_dep] += wait
      else
        summary[id, :n_inpool] += 1
      end
    end
  end
  return summary
end
