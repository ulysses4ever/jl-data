###################################################
## Find maximum matching in the graph
###################################################

function init_model(p::Params)
  if p.solver == "gurobi"
    m = Model(solver=GurobiSolver(OutputFlag = 0))
  elseif p.solver == "mosek"
    m = Model(solver=MosekSolver(LOG = 0))
  else
    println("Solver not supported")
  end
  return m
end

function match(edges::Edges, am::Array{Int64, 2}, p::Params; verbose::Int64 = 0)
  time_tic = time()
  m = init_model(p)
  n = edges.n_nodes
  @variable(m, 1 >= y[1:n] >= 0, Int)
  @variable(m, 1 >= x[edges.list] >= 0, Int)

  @objective(m, Max, sum(y[j] for j in 1:n))
  @constraint(m, c2[k=1:n], sum(x[(i,k)] for i=edges.ingoing[k]) == y[k])
  @constraint(m, c1[k=1:n], sum(x[(k,j)] for j=edges.outgoing[k]) == y[k])
  if p.techno == "23_cycles"
    two_three_cycles_constraint(m, n,am, edges, x , y)
  elseif p.techno == "2_cycles"
    two_cycles_constraint(m, n,am, edges, x, y)
  else
    println("techno not implemented")
  end
  time_jump = time() - time_tic
  status = solve(m)
  match_edges = getvalue(x)
  match_vertices = getvalue(y)
  solve_time = getsolvetime(m)

  return  (find(match_vertices .>= 1e-6), solve_time, time_jump)
end

function two_three_cycles_constraint(m, n,am, edges, x, y)
  @constraint(m, c4[i=1:n, j=edges.outgoing[i],
      k=intersect(edges.outgoing[j],(edges.ingoing[i]))],
      x[(k,i)] >= x[(i,j)] + x[(j,k)] - 1)
  @constraint(m, c5[i=1:n, j=edges.outgoing[i],
      k=setdiff(edges.outgoing[j],[i])],
      am[k,i] >= x[(i,j)] + x[(j,k)] - 1)
end

function two_cycles_constraint(m, n,am, edges, x, y)
  @constraint(m, c4[i=1:n, j=intersect(edges.outgoing[i], edges.ingoing[i])],
      x[(i,j)] == x[(j,i)])
  @constraint(m, c5[i=1:n, j=edges.outgoing[i]], x[(i,j)] <= am[j,i])
  @constraint(m, c6[i=1:n, j=edges.ingoing[i]], x[(j,i)] <= am[i,j])
end
