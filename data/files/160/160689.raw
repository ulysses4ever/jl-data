function binomial_pmf(p::Array, k::Int, o::Int)
    # binomial distribution for 'o' occurences in 'k' trials with probability 'p'
    return binomial(k,o) .* p[1].^o .* (1-p[1]).^(k-o)
end

function betabinomial_pmf(params::Array, k::Int, o::Int)
    # beta-binomial distribution for 'o' occurences in 'k' trials with params 'a' and 'b'
    a = params[1]
    b = params[2]
    return binomial(k,o) * beta(o+a,k-o+b) / beta(a,b)
end

function sample(p)
    # Sample from categorical distribution with probability vector p
    v = rand()
    s = 0.0
    for i = 1:length(p)
        s += p[i]
        if v <= s
            return i
        end
    end
    return length(p)
end

function betabinomal_log_pmf(a::Float64, b::Float64, k::Int, o::Int)
    # log-likelihood for 'o' occurences in 'k' trials with params 'a' and 'b'
    return (lgamma(k+1) + lgamma(o+a) + lgamma(k-o+b) + lgamma(a+b))
    - (lgamma(o+1) + lgamma(k-o+1) + lgamma(k+a+b) + lgamma(a) + lgamma(b))
end

function betabinomal_ll_gradient(a::Float64, b::Float64, k::Int, o::Int)
    # gradient of betabinomial log-likelihood function (see above)
    Da = digamma(o+a) + digamma(a+b) - digamma(k+a+b) - digamma(a)
    Db = digamma(k-o+b) + digamma(a+b) - digamma(k+a+b) - digamma(b)
    return [Da,Db]
end

function betabinomial_ll_hessian(a::Float64, b::Float64, k::Int, o::Int)
    # hessian of betabinomial log-likelihood function (see above)
    Daa = trigamma(o+a) + trigamma(a+b) - trigamma(k+a+b) - trigamma(a)
    Dbb = trigamma(k-o+b) + trigamma(a+b) - trigamma(k+a+b) - trigamma(b)
    Dab = trigamma(a+b) - trigamma(k+a+b)
    return [Daa Dab; Dab Dbb]
end

# function betabinomial_ll_hessian_fast(a::Float64, b::Float64, k::Int, o::Int)
#     # hessian of betabinomial log-likelihood function (see above)
#     Dab = trigamma(a+b) - trigamma(k+a+b)
#     Daa = trigamma(o+a)  - trigamma(a) + Dab
#     Dbb = trigamma(k-o+b) - trigamma(b) + Dab
#     return [Daa Dab; Dab Dbb]
# end

function create_bb_objective_func(k::Vector{Int}, o::Vector{Int}, weights::Vector{Float64})
    function f(x::Vector)
        # x[1] is alpha, x[2] is beta
        wll = 0.0 # weighted log-likelihood
        for i = 1:length(k)
            wll += weights[i] * ( lgamma(k[i]+1) +
                                  lgamma(o[i]+x[1]) +
                                  lgamma(k[i]-o[i]+x[2]) +
                                  lgamma(x[1]+x[2]) -
                                  lgamma(o[i]+1) -
                                  lgamma(k[i]-o[i]+1) -
                                  lgamma(k[i]+x[1]+x[2]) -
                                  lgamma(x[1]) -
                                  lgamma(x[2]) )
        end
        return wll
    end
    return f
end

function create_bb_gradient_func(k::Vector{Int}, o::Vector{Int}, weights::Vector{Float64})
    function g!(x::Vector, D::Vector)
        # x[1] is alpha, x[2] is beta
        D[1] = 0.0  # deriv w.r.t. alpha, x[1]
        D[2] = 0.0  # deriv w.r.t. beta, x[2]
        for i = 1:length(k)
            D[1] += weights[i] * ( digamma(o[i]+x[1]) +
                                   digamma(x[1]+x[2]) -
                                   digamma(k[i]+x[1]+x[2]) -
                                   digamma(x[1]) )
            D[2] += weights[i] * ( digamma(k[i]-o[i]+x[2]) +
                                   digamma(x[1]+x[2]) -
                                   digamma(k[i]+x[1]+x[2]) -
                                   digamma(x[2]) )
        end
    end
    return g!
end

function create_bb_hessian_func(k::Vector{Int}, o::Vector{Int}, weights::Vector{Float64})
    function h!(x::Vector, H::Matrix)
        # x[1] is alpha, x[2] is beta
        H[1,1] = 0.0 # double deriv alpha, x[1]
        H[2,2] = 0.0 # double deriv beta, x[2]
        H[1,2] = 0.0 # cross deriv 
        for i = 1:length(k)
            H[1,1] += weights[i] * ( trigamma(o[i]+x[1]) +
                                     trigamma(x[1]+x[2]) -
                                     trigamma(k[i]+x[1]+x[2]) -
                                     trigamma(x[1]) )
            H[2,2] += weights[i] * ( trigamma(k[i]-o[i]+x[2]) +
                                     trigamma(x[1]+x[2]) -
                                     trigamma(k[i]+x[1]+x[2]) -
                                     trigamma(x[2]) )
            H[1,2] += weights[i] * ( trigamma(x[1]+x[2]) -
                                     trigamma(k[i]+x[1]+x[2]) )
        end
        storage[2,1] = storage[1,2] # Dab
    end
    return h!
end




