module MethylHMM

using Distributions, Optim

export binomial_HMM,
       betabinom_HMM,
       generate,
       forward,
       backward,
       viterbi,
       fit!

# Constructors and type definitions
include("binomial_HMM.jl")
include("betabinom_HMM.jl")

include("file_io.jl")          # functions for loading data
include("stat_funcs.jl")       # statistics helper functions
include("forward_backward.jl") # dynamic programming functions
include("binomial_fit.jl")     # fitting methods for binomial HMM
include("betabinom_fit.jl")    # fitting methods for betabinomial HMM

# Interface to fitting functions (chooses binom vs betabinom based on HMM type)
function fit!(hmm; method=:baum_welch, repeats=10, max_iter=200, tol=1e-4, scaling=true, Bscale=1.0)
    # Setting tol to NaN will prevent early stopping, resulting in 'max_iter' iterations
    
    # Best/highest log-likelihood value
    best_ll = [-Inf]
    best_A = fill(NaN,size(hmm.A))
    best_B = fill(NaN,size(hmm.B))
    best_p = fill(NaN,size(hmm.p))

    for r = 1:repeats
        println("Fitting HMM from random initial conditions... ", r, " / ", repeats)
        if method == :baum_welch
            ll = baum_welch!(hmm, max_iter, tol, scaling)
        else
            error("method not recognized/implemented")
        end
        if ll[end] > best_ll[end]
            best_ll = ll
            best_A = deepcopy(hmm.A)
            best_B = deepcopy(hmm.B)
            best_p = deepcopy(hmm.p)
        end
        randomize!(hmm,Bscale)
        println() # new line
    end

    # Update hmm to have the best parameters
    hmm.A = best_A
    hmm.B = best_B
    hmm.p = best_p

    return best_ll # return convergence history
end

# Interface to draw samples from an hmm
function generate(hmm, k::Vector{Int}, c::Vector{Int})
    # Generate a sequence of observations (methylation events) given current HMM params
    #   'k' -- coverage, k[t] provides number of reads that include site t
    #   'c' -- nucleotide context, c[t] provides integer key for hmm.context_map for site t
    # Returns:
    #   'o' -- observations, o[t] provides number of methylation events at site t
    n_obs = length(c)

    # Sequence of states and observations
    s = zeros(Int,n_obs) # states
    o = zeros(Int,n_obs) # observations

    # Choose initial state with probabilities weighted by 'hmm.p'
    s[1] = sample(hmm.p)               # hmm.p are the initial state probabilities
    o[1] = rand() <= hmm.B[s[1],c[1]]  # draw obs given initial state, s[1], and context, c[1]

    # Iterate drawing observations and updating state
    for t = 2:n_obs
        # sample from appropriate row of state-transition matrix
        s[t] = sample(hmm.A[s[t-1],:])

        if typeof(hmm) == binomial_HMM
            # B[s,c] is probability of being methylated in state 's' and context 'c'
            prob = hmm.B[s[t],c[t]]
            o[t] = rand(Binomial(k[t],prob))
        elseif typeof(hmm) == betabinom_HMM
            a = hmm.B[s[t],c[t],1]
            b = hmm.B[s[t],c[t],2]
            rand_prob = rand(Beta,a,b)
            o[t] = rand(Binomial(k[t],prob))
        else
            error("HMM type not recognized")
        end
    end

    # return sequence of states and observations
    return (s,o)
end

# Randomize the parameters of an hmm
function randomize!(hmm, Bscale)
    # Randomize state-transition matrix
    hmm.A = rand(hmm.n_states,hmm.n_states)
    hmm.A ./= sum(hmm.A,2) # normalize rows
    
    # Randomize binomial parameters
    hmm.B = Bscale * rand(hmm.n_states,hmm.n_ctxt)
    
    # Randomize initial state probabilities
    hmm.p = rand(hmm.n_states)
    hmm.p ./= sum(hmm.p)
end

end
