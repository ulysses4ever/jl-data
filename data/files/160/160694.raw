module MethylHMM

export HMM, generate, forward, backward, viterbi, baum_welch!

type HMM
	n::Int             # Number of hidden states
	A::Matrix{Float64} # Estimated state-transition matrix A[i,j] = Pr[i->j]
	
	m::Int             # Number of nucleotide contexts
	B::Matrix{Float64} # Estimated methylation probabilities in each state and context
	contexts::Vector{ASCIIString} # list of the nucleotide contexts
	
	p::Vector{Float64} # Estimated initial state probabilities

	# Notes:
	#   'A' is a NxN matrix, rows sum to one
	#   'B' is a NxM matrix, where M = number of nucleotide contexts (CG, CA, CC, etc.)
	#		B[i,j] is a probability of a site being methylated, 0 <= B[i,j] <= 1
	#		B[i,:] are the probabilities in state 'i' across contexts
	#		B[:,j] are the probabilities in context 'j' across states
end

function HMM(n::Int; contexts=["CG","CA","CT","CC"])
	# Randomize state-transition matrix
	A = rand(n,n)
	A ./= repmat(sum(A,1),n,1) # normalize rows
	
	# Randomize emission probability matrix
	m = length(contexts)
	B = rand(n,m)
	
	# Randomize initial state probabilities
	p = rand(n)
	p ./= sum(p)

	return HMM(n,A,m,B,contexts,p)
end

function lkh(p::Float64, o::Bool)
	# calculate bernoulli pdf/likelihood of observation 'o' with probability 'p'
	return o*p + ~o*(1-p)
end

function sample(p)
	# Sample from categorical distribution with probability vector p
	v = rand()
	s = 0.0
	for i = 1:length(p)
		s += p[i]
		if v <= s
			return i
		end
	end
	return length(p)
end

function generate(hmm::HMM, c::Vector{Int})
	# Generate sequence of observations, given a vector 'c' of nucleotide contexts
	n_obs = length(c)

	# Sequence of states and observations
	s = zeros(Int,n_obs) # states
	o = zeros(Bool,n_obs) # observations

	# Choose initial state with probabilities weighted by 'hmm.p'
	s[1] = sample(hmm.p)               # hmm.p are the initial state probabilities
	o[1] = rand() <= hmm.B[s[1],c[1]]  # draw obs given initial state, s[1], and context, c[1]


	# Iterate drawing observations and updating state
	for t = 2:n_obs
		# sample from appropriate row of state-transition matrix
		s[t] = sample(hmm.A[s[t-1],:])

		# B[s,c] is probability of being methylated in state 's' and context 'c' 
		o[t] = rand() <= hmm.B[s[t],c[t]] 
	end

	# return sequence of states and observations
	return (s,o)
end

function forward(hmm::HMM, o::Vector{Bool}, c::Vector{Int}; scaling=true)
	# Calculate forward variables given observation sequence 'o' and context sequence 'c' 
	n_obs = length(o)

	# alpha[t,i] = (scaled) probability of being in state 'i' given o[1:t] and c[1:t]
	alpha = zeros(n_obs, hmm.n) 

	# base case (initialize at start)
	for i = 1:hmm.n
		alpha[1,i] = hmm.p[i] * lkh(hmm.B[i,c[1]], o[1])
	end

	if scaling
		coeff = (Float64)[] # scaling coefficients
		push!(coeff, 1./sum(alpha[1,:]))
		alpha[1,:] *= coeff[end] 
	end

	# induction step
	for t = 2:n_obs
		for j = 1:hmm.n
			for i = 1:hmm.n
				alpha[t,j] += hmm.A[i,j] * alpha[t-1,i]
			end
			alpha[t,j] *= lkh(hmm.B[j,c[t]], o[t])
		end
		if scaling
			push!(coeff, 1./sum(alpha[t,:]))
			alpha[t,:] *= coeff[end]
		end
	end

	# Calculate likelihood (or log-likelihood) of observed sequence
	if scaling
		log_p_obs = -sum(log(coeff)) # see Rabiner (1989), eqn 103
		return (alpha,log_p_obs,coeff)
	else
		p_obs = sum(alpha[end,:]) 
		return (alpha,p_obs)
	end
end

function backward(hmm::HMM, o::Vector{Bool}, c::Vector{Int}; scale_coeff=None)
	# Calculate backward variables given observation sequence 'o' and context sequence 'c' 
	# Variables are scaled if scale_coeff from forward algorithm, 1/sum(alpha[t,:]), are provided
	n_obs = length(o)

	# beta[t,i] = probability of being in state 'i' and then obseverving o[t+1:end]
	beta = zeros(n_obs, hmm.n)

	# base case (initialize at end)
	if scale_coeff == None
		beta[end,:] += 1
	else
		if length(scale_coeff) != n_obs
			error("scale_coeff is improperly defined (wrong length)")
		end
		beta[end,:] += scale_coeff[end]
	end

	# induction step
	for t = reverse(1:n_obs-1)
		for i = 1:hmm.n
			for j = 1:hmm.n
				beta[t,i] += hmm.A[i,j] * beta[t+1,j] * lkh(hmm.B[j,c[t+1]], o[t+1])
			end
		end
		if scale_coeff != None
			beta[t,:] *= scale_coeff[t]
		end
	end

	return beta
end

function viterbi(hmm::HMM, o::Vector{Bool}, c::Vector{Int})
	n_obs = length(o)

	# delta[i,j] = highest probability of state sequence ending in state j on step i
	# psi[i,j] = most likely state on step i-1 given state j on step i (argmax of deltas)
	delta = zeros(n_obs, hmm.n)
	psi = ones(Int, n_obs, hmm.n)

	# base case, psi[:,1] is ignored so don't initialize
	for i = 1:hmm.n
		delta[1,i] = hmm.p[i] .* lkh(hmm.B[i,c[1]],o[1])
	end

	# induction step
	for t = 2:n_obs
		for j = 1:hmm.n
			delta[t,j],psi[t,j] = findmax(hmm.A[:,j].*delta[t-1,:]')
			delta[t,j] *= lkh(hmm.B[j,c[t]],o[t])
		end
	end

	# backtrack to uncover the most likely path / state sequence
	q = zeros(Int,n_obs) # vector holding state sequence
	q[end] = indmax(delta[end,:])

	# backtrack recursively
	for t = reverse(1:n_obs-1)
		q[t] = psi[t+1,q[t+1]]
	end
	return q
end

end
