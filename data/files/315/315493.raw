module jb2048

import PyPlot
plt = PyPlot
plt.ion()

# used by dag2048.jl
export Board, Game, History, plot, record, slide, tileinsert!, back!

"Board=puzzle"
typealias Board Matrix{Int}

plotcolor = ["white", "lightyellow", "orange", "orange",
             "tomato", "tomato", "yellow", "yellow",
             "gold", "gold", "peru", "chocolate",
             "orangered", "red", "red"]
plotstyle = Dict("alpha"=>0.5, "boxstyle"=>"round")

"""
    plot(b::Board [, newtile, depth])

Plot a board. Optional argument `newtile`
is the index of a tile to be singled out
(it's value is expected to be computed by `tileinsert!`).
Optional argument `depth` is displayed as a figure's title
(it's value is expected to be computed by `move!`).
"""
function plot(b::Board, newtile=0, depth=0, move=0)
    plt.figure("2048", figsize=(7,5))
    plt.subplots_adjust(left=0.02, right=0.98, bottom=0.02, top=0.92)
    fs = 36 # font size
    m, n = size(b)
    plt.clf()
    plt.axis([0.5, n+0.5, 0.5, m+0.5])
    plt.xticks([])
    plt.yticks([])
    depth > 0 && plt.title("Depth $depth", loc="left")
    move > 0 && plt.title("Move $move", loc="right")
    lp = length(plotcolor)
    for i in 1:m
        for j in 1:n
            t = b[i,j]
            t == 0 && continue
            if 0 < t <= lp
                k = sub2ind((m,n),i,j)
                plotstyle["facecolor"] =
                    (k == newtile) ? "lightgreen" : plotcolor[t]
                t = 1 << t
            else
                plotstyle["facecolor"] = "lightcyan"
            end
            plt.text(j, m + 1 - i, t,
                ha = "center", va = "center",
                size = fs, bbox = plotstyle)
        end
    end
    plt.draw()
    plt.pause(0.01)
end

"""
    tileinsert!(b::Board)

Insert a random new tile into a board.
"""
function tileinsert!(b::Board)
    u = find(b .== 0)
    i = u[rand(1:end)]
    t = rand() < 0.9 ? 1 : 2
    b[i] = t
    i
end

"""
    slide(b::Board, direction:: Int)

Slide a board `b` in one of the four directions (1=left, 2=right, 3=up, 4=down),
and merge equal tiles, along the rules of 2048 game.

Return a tuple `(rb,score,moved)` where:
  * `rb` is the resulting board
  * `score` is the sum of the values of merged tiles
  * `moved` is a boolean that reports whether the initial board `b`
    and the new one `rb` are distinct, i.e. whether the move is legal.
"""
slide(b::Board, direction:: Int)=dslide(b,direction)
function dslide(b::Board, direction:: Int)
    # direct slide, with code duplication
    m, n = size(b)
    r = zeros(b)
    score = 0
    moved = false
    if direction < 3    # horizontal slide
        (direction == 1) ? (start = 1; delta = 1) : (start = n; delta = -1)
        for i in 1:m
            j = target = start
            t0 = 0
            @inbounds for k in 1:n
                t = b[i,j]
                if t > 0
                    if t == t0  # tiles merge
                        t += 1
                        target -= delta
                        t0 = 0
                        score += 1 << t
                    else
                        t0 = t
                    end
                    r[i,target] = t
                    target == j || (moved = true)
                    target += delta
                end
                j += delta
            end
        end
    else    # vertical slide
        (direction == 3) ? (start = 1; delta = 1) : (start = m; delta = -1)
        for j in 1:n
            i = target = start
            t0 = 0
            @inbounds for k in 1:m
                t = b[i,j]
                # if t != 0
                if t > 0
                    if t == t0  # tiles merge
                        t += 1
                        target -= delta
                        t0 = 0
                        score += 1 << t
                    else
                        t0 = t
                    end
                    r[target,j] = t
                    target == i || (moved = true)
                    target += delta
                end
                i += delta
            end
        end
    end
    return r, score, moved
end

function tslide(b::Board, direction:: Int)
    # use transposition
    # no code duplication, but almost three times slower :-(
    if direction < 3    # horizontal slide
        m, n = size(b)
        rb = zeros(b)
        score = 0
        moved = false
        (direction == 1) ? (start = 1; delta = 1) : (start = n; delta = -1)
        for i in 1:m
            j = target = start
            t0 = 0
            @inbounds for k in 1:n
                t = b[i,j]
                if t > 0
                    if t == t0  # tiles merge
                        t += 1
                        target -= delta
                        t0 = 0
                        score += 1 << t
                    else
                        t0 = t
                    end
                    rb[i,target] = t
                    target == j || (moved = true)
                    target += delta
                end
                j += delta
            end
        end
        return rb, score, moved
    else    # vertical slide
        b = transpose(b)
        rb, score, moved = tslide(b, direction-2)
        return transpose(rb), score, moved
    end
end

gamma = [16 11 8 6; 11 6 4 3; 8 4 2 1.4; 6 3 1.4 1]
# gamma = [10 6 4 3; 6 4 3 2; 4 3 2 1.42; 3 2 1.42 1]
# gamma = 0.25 * [64 32 16 8; 32 12 6 4; 16 6 3 2; 8 4 2 1]
# gamma = 0.5 * [14 12 10 8; 12 9 6 4; 10 6 3 2; 8 4 2 1]

function setgamma(weights=nothing)
    global gamma = [16 11 8 6; 11 6 4 3; 8 4 2 1.4; 6 3 1.4 1]
    weights == nothing || (gamma = weights)
    gamma
end

worse_eval = -128.0
function updateworse(b::Board)
    sup = maximum(b)
    global worse_eval = - (1 << sup) * gamma[1]
end

# staticache = Dict{Board,Float64}()
staticache = Dict{UInt64,Float64}()
hits_staticeval = misses_staticeval = 0

"""
    staticeval(b::Board)

Return the static evaluation of a board.
Use the global weighting matrix `gamma`.
"""
function staticeval(b::Board)
    ### cache
    ### It's a little faster to store only a key in the cache,
    ### instead of the matrix b, and it's safe in this context
    global staticache, hits_staticeval, misses_staticeval
    key = hash(b)
    val::Float64 = get(staticache, key, 0.0)
    val == 0.0 || (hits_staticeval += 1; return val)
    ### end cache

    global gamma
    # val::Float64
    local yval::Float64
    m, n = size(b)
    x = b[1]
    val = (1<<x) * gamma[1]
    score = 0
    # first column
    @inbounds for i in 2:m
        y = b[i,1]
        if y>0
            if x < y    # y squeezes x
                yval = 4<<x - 4<<y
            else
                yval = (1<<y) * gamma[i,1]
                x==y && (score += 2<<x)
            end
            val += yval
        end
        x = y
    end
    # first row
    x = b[1]
    @inbounds for j in 2:n
        y = b[1,j]
        if y>0
            if x < y    # y squeezes x
                yval = 4<<x - 4<<y
            else
                yval = (1<<y) * gamma[1,j]
                x==y && (score += 2<<x)
            end
            val += yval
        end
        x = y
    end
    # inner tiles
    for i in 2:m
        @inbounds for j in 2:n
            y = b[i,j]
            if y>0
                squeeze = 0
                x = b[i,j-1]
                if x>0
                    if x<y  # y squeezes x
                        squeeze = 4<<x - 4<<y
                    elseif x==y
                        score += 2<<x
                    end
                end
                x = b[i-1,j]
                if x>0
                    if x<y  # y squeezes x
                        squeeze += 4<<x - 4<<y
                    elseif x==y
                        squeeze = 0
                        score += 2<<x
                    end
                end
                if squeeze < 0
                    yval = squeeze
                else
                    yval = (1<<y) * gamma[i,j]
                end
                val += yval
            end
        end
    end
    val += score
    ### cache
    misses_staticeval += 1
    staticache[key] = val
    ### end cache
    val
end

"""
    maxeval(b::Board, depth [, score])

Return the recursive evaluation of the best move
(via calls to `meaneval`), up to the required depth.
Update optional argument score, before transmission to `meaneval`.
"""
function maxeval(b::Board, depth::Int, score::Int=0)
    besteval = worse_eval
    top = b[1]
    for d = 1:4
        bs, sc, moved = slide(b, d)
        if moved
            bs[1] < top && 8 < top && continue
            val = meaneval(bs, depth-1, score+sc)
            val > besteval && (besteval = val)
        end
    end
    besteval
end

# meancache = Dict{(Board,Int,Int),Float64}()
meancache = Dict{UInt64,Float64}()
hits_meaneval = misses_meaneval = 0

"""
    meaneval(b::Board, depth [, score])

Return `score + staticeval(b)` if `depth==0`.
Otherwise, for each board resulting of the insertion of a new tile in `b`:
  * evaluate it via a recursive call to `maxeval`, up to the required depth
  * return the average evaluation, with uniform weight
    for each free cell in `b`, and 0.9 weight (resp. 0.1)
    when inserting the tile 2 (resp. 4).
"""
function meaneval(b::Board, depth::Int, score::Int=0)
    depth <= 0 && return score + staticeval(b)
    ### cache
    # It's a little faster to store only a key in the cache,
    # instead of (b,depth,score), and it's safe in this context
    global meancache, hits_meaneval, misses_meaneval
    key = hash((b,depth,score))
    val::Float64 = get(meancache, key, 0.0)
    val == 0.0 || (hits_meaneval += 1; return val)
    ## end cache

    # val::Float64
    fc = find(b .== 0)  # indices of free cells
    nf = length(fc)
    if nf == 0
        return worse_eval
    end
    val = score
    for i in fc
        b[i] = 1
        val += 0.9 * maxeval(b, depth, score)
        b[i] = 2
        val += 0.1 * maxeval(b, depth, score)
        b[i] = 0
    end
    val = val / nf
    ### cache
    misses_meaneval += 1
    meancache[key] = val
    ### end cache
    val
end

type History
    length::Int
    circular::Int
    start::Int
    board::Array{Board}
    newtile::Array{Int}
    depth::Array{Int}

    function History(length)
        circular = 0
        start = 1
        board = Array(Board,length)
        newtile = Array(Int,length)
        depth = Array(Int,length)
        new(length, circular, start, board, newtile, depth)
    end
end

# import Base.show
function Base.show(io::IO, h::History)
    print(io, "Circular history: start $(h.start) -> current $(h.circular), length $(h.length)")
end

function record(h::History, b::Board, t::Int, d::Int)
    # first values of (start,circular) for length 128, phase 1:
    #  (1,0) -> (1,1) -> (1,2) -> (1,3) ... -> (1,127) -> (1,128)
    # now buffer is full, transition to phase 2 occurs: (1,128) -> (2,1)
    # values of (circular,start) during phase 2:
    #  (1,2) -> (2,3) -> (3,4) ... -> (127, 128) -> (128,1) -> (1,2)
    h.circular += 1
    if h.circular > h.length
        h.circular = 1
        h.start = 2
    elseif h.start > 1
        # steady state, full circular buffer
        h.start += 1
        h.start > h.length && (h.start = 1)
    end
    i = h.circular
    h.board[i], h.newtile[i], h.depth[i] = b, t, d
end

# import Base.getindex, Base.setindex!
function Base.getindex(h::History, i::Int)
    n = endof(h)
    i = mod(h.start + i - 2, n) + 1
    h.board[i], h.newtile[i], h.depth[i]
end

# import Base.endof
function Base.endof(h::History)
    h.start == 1 ? h.circular : h.length
end

"""
A game `g` has five fields:
  * `board`, a matrix that records game's "position"
  * `newtile`, an index that records the last tile inserted
    by `tileinsert!`, and is used by `plot!`
  * `depth`, that records the recursive depth computed
    by `move!`, and is used by `plot!`
  * `length`, which records the number of moves during a play
  * `hist`, a circular buffer that stores previous values of `g.board`
"""
type Game
    board::Board
    newtile::Int
    length::Int
    depth::Int
    hist::History

    function Game(board)
        new(board, 0, 0, 0, History(128))
    end
end
record(g::Game) = record(g.hist, g.board, g.newtile, g.depth)

function Base.show(io::IO, g::Game)
    print(io, "Game ", g.board, ", length ", g.length,
        ", newtile ", g.newtile, ", depth ", g.depth)
end

Base.getindex(g::Game, i...) = g.board[i...]
Base.setindex!(g::Game, x, i...) = Base.setindex!(g.board, x, i...)
Base.endof(g::Game) = Base.endof(g.board)

"""
    plot(g::Game [, depth])

Shortcut for plotting `g.board`, with `g.newtile` singled out,
and `g.depth`, `g.length` displayed as title
"""
function plot(g::Game)
    plot(g.board, g.newtile, g.depth, g.length)
end

function initgame()
    g = Game(zeros(gamma))
    tileinsert!(g.board)
    g.newtile=tileinsert!(g.board)
    g
end

# careful = [7, 12, 16]
# careful = [5, 7, 9, 16, 16]
careful = [5, 7, 9, 11, 16, 16]
function setcareful(steps=nothing)
    global careful = [5, 7, 9, 16, 16]
    steps == nothing || (careful = steps)
    careful
end

"""
    move!(g::Game)

Update `g.board`, and return a couple `(bestdir, depth)`,
where `bestdir` is an integer that codes
the direction of the move (0 stands for "end of game",
i.e. there is no legal move), and `depth` is the
(computed) depth of the
recursive evaluation performed
for computing this "best" move.
"""
function move!(g::Game)
    empty!(staticache)
    empty!(meancache)
    updateworse(g.board)

    ### compute depth
    depth = length(careful)
    small = length(find(g.board .< 3))
    for step in careful
        small > step && (depth -= 1)
    end
    g.depth = depth

    ### compute best move
    besteval = worse_eval
    bestdir = 0
    top = g.board[1]
    pruned::Vector{Int} = []
    local newboard
    for d = 1:4
        b, score, moved = slide(g.board, d)
        if moved
            if b[1] < top && 8 < top
                push!(pruned, d)
                continue
            end
            val = meaneval(b, depth, score)
            if val > besteval
                besteval = val
                bestdir = d
                newboard = b
            end
        end
    end
    if length(pruned) > 0 && besteval < 0
        # desperate attempt to find a better move
        # code is duplicated but we must try it, especially if bestdir==0
        # (i.e. no other legal move)
        # println(g.board, pruned, round(besteval))
        for d in pruned
            b, score, moved = slide(g.board, d)
            if moved
                val = meaneval(b, depth, score)
                if val > besteval
                    besteval = val
                    bestdir = d
                    newboard = b
                end
            end
        end
    end
    if bestdir > 0
        g.board = newboard
        g.length += 1
    end
    bestdir
end

"""
    play!(g::Game; display=false, moves=32768)

Play a game, with current state of `g` as starting point.
Update `g` and for convenience return `g.length` (the total number of moves
since creation of the game `g`).
If keyword argument `display` is `true`, `g` is plotted after each move.
The number of moves may be bounded by
the optional keyword argument `moves`,
thereafter the play stops -- and may be resumed by issuing
again `play!(g)`.
"""
function play!(g::Game; display=false, moves=32768, target=32)
    global gamma
    global hits_meaneval, misses_meaneval
    global hits_staticeval, misses_staticeval
    n = g.length
    if n < 2
        hits_meaneval = misses_meaneval = 0
        hits_staticeval = misses_staticeval = 0
        g.hist = History(128)
        record(g.hist, g.board, 0, 0)
    end
    while g.length < n + moves && g[1] < target
        move!(g) > 0 || break
        g.newtile = tileinsert!(g.board)
        display && plot(g)
        record(g)
    end
    g.length
end

"""
    back!(g::Game, i)

Restore the game `g` to a previous state.
The integer `i` is an index in the circular buffer `g.hist`:

    back!(g,-1) # cancel the last move
    back!(g, 1) # restore the game at the beginning of the history

Caution: `g.hist` is not updated.
"""
function back!(g::Game, i)
    g.board, g.newtile = g.hist[i][1:2]
    n = endof(g.hist)
    g.length += mod1(i, n) - n
end

"""
    force!(g::Game, dir::Int)

Force a move in the required direction (without updating history),
and plot the result:

    force!(g,3) # force a move up
"""
function force!(g::Game, dir::Int)
    b, score, moved = slide(g.board, dir)
    moved || error("Illegal direction")
    g.board = b
    g.newtile = tileinsert!(b)
    plot(g)
    score
end

"""
    evals(b::Board, depth)

Return a matrix `u`, where `u[i,j]` is the evaluation of move `i`
(i.e. in the direction `i`) up to depth `j`.
"""
function evals(b::Board, depth::Int)
    empty!(staticache)
    empty!(meancache)
    u = zeros(4,depth)
    for dir = 1:4
        bs, score, moved = slide(b, dir)
        if moved
            for k = 1:depth
                val = meaneval(bs, k, score)
                u[dir,k] = round(val)
            end
        end
    end
    u
end

"""
    repartition(n; board, verbose)

Play `n` games and return a tuple of statistics:
  * average number of moves
  * an array `hsup`, where hsup[i] is the number of games that halted
    with 2^i as the largest tile
  * an array `amoves`, that records, for each game, the number of moves.

Optional keyword argument `board` specifies the starting board.
If the optional keyword argument `verbose` is given,
it should be a range: after each game `hsup[verbose]` is printed,
among other informations. Example:

    repartition(100, verbose=10:14)

prints, after each of 100 games, some informations and
the number of games that reached so far 1024, 2048, ... 16384.
"""
function repartition(n; board=nothing, verbose=1:0)
    hsup = zeros(Int, 15)
    nmoves = 0
    local hmoves
    amoves = zeros(Int, n)
    for i=1:n
        g = (board == nothing) ? initgame() : Game(board)
        play!(g)
        amoves[i] = g.length
        nmoves += g.length
        sup = maximum(g.board[g.board .<= length(hsup)])
        hsup[sup] += 1
        hmoves = div(nmoves,i)
        if length(verbose) > 1
            v = hsup[verbose]
            println(i,": ",(g.length, 1<<sup), " -> $hmoves $v")
            # sup < 10 && println(g)
        end
    end
    sort!(amoves, rev=true)
    hmoves, hsup, amoves
end

end
