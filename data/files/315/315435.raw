module dag2048

using jb2048
import Base.show

abstract DagNode

meandag = Dict{Board,DagNode}()
type MeanNode <: DagNode
    board::Board
    child::Vector{DagNode}
    val::Vector{Float64}
    height::Int

    function MeanNode(b::Board)
        global meandag::Dict{Board,DagNode}
        node = get(meandag, b, nothing)
        node == nothing || return node
        child = DagNode[]
        val = zeros(10)
        height = 0
        fc = find(b .== 0)  # free cells (indices)
        nf = length(fc)
        p1 = 0.9/nf
        p2 = 0.1/nf
        for i in fc
            b[i] = 1
            c =  MaxNode(copy(b))
            push!(child, c)
            val += c.val * p1
            h = c.height + 1
            h > height && (height = h)
            b[i] = 2
            c =  MaxNode(copy(b))
            push!(child, c)
            val += c.val * p2
            h = c.height + 1
            h > height && (height = h)
            b[i] = 0
        end
        node = new(b, child, val, height)
        meandag[b] = node
    end
end

function meantree(b::Board)
    empty!(meandag)
    empty!(maxdag)
    MeanNode(b, 1)
end

maxdag = Dict{Board,DagNode}()
type MaxNode <: DagNode
    board::Board
    child::Vector{DagNode}
    val::Vector{Float64}
    best::Tuple{Int,Int}
    height::Int
    # target::Int

    # function MaxNode(b::Board, target=32)
    function MaxNode(b::Board)
        function children(onlystable=true)
            i = 0
            local v::Float64
            for d = 1:4
                bs, score, moved, stable = slide(b, d)
                onlystable && !stable && continue
                if moved
                    i += 1
                    c = MeanNode(bs)
                    push!(child, c)
                    if i < 2
                        val = c.val
                        best = (i,d)
                        v = sum(ival .* val)
                    else
                        cv = sum(ival .* c.val)
                        cv > v && (val=c.val; v=cv; best=(i,d))
                    end
                    h = c.height
                    h > height && (height=h)
                end
            end
            i > 0
        end
        global maxdag::Dict{Board,DagNode}
        node = get(maxdag, b, nothing)
        node == nothing || return node
        child = DagNode[]
        val = zeros(10)
        # ival = collect(Float64, [1<<i for i=1:10])
        ival = collect(Float64, 1:10)
        best = (0,0)
        height = 0
        i = 0
        local v::Float64
        intern = children(true)
        # ok || (ok = children(false))
        if !intern  # leaf
            lv = length(val)
            sup = maximum(b[b .<= lv])
            val[sup] = 1.0
        end
        node = new(b, child, val, best, height)
        # node = new(b, child, val, best, height, target)
        maxdag[b] = node
    end
end

# function maxtree(b::Board, target=32)
function maxtree(b::Board)
    empty!(meandag)
    empty!(maxdag)
    MaxNode(b)
    # MaxNode(b,target)
end

isleaf(d::DagNode) = length(d.child) == 0
# function isleaf(d::DagNode, target::Int)
#     d.board[1] == target || isleaf(d)
# end

function show(io::IO, d::DagNode)
    b = d.board
    m, n = size(b)
    print(io, "[")
    for i in 1:m
        for j in 1:n
            print(io, " ", b[i,j])
        end
        if i < m
            print(io, ";")
        else
            print(io, "]")
        end
    end
    i = findfirst(d.val)
    j = findlast(d.val)
    val=d.val[i:j]
    val = round(val,4)
    if length(d.child) == 0
        print(io, ", leaf -> val $i$val")
        return
    end
    if isa(d, MeanNode)
        print(io, " mean -> val $i$val\n  height $(d.height)")
    else
        print(io, " max -> val $i$val\n  height $(d.height), best $(d.best)")
    end
end

function play!(g::Game, moves=32768; target=32, display=false,verbose=false)
    b = g.board
    if g.length < 2
        g.hist = jb2048.History(128)
        jb2048.append(g.hist, g.board, 0)
    end
    while g.length < moves
        verbose && println("move $(g.length)")
        node = maxdag[b]
        verbose && println(node)
        isleaf(node) && break
        c = node.child[node.best[1]]
        b = copy(c.board)
        g.newtile = tileinsert!(b)
        verbose && println("$c, new tile $(g.newtile)")
        g.length += 1
        g.board = b
        display && plot(g)
        jb2048.append(g.hist, b, g.newtile)
        b[1] >= target && break
    end
    g.length
end

end
