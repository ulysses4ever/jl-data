# N-Body Simulation in Julia for the Computer Language Benchmark Game
# Contributed by Jay Bromley

# Constants
const SOLAR_MASS = 4 * pi * pi
const DAYS_PER_YEAR = 365.24

# Types

type Body{T}
    m::T
    x::Vector{T}
    v::Vector{T}
end

# Initialize the bodies: Sun, Jupiter, Saturn, Uranus, Neptune

function make_bodies()
    return Body{Float64}[
     Body{Float64}(SOLAR_MASS, [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]),
     Body{Float64}(9.54791938424326609e-04 * SOLAR_MASS,
                   [4.84143144246472090e+00,
                    -1.16032004402742839e+00,
                    -1.03622044471123109e-01],
                   [1.66007664274403694e-03,
                    7.69901118419740425e-03,
                    -6.90460016972063023e-05] * DAYS_PER_YEAR),
     Body{Float64}(2.85885980666130812e-04 * SOLAR_MASS,
                   [8.34336671824457987e+00,
                    4.12479856412430479e+00,
                    -4.03523417114321381e-01],
                   [-2.76742510726862411e-03,
                    4.99852801234917238e-03,
                    2.30417297573763929e-05] * DAYS_PER_YEAR),
     Body{Float64}(4.36624404335156298e-05 * SOLAR_MASS,
                   [1.28943695621391310e+01,
                    -1.51111514016986312e+01,
                    -2.23307578892655734e-01],
                   [2.96460137564761618e-03,
                    2.37847173959480950e-03,
                    -2.96589568540237556e-05] * DAYS_PER_YEAR),
     Body{Float64}(5.15138902046611451e-05 * SOLAR_MASS,
                   [1.53796971148509165e+01,
                    -2.59193146099879641e+01,
                    1.79258772950371181e-01],
                   [2.68067772490389322e-03,
                    1.62824170038242295e-03,
                    -9.51592254519715870e-05] * DAYS_PER_YEAR)]
end

function offsetmomentum!(bodies)
    bodies[1].v = -sum(map((b) -> b.m * b.v, bodies)) / SOLAR_MASS
end

function distance(x1, x2)
    delta = similar(x1)
    for i in 1:endof(x1)
        delta[i] = x1[i] - x2[i]
    end
    sqrt(dot(delta, delta))
end

function kinetic(body)
    0.5 * body.m * dot(body.v, body.v)
end

function potential(b1, b2)
    (b1.m * b2.m) / distance(b1.x, b2.x)
end

function energy(bodies)
    e = 0.0

    for i in 1:endof(bodies)
        @inbounds b1 = bodies[i]
        e += kinetic(b1)
        for j in (i + 1):endof(bodies)
            @inbounds b2 = bodies[j]
            e -= potential(b1, b2)
        end
    end
    return e
end

function step!(bodies, dt)
    # Update velocities.
    for i in 1:endof(bodies), j in (i + 1):endof(bodies)
        @inbounds b1 = bodies[i]
        @inbounds b2 = bodies[j]
        delta = b1.x - b2.x
        d = distance(b1.x, b2.x)
        mag = dt / (d * d * d)
        b1.v -= delta * b2.m * mag
        b2.v += delta * b1.m * mag
    end

    # Update positions.
    for b in bodies
        b.x += dt * b.v
    end
end

function run(iterations)
    bodies = make_bodies()
    offsetmomentum!(bodies)
    println(energy(bodies))
    for i in 1:iterations
        step!(bodies, 0.01)
    end
    println(energy(bodies))
end


# Main entry point
# iterations = int(ARGS[1])
# run(iterations)
