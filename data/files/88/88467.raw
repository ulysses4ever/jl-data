import Base.Math: @horner

const FORWARD  =  true
const BACKWARD = false

const sqrtpi = 1.772453850905516027298
const edivsqrt2pi = 1.084437551419227546612

"""
Compute a typed 0.5.
"""
half(x::Number) = oftype(x,0.5)
half(x::Integer) = half(float(x))
half{T<:Number}(::Type{T}) = convert(T,0.5)
half{T<:Integer}(::Type{T}) = half(AbstractFloat)

"""
Compute a typed 2.
"""
two(x::Number) = oftype(x,2)
two{T<:Number}(::Type{T}) = convert(T,2)

"""
The Kronecker Œ¥ function.
"""
Œ¥(k::Integer,j::Integer) = k == j ? 1 : 0


"""
Pochhammer symbol (x)_n = Œì(x+n)/Œì(x) for the rising factorial.
"""
function pochhammer(x::Number,n::Integer)
    ret = one(x)
    if n‚â•0
        for i=0:n-1
            ret *= x+i
        end
    else
        ret /= pochhammer(x+n,-n)
    end
    ret
end

pochhammer{T<:Number}(x::AbstractArray{T,1},n::Integer) = [pochhammer(x[i],n) for i=1:length(x)]
pochhammer{T<:Number}(x::AbstractArray{T,2},n::Integer) = [pochhammer(x[i,j],n) for i=1:size(x,1),j=1:size(x,2)]
pochhammer{T<:Number}(x::AbstractArray{T},n::Integer) = reshape([ pochhammer(x[i],n) for i in eachindex(x) ], size(x))

pochhammer(x::Number,n::Number) = gamma(x+n)/gamma(x)
pochhammer{T<:Number}(x::AbstractArray{T},n::Number) = gamma(x+n)./gamma(x)

function pochhammer{T<:Real}(x::Number,n::UnitRange{T})
    ret = Vector{promote_type(typeof(x),T)}(length(n))
    ret[1] = pochhammer(x,first(n))
    for i=2:length(n)
        ret[i] = (x+n[i]-1)*ret[i-1]
    end
    ret
end

"""
Stirling series for Œì(z).
"""
stirlingseries(z) = gamma(z)*sqrt((z/œÄ)/2)*exp(z)/z^z

function stirlingseries(z::Float64)
    if z ‚â• 3274.12075200175       # N =  4
        @horner(inv(z),1.0,0.08333333333333333,0.003472222222222222,-0.0026813271604938273)
    elseif z ‚â• 590.1021805526798  # N =  5
        @horner(inv(z),1.0,0.08333333333333333,0.003472222222222222,-0.0026813271604938273,-0.00022947209362139917)
    elseif z ‚â• 195.81733962412835 # N =  6
        @horner(inv(z),1.0,0.08333333333333333,0.003472222222222222,-0.0026813271604938273,-0.00022947209362139917,0.0007840392217200666)
    elseif z ‚â• 91.4692823071966   # N =  7
        @horner(inv(z),1.0,0.08333333333333333,0.003472222222222222,-0.0026813271604938273,-0.00022947209362139917,0.0007840392217200666,6.972813758365857e-5)
    elseif z ‚â• 52.70218954633605  # N =  8
        @horner(inv(z),1.0,0.08333333333333333,0.003472222222222222,-0.0026813271604938273,-0.00022947209362139917,0.0007840392217200666,6.972813758365857e-5,-0.0005921664373536939)
    elseif z ‚â• 34.84031591198865  # N =  9
        @horner(inv(z),1.0,0.08333333333333333,0.003472222222222222,-0.0026813271604938273,-0.00022947209362139917,0.0007840392217200666,6.972813758365857e-5,-0.0005921664373536939,-5.171790908260592e-5)
    elseif z ‚â• 25.3173982783047   # N = 10
        @horner(inv(z),1.0,0.08333333333333333,0.003472222222222222,-0.0026813271604938273,-0.00022947209362139917,0.0007840392217200666,6.972813758365857e-5,-0.0005921664373536939,-5.171790908260592e-5,0.0008394987206720873)
    elseif z ‚â• 19.685015283078513 # N = 11
        @horner(inv(z),1.0,0.08333333333333333,0.003472222222222222,-0.0026813271604938273,-0.00022947209362139917,0.0007840392217200666,6.972813758365857e-5,-0.0005921664373536939,-5.171790908260592e-5,0.0008394987206720873,7.204895416020011e-5)
    elseif z ‚â• 16.088669099569266 # N = 12
        @horner(inv(z),1.0,0.08333333333333333,0.003472222222222222,-0.0026813271604938273,-0.00022947209362139917,0.0007840392217200666,6.972813758365857e-5,-0.0005921664373536939,-5.171790908260592e-5,0.0008394987206720873,7.204895416020011e-5,-0.0019144384985654776)
    elseif z ‚â• 13.655055978888104 # N = 13
        @horner(inv(z),1.0,0.08333333333333333,0.003472222222222222,-0.0026813271604938273,-0.00022947209362139917,0.0007840392217200666,6.972813758365857e-5,-0.0005921664373536939,-5.171790908260592e-5,0.0008394987206720873,7.204895416020011e-5,-0.0019144384985654776,-0.00016251626278391583)
    elseif z ‚â• 11.93238782087875  # N = 14
        @horner(inv(z),1.0,0.08333333333333333,0.003472222222222222,-0.0026813271604938273,-0.00022947209362139917,0.0007840392217200666,6.972813758365857e-5,-0.0005921664373536939,-5.171790908260592e-5,0.0008394987206720873,7.204895416020011e-5,-0.0019144384985654776,-0.00016251626278391583,0.00640336283380807)
    elseif z ‚â• 10.668852439197263 # N = 15
        @horner(inv(z),1.0,0.08333333333333333,0.003472222222222222,-0.0026813271604938273,-0.00022947209362139917,0.0007840392217200666,6.972813758365857e-5,-0.0005921664373536939,-5.171790908260592e-5,0.0008394987206720873,7.204895416020011e-5,-0.0019144384985654776,-0.00016251626278391583,0.00640336283380807,0.0005401647678926045)
    elseif z ‚â• 9.715358216638403  # N = 16
        @horner(inv(z),1.0,0.08333333333333333,0.003472222222222222,-0.0026813271604938273,-0.00022947209362139917,0.0007840392217200666,6.972813758365857e-5,-0.0005921664373536939,-5.171790908260592e-5,0.0008394987206720873,7.204895416020011e-5,-0.0019144384985654776,-0.00016251626278391583,0.00640336283380807,0.0005401647678926045,-0.02952788094569912)
    elseif z ‚â• 8.979120323411497  # N = 17
        @horner(inv(z),1.0,0.08333333333333333,0.003472222222222222,-0.0026813271604938273,-0.00022947209362139917,0.0007840392217200666,6.972813758365857e-5,-0.0005921664373536939,-5.171790908260592e-5,0.0008394987206720873,7.204895416020011e-5,-0.0019144384985654776,-0.00016251626278391583,0.00640336283380807,0.0005401647678926045,-0.02952788094569912,-0.002481743600264998)
    else
        gamma(z)*sqrt(z/2œÄ)*exp(z)/z^z
    end
end



stirlingremainder(z::Number,N::Int) = (1+zeta(N))*gamma(N)/((2œÄ)^(N+1)*z^N)/stirlingseries(z)
stirlingremainder{T<:Number}(z::AbstractVector{T},N::Int) = (1+zeta(N))*gamma(N)/(2œÄ)^(N+1)./z.^N./stirlingseries(z)

Aratio(n::Int,Œ±::Float64,Œ≤::Float64) = exp((n/2+Œ±+1/4)*log1p(-Œ≤/(n+Œ±+Œ≤+1))+(n/2+Œ≤+1/4)*log1p(-Œ±/(n+Œ±+Œ≤+1))+(n/2+1/4)*log1p(Œ±/(n+1))+(n/2+1/4)*log1p(Œ≤/(n+1)))
Aratio(n::Number,Œ±::Number,Œ≤::Number) = (1+(Œ±+1)/n)^(n+Œ±+1/2)*(1+(Œ≤+1)/n)^(n+Œ≤+1/2)/(1+(Œ±+Œ≤+1)/n)^(n+Œ±+Œ≤+1/2)/(1+(zero(Œ±)+zero(Œ≤))/n)^(n+1/2)
Aratio(n::AbstractVector,Œ±::Number,Œ≤::Number) = [ Aratio(n[i],Œ±,Œ≤) for i=1:length(n) ]

Cratio(n::Int,Œ±::Float64,Œ≤::Float64) = exp((n+Œ±+1/2)*log1p((Œ±-Œ≤)/(2n+Œ±+Œ≤+2))+(n+Œ≤+1/2)*log1p((Œ≤-Œ±)/(2n+Œ±+Œ≤+2))-log1p((Œ±+Œ≤+2)/2n)/2)/sqrt(n)
Cratio(n::Number,Œ±::Number,Œ≤::Number) = n^(-1/2)*(1+(Œ±+1)/n)^(n+Œ±+1/2)*(1+(Œ≤+1)/n)^(n+Œ≤+1/2)/(1+(Œ±+Œ≤+2)/2n)^(2n+Œ±+Œ≤+3/2)
Cratio(n::AbstractVector,Œ±::Number,Œ≤::Number) = [ Cratio(n[i],Œ±,Œ≤) for i=1:length(n) ]


AnŒ±Œ≤(n::Number,Œ±::Number,Œ≤::Number) = 2^(Œ±+Œ≤+1)/(2n+Œ±+Œ≤+1)*exp(lgamma(n+Œ±+1)-lgamma(n+Œ±+Œ≤+1)+lgamma(n+Œ≤+1)-lgamma(n+1))
function AnŒ±Œ≤(n::Integer,Œ±::Number,Œ≤::Number)
    if n==0
        2^(Œ±+Œ≤+1)*beta(Œ±+1,Œ≤+1)
    else
        val = AnŒ±Œ≤(0,Œ±,Œ≤)
        for i=1:n
            val *= (i+Œ±)*(i+Œ≤)/(i+Œ±+Œ≤)/i*(2i+Œ±+Œ≤-1)/(2i+Œ±+Œ≤+1)
        end
        val
    end
end

function AnŒ±Œ≤(n::Integer,Œ±::Float64,Œ≤::Float64)
    if n+min(Œ±,Œ≤,Œ±+Œ≤,0) ‚â• 7.979120323411497
        2.^(Œ±+Œ≤+1)/(2n+Œ±+Œ≤+1)*stirlingseries(n+Œ±+1)*Aratio(n,Œ±,Œ≤)/stirlingseries(n+Œ±+Œ≤+1)*stirlingseries(n+Œ≤+1)/stirlingseries(n+one(Float64))
    else
        (n+1)*(n+Œ±+Œ≤+1)/(n+Œ±+1)/(n+Œ≤+1)*AnŒ±Œ≤(n+1,Œ±,Œ≤)*((2n+Œ±+Œ≤+3)/(2n+Œ±+Œ≤+1))
    end
end

AnŒ±Œ≤{T<:Integer}(n::AbstractVector{T},Œ±::Number,Œ≤::Number) = [ AnŒ±Œ≤(n[i],Œ±,Œ≤) for i=1:length(n) ]
AnŒ±Œ≤{T<:Integer}(n::AbstractMatrix{T},Œ±::Number,Œ≤::Number) = [ AnŒ±Œ≤(n[i,j],Œ±,Œ≤) for i=1:size(n,1), j=1:size(n,2) ]


"""
The Lambda function Œõ(z) = Œì(z+¬Ω)/Œì(z+1) for the ratio of gamma functions.
"""
Œõ(z::Number) = exp(lgamma(z+half(z))-lgamma(z+one(z)))
"""
For 64-bit floating-point arithmetic, the Lambda function uses the asymptotic series for œÑ in Appendix B of

    I. Bogaert and B. Michiels and J. Fostier, ùí™(1) computation of Legendre polynomials and Gauss‚ÄìLegendre nodes and weights for parallel computing, SIAM J. Sci. Comput., 34:C83‚ÄìC101, 2012.
"""
function Œõ(x::Float64)
    if x > 9.84475
        xp = x+0.25
        @horner(inv(xp^2),1.0,-1.5625e-02,2.5634765625e-03,-1.2798309326171875e-03,1.343511044979095458984375e-03,-2.432896639220416545867919921875e-03,6.7542375336415716446936130523681640625e-03)/sqrt(xp)
    else
        (x+1.0)*Œõ(x+1.0)/(x+0.5)
    end
end


"""
The Lambda function Œõ(z,Œª‚ÇÅ,Œª‚ÇÇ) = Œì(z+Œª‚ÇÅ)/Œì(z+Œª‚ÇÇ) for the ratio of gamma functions.
"""
Œõ(z::Number,Œª‚ÇÅ::Number,Œª‚ÇÇ::Number) = exp(lgamma(z+Œª‚ÇÅ)-lgamma(z+Œª‚ÇÇ))
function Œõ(x::Float64,Œª‚ÇÅ::Float64,Œª‚ÇÇ::Float64)
    if min(x+Œª‚ÇÅ,x+Œª‚ÇÇ) ‚â• 8.979120323411497
        exp(Œª‚ÇÇ-Œª‚ÇÅ+(x-.5)*log1p((Œª‚ÇÅ-Œª‚ÇÇ)/(x+Œª‚ÇÇ)))*(x+Œª‚ÇÅ)^Œª‚ÇÅ/(x+Œª‚ÇÇ)^Œª‚ÇÇ*stirlingseries(x+Œª‚ÇÅ)/stirlingseries(x+Œª‚ÇÇ)
    else
        (x+Œª‚ÇÇ)/(x+Œª‚ÇÅ)*Œõ(x+1.,Œª‚ÇÅ,Œª‚ÇÇ)
    end
end


CnŒª(n::Integer,Œª::Float64) = 2^Œª/sqrtpi*Œõ(n+Œª)
CnŒª(n::Integer,Œª::Number) = 2^Œª/sqrt(oftype(Œª,œÄ))*Œõ(n+Œª)
function broadcast{T<:Integer}(::typeof(CnŒª),n::UnitRange{T},Œª::Number)
    ret = Vector{typeof(Œª)}(length(n))
    ret[1] = CnŒª(first(n),Œª)
    for i=2:length(n)
        ret[i] = (n[i]+Œª-half(Œª))/(n[i]+Œª)*ret[i-1]
    end
    ret
end

function CnmŒª(n::Integer,m::Integer,Œª::Number)
    if m == 0
        CnŒª(n,Œª)
    else
        (Œª+m-1)/2/m*(m-Œª)/(n+Œª+m)*CnmŒª(n,m-1,Œª)
    end
end

function CnŒ±Œ≤(n::Integer,Œ±::Number,Œ≤::Number)
    if n==0
        2^(Œ±+Œ≤+1)*beta(Œ±+1,Œ≤+1)/œÄ
    else
        val = CnŒ±Œ≤(0,Œ±,Œ≤)
        for i=1:n
            val *= (i+Œ±)*(i+Œ≤)/(i+(Œ±+Œ≤+1)/2)/(i+(Œ±+Œ≤)/2)
        end
        val
    end
end

function CnŒ±Œ≤(n::Integer,Œ±::Float64,Œ≤::Float64)
    if n+min(Œ±,Œ≤) ‚â• 7.979120323411497
        stirlingseries(n+Œ±+1)/sqrtpi/stirlingseries(2n+Œ±+Œ≤+2)*Cratio(n,Œ±,Œ≤)*stirlingseries(n+Œ≤+1)
    else
        (n+(Œ±+Œ≤+3)/2)/(n+Œ≤+1)*(n+(Œ±+Œ≤+2)/2)/(n+Œ±+1)*CnŒ±Œ≤(n+1,Œ±,Œ≤)
    end
end

function CnmŒ±Œ≤(n::Integer,m::Integer,Œ±::Number,Œ≤::Number)
    if m == 0
        CnŒ±Œ≤(n,Œ±,Œ≤)
    else
        CnmŒ±Œ≤(n,m-1,Œ±,Œ≤)/2(2n+Œ±+Œ≤+m+1)
    end
end

function absf(Œ±::Number,Œ≤::Number,m::Int,Œ∏::Number)
    ret = zero(Œ∏)
    for l=0:m
        ret += pochhammer(half(Œ±)+Œ±,l)*pochhammer(half(Œ±)-Œ±,l)*pochhammer(half(Œ≤)+Œ≤,m-l)*pochhammer(half(Œ≤)-Œ≤,m-l)/factorial(l)/factorial(m-l)/sinpi(Œ∏/2)^(l+Œ±+half(Œ±))/cospi(Œ∏/2)^(m-l+Œ≤+half(Œ≤))
    end
    ret
end

function broadcast{T<:Number}(::typeof(absf),Œ±::Number,Œ≤::Number,m::Int,Œ∏::AbstractArray{T,1})
    ret = zero(Œ∏)
    cfs = zeros(T,m+1)
    for l=0:m
        @inbounds cfs[l+1] = pochhammer(half(Œ±)+Œ±,l)*pochhammer(half(Œ±)-Œ±,l)*pochhammer(half(Œ≤)+Œ≤,m-l)*pochhammer(half(Œ≤)-Œ≤,m-l)/factorial(l)/factorial(m-l)
    end
    @inbounds for i=1:length(Œ∏),l=0:m
        ret[i] += cfs[l+1]/sinpi(Œ∏[i]/2)^(l+Œ±+half(Œ±))/cospi(Œ∏[i]/2)^(m-l+Œ≤+half(Œ≤))
    end
    ret
end

function compute_absf!{T<:AbstractFloat}(ret::Vector{T},cfs::Matrix{T},Œ±::T,Œ≤::T,tempcos::Vector{T},tempsin::Vector{T},tempcosŒ≤sinŒ±::Vector{T},m::Int)
    @inbounds for i=1:length(ret)
        temp = inv(tempcos[i]^m*tempcosŒ≤sinŒ±[i])
        ret[i] = cfs[m+1,1]*temp
        for l=1:m
            temp *= tempcos[i]/tempsin[i]
            ret[i] += cfs[m+1,l+1]*temp
        end
    end
    ret
end

function compute_absf!{T<:AbstractFloat}(ret::Vector{T},tempsin::Vector{T},tempsinŒª::Vector{T},m::Int)
    for i=1:length(ret)
        @inbounds ret[i] = inv(tempsin[i]^m*tempsinŒª[i])
    end
    ret
end

function compute_umvm!{T<:AbstractFloat}(um::Vector{T},vm::Vector{T},cfs::Matrix{T},Œ±::T,Œ≤::T,tempcos::Vector{T},tempsin::Vector{T},tempcosŒ≤sinŒ±::Vector{T},m::Int,Œ∏::Vector{T},ir::UnitRange{Int64})
    @inbounds for i in ir
        temp = inv(tempcos[i]^m*tempcosŒ≤sinŒ±[i])
        œë = (Œ±+half(Œ±))/2-(Œ±+Œ≤+m+1)*Œ∏[i]/2
        um[i] = cfs[m+1,1]*cospi(œë)*temp
        vm[i] = cfs[m+1,1]*sinpi(œë)*temp
        @inbounds for l=1:m
            temp *= tempcos[i]/tempsin[i]
            œë = (Œ±+l+half(Œ±))/2-(Œ±+Œ≤+m+1)*Œ∏[i]/2
            um[i] += cfs[m+1,l+1]*cospi(œë)*temp
            vm[i] += cfs[m+1,l+1]*sinpi(œë)*temp
        end
    end
end

function compute_umvm!{T<:AbstractFloat}(um::Vector{T},vm::Vector{T},Œª::T,tempsinŒªm::Vector{T},m::Int,Œ∏::Vector{T},ir::UnitRange{Int64})
    @inbounds @simd for i in ir
        temp = inv(tempsinŒªm[i])
        œë = (m+Œª)*(half(T)-Œ∏[i])
        um[i] = cospi(œë)*temp
        vm[i] = sinpi(œë)*temp
    end
end

function findmindices!{T<:AbstractFloat}(RŒ±Œ≤jm::Vector{T},cfs::Matrix{T},Œ±::T,Œ≤::T,j::Int,m::Int,tempcos::Vector{T},tempsin::Vector{T},tempcosŒ≤sinŒ±::Vector{T})
    compute_absf!(RŒ±Œ≤jm,cfs,Œ±,Œ≤,tempcos,tempsin,tempcosŒ≤sinŒ±,m)
    scale!(RŒ±Œ≤jm,CnmŒ±Œ≤(j,m,Œ±,Œ≤))
    rmin,imin = findmin(RŒ±Œ≤jm)
    if rmin < eps(T)
        i‚ÇÅ = imin-1
        while i‚ÇÅ ‚â• 3
            if RŒ±Œ≤jm[i‚ÇÅ] < eps(T)
                i‚ÇÅ-=1
            else
                break
            end
        end
        i‚ÇÇ = imin+1
        while i‚ÇÇ ‚â§ length(RŒ±Œ≤jm)-2
            if RŒ±Œ≤jm[i‚ÇÇ] < eps(T)
                i‚ÇÇ+=1
            else
                break
            end
        end
        return i‚ÇÅ,i‚ÇÇ
    else
        return 1,0# error("There are no indices such that the interior asymptotic formula is valid.")# but adding an error is type-unstable :(.
    end
end

function findmindices!{T<:AbstractFloat}(RŒ±Œ≤jm::Vector{T},Œª::T,j::Int,m::Int,tempsin::Vector{T},tempsinŒª::Vector{T})
    compute_absf!(RŒ±Œ≤jm,tempsin,tempsinŒª,m)
    scale!(RŒ±Œ≤jm,CnmŒª(j,m,Œª))
    rmin,imin = findmin(RŒ±Œ≤jm)
    if rmin < eps(T)
        i‚ÇÅ = imin-1
        while i‚ÇÅ ‚â• 3
            if RŒ±Œ≤jm[i‚ÇÅ] < eps(T)
                i‚ÇÅ-=1
            else
                break
            end
        end
        i‚ÇÇ = imin+1
        while i‚ÇÇ ‚â§ length(RŒ±Œ≤jm)-2
            if RŒ±Œ≤jm[i‚ÇÇ] < eps(T)
                i‚ÇÇ+=1
            else
                break
            end
        end
        return i‚ÇÅ,i‚ÇÇ
    else
        return 1,0# error("There are no indices such that the interior asymptotic formula is valid.")# but adding an error is type-unstable :(.
    end
end

# initialization methods

function init_cfs{T<:AbstractFloat}(Œ±::T,Œ≤::T,M::Int)
    cfs = zeros(T,M+1,M+1)
    @inbounds for m=0:M,l=0:m
        cfs[m+1,l+1] = pochhammer(half(Œ±)+Œ±,l)*pochhammer(half(Œ±)-Œ±,l)*pochhammer(half(Œ≤)+Œ≤,m-l)*pochhammer(half(Œ≤)-Œ≤,m-l)/factorial(l)/factorial(m-l)
    end
    cfs
end

function init_c‚ÇÅc‚ÇÇ!(c‚ÇÅ::Vector,c‚ÇÇ::Vector,a::Vector,b::Vector,j‚ÇÅ::Int,j‚ÇÇ::Int)
    @inbounds for j=1:j‚ÇÅ-1 c‚ÇÅ[j] = 0 end
    @inbounds for j=j‚ÇÅ:j‚ÇÇ c‚ÇÅ[j] = a[j]*b[j] end
    @inbounds for j=j‚ÇÇ+1:length(c‚ÇÅ) c‚ÇÅ[j] = 0 end
    copy!(c‚ÇÇ,c‚ÇÅ)
end

function init_c‚ÇÅc‚ÇÇ!(c‚ÇÅ::Vector,c‚ÇÇ::Vector,u::Vector,v::Vector,c::Vector,i‚ÇÅ::Int,i‚ÇÇ::Int)
    @inbounds for i=1:i‚ÇÅ-1
        c‚ÇÅ[i] = 0
        c‚ÇÇ[i] = 0
    end
    @inbounds for i=i‚ÇÅ:i‚ÇÇ
        c‚ÇÅ[i] = u[i]*c[i]
        c‚ÇÇ[i] = v[i]*c[i]
    end
    @inbounds for i=i‚ÇÇ+1:length(c‚ÇÅ)
        c‚ÇÅ[i] = 0
        c‚ÇÇ[i] = 0
    end
end


"""
Modified Chebyshev moments of the first kind with respect to the Jacobi weight:

    ‚à´‚Çã‚ÇÅ‚Å∫¬π T_n(x) (1-x)^Œ±(1+x)^Œ≤ dx.

"""
function chebyshevjacobimoments1{T<:AbstractFloat}(N::Int,Œ±::T,Œ≤::T)
    Œº = zeros(T,N)
    N > 0 && (Œº[1] = 2.^(Œ±+Œ≤+1)*beta(Œ±+1,Œ≤+1))
    if N > 1
        Œº[2] = Œº[1]*(Œ≤-Œ±)/(Œ±+Œ≤+2)
        for i=1:N-2
            @inbounds Œº[i+2] = (2(Œ≤-Œ±)*Œº[i+1]-(Œ±+Œ≤-i+2)*Œº[i])/(Œ±+Œ≤+i+2)
        end
    end
    Œº
end

"""
Modified Chebyshev moments of the second kind with respect to the Jacobi weight:

    ‚à´‚Çã‚ÇÅ‚Å∫¬π U_n(x) (1-x)^Œ±(1+x)^Œ≤ dx.

"""
function chebyshevjacobimoments2{T<:AbstractFloat}(N::Int,Œ±::T,Œ≤::T)
    Œº = zeros(T,N)
    N > 0 && (Œº[1] = 2.^(Œ±+Œ≤+1)*beta(Œ±+1,Œ≤+1))
    if N > 1
        Œº[2] = 2Œº[1]*(Œ≤-Œ±)/(Œ±+Œ≤+2)
        for i=1:N-2
            @inbounds Œº[i+2] = (2(Œ≤-Œ±)*Œº[i+1]-(Œ±+Œ≤-i)*Œº[i])/(Œ±+Œ≤+i+2)
        end
    end
    Œº
end

"""
Compute Jacobi expansion coefficients in P‚Çô^(Œ±+1,Œ≤) given Jacobi expansion coefficients in P‚Çô^(Œ±,Œ≤) in-place.
"""
function incrementŒ±!(c::AbstractVector,Œ±,Œ≤)
    Œ±Œ≤,N = Œ±+Œ≤,length(c)
    N > 1 && (c[1] -= (Œ≤+1)/(Œ±Œ≤+3)*c[2])
    @inbounds for i=2:N-1 c[i] = (Œ±Œ≤+i)/(Œ±Œ≤+2i-1)*c[i] - (Œ≤+i)/(Œ±Œ≤+2i+1)*c[i+1] end
    N > 1 && (c[N] *= (Œ±Œ≤+N)/(Œ±Œ≤+2N-1))
    c
end

"""
Compute Jacobi expansion coefficients in P‚Çô^(Œ±,Œ≤+1) given Jacobi expansion coefficients in P‚Çô^(Œ±,Œ≤) in-place.
"""
function incrementŒ≤!(c::AbstractVector,Œ±,Œ≤)
    Œ±Œ≤,N = Œ±+Œ≤,length(c)
    N > 1 && (c[1] += (Œ±+1)/(Œ±Œ≤+3)*c[2])
    @inbounds for i=2:N-1 c[i] = (Œ±Œ≤+i)/(Œ±Œ≤+2i-1)*c[i] + (Œ±+i)/(Œ±Œ≤+2i+1)*c[i+1] end
    N > 1 && (c[N] *= (Œ±Œ≤+N)/(Œ±Œ≤+2N-1))
    c
end

"""
Compute Jacobi expansion coefficients in P‚Çô^(Œ±+1,Œ±+1) given Jacobi expansion coefficients in P‚Çô^(Œ±,Œ±) in-place.
"""
function incrementŒ±Œ≤!(c::AbstractVector,Œ±,Œ≤)
    @assert Œ± == Œ≤
    N = length(c)
    N > 2 && (c[1] -= (Œ±+2)/(4Œ±+10)*c[3])
    @inbounds for i=2:N-2 c[i] = (2Œ±+i)*(2Œ±+i+1)/(2Œ±+2i-1)/(2Œ±+2i)*c[i] - (Œ±+i+1)/(4Œ±+4i+6)*c[i+2] end
    N > 1 && (c[N-1] *= (2Œ±+N-1)*(2Œ±+N)/(2Œ±+2N-3)/(2Œ±+2N-2))
    N > 0 && (c[N] *= (2Œ±+N)*(2Œ±+N+1)/(2Œ±+2N-1)/(2Œ±+2N))
    c
end

"""
Compute Jacobi expansion coefficients in P‚Çô^(Œ±-1,Œ≤) given Jacobi expansion coefficients in P‚Çô^(Œ±,Œ≤) in-place.
"""
function decrementŒ±!(c::AbstractVector,Œ±,Œ≤)
    Œ±Œ≤,N = Œ±+Œ≤,length(c)
    N > 1 && (c[N] *= (Œ±Œ≤+2N-2)/(Œ±Œ≤+N-1))
    @inbounds for i=N-1:-1:2 c[i] = (Œ±Œ≤+2i-2)/(Œ±Œ≤+i-1)*c[i] + (Œ±Œ≤+2i-2)/(Œ±Œ≤+2i)*(Œ≤+i)/(Œ±Œ≤+i-1)*c[i+1] end
    N > 1 && (c[1] += (Œ≤+1)/(Œ±Œ≤+2)*c[2])
    c
end

"""
Compute Jacobi expansion coefficients in P‚Çô^(Œ±,Œ≤-1) given Jacobi expansion coefficients in P‚Çô^(Œ±,Œ≤) in-place.
"""
function decrementŒ≤!(c::AbstractVector,Œ±,Œ≤)
    Œ±Œ≤,N = Œ±+Œ≤,length(c)
    N > 1 && (c[N] *= (Œ±Œ≤+2N-2)/(Œ±Œ≤+N-1))
    @inbounds for i=N-1:-1:2 c[i] = (Œ±Œ≤+2i-2)/(Œ±Œ≤+i-1)*c[i] - (Œ±Œ≤+2i-2)/(Œ±Œ≤+2i)*(Œ±+i)/(Œ±Œ≤+i-1)*c[i+1] end
    N > 1 && (c[1] -= (Œ±+1)/(Œ±Œ≤+2)*c[2])
    c
end

"""
Compute Jacobi expansion coefficients in P‚Çô^(Œ±-1,Œ±-1) given Jacobi expansion coefficients in P‚Çô^(Œ±,Œ±) in-place.
"""
function decrementŒ±Œ≤!(c::AbstractVector,Œ±,Œ≤)
    @assert Œ± == Œ≤
    N = length(c)
    N > 0 && (c[N] *= (2Œ±+2N-3)*(2Œ±+2N-2)/(2Œ±+N-2)/(2Œ±+N-1))
    N > 1 && (c[N-1] *= (2Œ±+2N-5)*(2Œ±+2N-4)/(2Œ±+N-3)/(2Œ±+N-2))
    @inbounds for i=N-2:-1:2 c[i] = (2Œ±+2i-3)*(2Œ±+2i-2)/(2Œ±+i-2)/(2Œ±+i-1)*(c[i] + (Œ±+i)/(4Œ±+4i+2)*c[i+2]) end
    N > 2 && (c[1] += (Œ±+1)/(4Œ±+6)*c[3])
    c
end


function modŒ±Œ≤(Œ±)
    if -0.5 < Œ± ‚â§ 0.5
        a = Œ±
    else
        a = Œ±%1
        a > 0.5 && (a-=1)
        a ‚â§ -0.5 && (a+=1)
    end
    a
end

function modŒª(Œª)
    if 0 ‚â§ Œª < 1
        l = Œª
    else
        l = Œª%1
        l < 0 && (l+=1)
    end
    l
end

function tosquare!(ret::AbstractVector,Œ±,Œ≤)
    a,b = modŒ±Œ≤(Œ±),modŒ±Œ≤(Œ≤)
    A,B = Œ±-a,Œ≤-b
    if Œ± ‚â§ -0.5 && Œ≤ ‚â§ -0.5
        incrementŒ±!(ret,Œ±,Œ≤)
        incrementŒ≤!(ret,a,Œ≤)
    elseif Œ± ‚â§ -0.5
        incrementŒ±!(ret,Œ±,Œ≤)
        for j=B:-1:1
            decrementŒ≤!(ret,a,j+b)
        end
    elseif Œ≤ ‚â§ -0.5
        incrementŒ≤!(ret,Œ±,Œ≤)
        for i=A:-1:1
            decrementŒ±!(ret,i+a,b)
        end
    else
        for i=A:-1:1
            decrementŒ±!(ret,i+a,Œ≤)
        end
        for j=B:-1:1
            decrementŒ≤!(ret,a,j+b)
        end
    end
    ret
end

function fromsquare!(ret::AbstractVector,Œ±,Œ≤)
    a,b = modŒ±Œ≤(Œ±),modŒ±Œ≤(Œ≤)
    A,B = Œ±-a,Œ≤-b
    if Œ± ‚â§ -0.5 && Œ≤ ‚â§ -0.5
        decrementŒ±!(ret,a,b)
        decrementŒ≤!(ret,Œ±,b)
    elseif Œ± ‚â§ -0.5
        decrementŒ±!(ret,a,b)
        for j=0:B-1
            incrementŒ≤!(ret,Œ±,j+b)
        end
    elseif Œ≤ ‚â§ -0.5
        decrementŒ≤!(ret,a,b)
        for i=0:A-1
            incrementŒ±!(ret,i+a,Œ≤)
        end
    else
        for i=0:A-1
            incrementŒ±!(ret,i+a,b)
        end
        for j=0:B-1
            incrementŒ≤!(ret,Œ±,j+b)
        end
    end
    ret
end


function toline!(ret::AbstractVector,Œ±,Œ≤)
    @assert Œ± == Œ≤
    a,b = modŒ±Œ≤(Œ±),modŒ±Œ≤(Œ≤)
    A,B = Œ±-a,Œ≤-b
    if Œ± ‚â§ -0.5
        incrementŒ±Œ≤!(ret,Œ±,Œ≤)
    else
        for i=A:-1:1
            decrementŒ±Œ≤!(ret,i+a,i+a)
        end
    end
    ret
end

function fromline!(ret::AbstractVector,Œ±,Œ≤)
    @assert Œ± == Œ≤
    a,b = modŒ±Œ≤(Œ±),modŒ±Œ≤(Œ≤)
    A,B = Œ±-a,Œ≤-b
    if Œ± ‚â§ -0.5
        decrementŒ±Œ≤!(ret,a,b)
    else
        for i=0:A-1
            incrementŒ±Œ≤!(ret,i+a,i+a)
        end
    end
    ret
end
