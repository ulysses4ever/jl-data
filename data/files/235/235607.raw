using JFinEALE
using Targe2                    # automatic triangulation

## Two-dimensional heat transfer with convection: convergence study
#

## Description
#
# Consider a plate of uniform thickness, measuring 0.6 m by 1.0 m. On one
# short edge the temperature is fixed at 100 °C, and on one long edge the
# plate is perfectly insulated so that the heat flux is zero through that
# edge. The other two edges are losing heat via convection to an ambient
# temperature of 0 °C. The thermal conductivity of the plate is 52.0 W/(m
# .°K), and the convective heat transfer coefficient is 750 W/(m^2.°K).
# There is no internal generation of heat. Calculate the temperature 0.2 m
# along the un-insulated long side, measured from the intersection with the
# fixed temperature side. The reference result is 18.25 °C.

##
# The reference temperature at the point A  is 18.25 °C according to the
# NAFEMS publication ( hich cites the book Carslaw, H.S. and J.C. Jaeger,
# Conduction of Heat in Solids. 1959: Oxford University Press).

##
# The present  tutorial will investigate the reference temperature  and it
# will attempt to  estimate the  limit value more precisely using a
# sequence of meshes and Richardson's extrapolation.

## Solution
#

kappa=[52 0; 0 52]*phun("W/(M*K)"); # conductivity matrix
h=750*phun("W/(M^2*K)");# surface heat transfer coefficient
Width=0.6*phun("M");# Geometrical dimensions
Height=1.0*phun("M");
HeightA=0.2*phun("M");
Thickness=1.0*phun("M");
tolerance =Width/1000;


println("""
Two-dimensional heat transfer with convection: convergence study.
Unstructured quadratic triangle mesh.
        """
        )
        t0 = time()

modeldata=[]
resultsTempA=JFFlt[]

mesh_size  =  0.4;

for nref=1:3
    mesh_size  =  mesh_size/2
    input="""
    curve 1 line 0 0 0.6 0 
    curve 2 line 0.6 0 0.6 0.2 
    curve 3 line 0.6 0.2 0.6 1.0 
    curve 4 line 0.6 1.0 0 1.0 
    curve 5 line 0 1.0 0 0 
    subregion 1  property 1 boundary 1 2 3 4 5 
    m-ctl-point constant   $mesh_size 
    """
    XY,triconn,trigroups,edgeconn,edgegroups=Targe2.targe2mesher(input; quadratic = true)
    fens=FENodeSet(xyz=XY)
    fes=FESetT6(conn=triconn)
    bfes= FESetL3(conn=edgeconn)

    # Define boundary conditions

    ##
    # The prescribed temperature is applied along edge 1 (the bottom
    # edge in Figure 1)..

    l1 =connectednodes(subset(bfes,edgegroups[1]))
    essential1= dmake(node_list=l1,temperature=100);


    ##
    # The convection boundary condition is applied along the edges
    # 2,3,4. The elements along the boundary are quadratic line
    # elements L3. The order-four Gauss quadrature is sufficiently
    # accurate.
    convection1= dmake(fes=subset(bfes,[edgegroups[2],edgegroups[3],edgegroups[4]]),
                       integration_rule=GaussRule(dim=1,order=3),
                       ambient_temperature=0,surface_transfer_coefficient=h);

    # Make model data
    modeldata= dmake(fens= fens,
                     region=[dmake(conductivity=kappa,
                                   fes=fes,integration_rule=TriRule(npts=3))],
                     boundary_conditions=dmake(essential=[essential1],convection =[convection1]));


    # Call the solver
    modeldata=JFinEALE.AlgoHeatDiffusionModule.steadystate(modeldata)

    println("Total time elapsed = ",time() - t0,"s")

    l4 =fenodeselect(fens; box=[Width Width HeightA HeightA], inflate =tolerance)


    geom=modeldata["geom"]
    Temp=modeldata["temp"]
    

    ##
    # Collect the temperature  at the point A  [coordinates
    # (Width,HeightA)].
    push!(resultsTempA,Temp.values[l4][1]);

end

## 
# These are the computed results for the temperature at point A:
println("$( resultsTempA  )")

# Postprocessing
geom=modeldata["geom"]
Temp=modeldata["temp"]
region=modeldata["region"]
vtkexportmesh ("aT6.vtk", region[1]["fes"].conn, [geom.values Temp.values/100],
               JFinEALE.MeshExportModule.T6; scalars=Temp.values, scalars_name ="Temperature")

# ## 
# # Richardson extrapolation is used to estimate the true solution from the
# # results for the finest three meshes.
#    [xestim, beta] = richextrapol(results(end-2:end),mesh_sizes(end-2:end));
#     disp(['Estimated true solution for temperature at A: ' num2str(xestim) ' degrees'])

# ## 
# # Plot the estimated true error.
#    figure
#     loglog(mesh_sizes,abs(results-xestim)/xestim,'bo-','linewidth',3)
#     grid on
#      xlabel('log(mesh size)')
#     ylabel('log(|estimated temperature error|)')
#     set_graphics_defaults

# ## 
# # The estimated true error has  a slope of approximately 4 on the log-log
# scale.
# ## 
# # Plot the absolute values of the approximate error (differences  of
# # successive solutions).
#     figure
#     loglog(mesh_sizes(2:end),abs(diff(results)),'bo-','linewidth',3)
#     Thanksgrid on
#     xlabel('log(mesh size)')
#     ylabel('log(|approximate temperature error|)')
#     set_graphics_defaults


## Discussion
# 
## 
# The last segment  of the approximate error curve is close to the slope of
# the estimated true error. Nevertheless, it would have been more
# reassuring if the  three successive approximate errors  were located more
# closely on a straight line.

## 
# The use of uniform mesh-size meshes is sub optimal: it would be more
# efficient to use graded meshes. The tutorial pub_T4NAFEMS_conv_graded
# addresses use of graded meshes  in convergence studies.

