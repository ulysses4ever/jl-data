# NOTE: this is part of the @cuda test set, but needs to be top-level
module KernelModule
    export do_more_nothing
    @target ptx do_more_nothing() = return nothing
end

## LLVM IR

@target ptx foo() = return nothing
ir = sprint(io->code_llvm(io, foo, (),
                          #=strip_ir_metadata=#true, #=dump_module=#true))

# module should only contain our function + a generic call wrapper
@test length(matchall(r"define .+", ir)) == 2
@test ismatch(r"define void @julia_foo_.+\(\) #0 \{", ir)
@test ismatch(r"define %jl_value_t\* @jlcall_", ir)
# module should be created for the PTX back-end
@test contains(ir, "!\"Julia Codegen Target\", !\"ptx\"")
# function should be generated by the PTX back-end
@test ismatch(r"attributes #0 = \{.+\"jl_cgtarget\"=\"ptx\".+\}", ir)
# GC frame ref should have been optimized away
# NOTE: disabled now that the module only gets optimized later on,
#       which means the frame ref is still part of code_llvm
#@test !contains(ir, "jl_get_ptls_states")


## PTX assembly

# TODO: PTX assembly generation / code_native
# -> test if foo and bar doesn't end up in same PTX module

# TODO: assert .entry
# TODO: assert devfun non .entry


@target ptx function throw_exception()
    throw(DivideError())
end
ir = sprint(io->code_llvm(io, throw_exception, ()))

# exceptions should get lowered to a plain trap...
@test contains(ir, "llvm.trap")
# not a jl_throw referencing a jl_value_t representing the exception
@test !contains(ir, "jl_value_t")
@test !contains(ir, "jl_throw")

# return values
@target ptx retint() = return 1
@test_throws ErrorException @cuda (1, 1) retint()
# TODO: test whether child functions can return values
#       (testing blocked by #15276 / #15967)

# delayed binding lookup (due to noexisting global)
@target ptx ref_nonexisting() = nonexisting
@test_throws ErrorException code_native(DevNull, ref_nonexisting, ())

# generic call to nonexisting function
@target ptx call_nonexisting() = nonexisting()
@test_throws ErrorException code_native(DevNull, call_nonexisting, ())

# cannot call PTX functions
@target ptx call_nonptx() = return nothing
@test_throws ErrorException call_nonptx()

# bug: generate code twice for the same kernel (jl_to_ptx wasn't idempotent)
@target ptx codegen_twice() = return nothing
code_native(DevNull, codegen_twice, ())
code_native(DevNull, codegen_twice, ())

# bug: depending on a child function from multiple parents resulted in
#      the child only being present once
# NOTE: disabled because of #15276 / #15967
let
    @target ptx @noinline function child()
        return 0
    end

    @target ptx function parent1(arr::Ptr{Int64})
        i = child()
        unsafe_store!(arr, i, i)
        return nothing
    end
    # asm = sprint(io->code_native(io, parent1, (Ptr{Int64},)))
    # @test ismatch(r".visible .func .+ julia_child", asm)


    @target ptx function parent2(arr::Ptr{Int64})
        i = child()+1
        unsafe_store!(arr, i, i)

        return nothing
    end
    # asm = sprint(io->code_native(io, parent2, (Ptr{Int64},)))
    # @test ismatch(r".visible .func .+ julia_child", asm)
end

# bug: similar, but slightly different issue as above
#      in the case of two child functions
# NOTE: disabled because of #15276 / #15967
let
    @target ptx @noinline function child1()
        return 0
    end

    @target ptx @noinline function child2()
        return 0
    end

    @target ptx function parent1(arry::Ptr{Int64})
        i = child1() + child2()
        unsafe_store!(arry, i, i)

        return nothing
    end
    # asm = sprint(io->code_native(io, parent1, (Ptr{Int64},)))


    @target ptx function parent2(arry::Ptr{Int64})
        i = child1() + child2()
        unsafe_store!(arry, i, i+1)

        return nothing
    end
    # asm = sprint(io->code_native(io, parent2, (Ptr{Int64},)))
end
