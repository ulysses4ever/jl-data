# wrapper for arules.R

using RCall
using DataFrames


function init_arules()
    R"""
    test1p1 <- 1 + 1
    """
    if 2 != (@rget test1p1)
        stop("You must have R installed in order to use this package")
    end

    R"""
    if (\"arules\" %in% installed.packages() == FALSE) {
        install.packages(\"arules\", dependencies = TRUE, repos = \"http://cran.r-project.org\")
    }
    library(arules)

    all_factors <- function(dat) {
        p <- ncol(dat)
        out <- dat
        for (j in 1:p) {
            out[, j] <- factor(dat[, j])
        }
        return(out)
    }


    character_columns <- function(dat) {
        p <- ncol(dat)
        for (j in 1:p) {
            if (is.factor(dat[, j])) {
                dat[, j] <- as.character(dat[, j])
            }

        }
        return(dat)
    }
    """
    return nothing
end

init_arules()

# This is a simple function that assures we don't have strings
# with a " => " as part of them. This is something R outputs
# when it creates rules, and we'll uses it's presence to split
# rules generated by R into left-hand side (lhs) and rhs.
function sanitize_input(dat)
    out = deepcopy(dat)
    # p = ncol(out)
    # for j = 1:p
    #     if eltype(out[:, j]) <: Number
    #         println(j)
    #         println("Numeric column...")
    #         continue
    #     end
    #     out[:, j] = map(x -> replace(x, " => ", " "), out[:, j])
    # end
    out
end


"""
    make_transactions(dat::DataFrame, transact_name::String, arules)

This function takes a Julia dataframe and creates an R transactions object, which
isn't returned, but lives in the R session and can be used from Julia using the
appropriate functions in this package. For example, we can call `apriori()` on it.
"""
function make_transactions(dat::DataFrame, transact_name::String, arules = true)
    # sanitize_input!(dat)
    @rput dat
    rcode = "
    dat <- all_factors(dat)
    $transact_name <- as(dat, \"transactions\")
    "
    # evaluate the above R code, which generates a transactions
    # whose name is specified by the `transname` argument
    reval(rcode);
end


function split_rule!(dat)
    n = size(dat, 1)
    dat[:lhs] = Array{String,1}(n)
    dat[:rhs] = Array{String,1}(n)
    for i = 1:n
        dat[i, :lhs], dat[i, :rhs] = split(dat[i, :rules], " => ")
    end
end


function apriori(transact_name::String, supp = 0.2, conf = 0.01)
    rcode = "
    rules1 <- apriori($transact_name, parameter = list(supp = $supp,
                                                       conf = $conf,
                                                       target = \"rules\"))
    rules2 <- if (length(rules1) == 0) data.frame() else rules1
    rules3 <- character_columns(as(rules2, \"data.frame\"))
    "
    reval(rcode);
    rules_df = @rget rules3;
    split_rule!(rules_df);
    rules_df = rules_df[:, [:lhs, :rhs, :support, :confidence, :lift]]
    rules_df
end

d = readtable("./data/adult.csv")
d2 = sanitize_input(d)
make_transactions(d2, "adult")
a = apriori("adult");
