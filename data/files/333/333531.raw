module Debian
export debian_file, control, locations, make, prepare_git_sources, rules, publish, change

using Docker
using Convenience

const email = "rc-softdev@ucl.ac.uk"
const maintainer = "Research Software Development Team"
const launchpadID = "m-davezac"
const PPA = "ppa"
const gpgkey = "ubuntu-pkg"

function debian_file(name, args...)
  dir = "debian"
  ispath(dir) || mkdir(dir)
  isdir(dir) || error("$dir exists but is not a directory")
  open(joinpath(dir, name), "w") do stream
    for u in args
      println(stream, u)
    end
  end
end

# Creates a control file for a source package declaring one or more binary packages
# >>> control(package, version;
#     build_deps=build_deps, homepage=homepage,
#     # binary package description, package name defaults to same as source
#     description="Library to do threads the intel way",
#     # development package
#     package="$package-dev",
#     architecture="all",
#     depends="$package",
#     description="Headers for intel threading library",
#     # debug package
#     package="$package-dbg",
#     description="Debug libraries for intel threading"
#   )
function control(package::String, version::String; section::String="devel",
    priority::String="optional", build_depends=String[], homepage::String="",
    maintainer::String=Debian.maintainer, email::String=Debian.email, kwargs...)

    # Transform variable keyword arguments into binary packages
    current = Dict{String, String}()
    binaries = Dict{String, String}[]
    for (key, value) in kwargs
      key = lowercase(string(key))
      if isa(value, Array) || isa(value, Tuple)
        value = join(value, if key == "description"; "\n" else ", " end)
      else
        value = string(value)
      end

      if key == "package" && length(current) > 0
        if !haskey(current, "package")
          current["package"] = package
        end
        push!(binaries, current)
        current = {key => string(value)}
      else
        current[key] = value
      end
    end
    if length(current) > 0; push!(binaries, current) end
    if length(binaries) == 0; push!(binaries, {"package" => package}) end

    # Create list of lines
    args = String[
      "Source: $package",
      "Section: $section",
      "Priority: $priority",
      "Maintainer: $maintainer <$email>",
      "Standards-Version: 3.9.5",
    ]
    if length(homepage) > 0; push!(args, "Homepage: $homepage"); end
    if isa(build_depends, Array) || isa(build_depends, Tuple)
      build_depends = join(build_depends, ", ")
    end
    if length(build_depends) > 0
      push!(args, "Build-Depends: debhelper (>=9), $build_depends")
    else
      push!(args, "Build-Depends: debhelper (>=9)")
    end

    for binary in binaries
      name = pop!(binary, "package", package)
      desc = pop!(binary, "description", "")
      arch = pop!(binary, "architecture", "any")
      push!(args, "")
      push!(args, "Package: $name")
      push!(args, "Architecture: $arch")
      for (key, value) in binary
        key = "$(uppercase(key[1]))$(lowercase(key[2:end]))"
        push!(args, "$key: $value")
      end
      if length(desc) > 0; push!(args, "Description: $desc"); end
    end

    # now call function
    debian_file("control", args...)
end

function change(package, version, args...; maintainer::String=Debian.maintainer,
        email::String=Debian.email, urgency::String="low", distribution::String="unstable")
  if length(args) == 0
    args = ["  * No reported changes"]
  else
    args = ["  * $u" for u in args]
  end
  debian_file("changelog",
    "$package ($version) $distribution; urgency=$urgency",
    "",
    args...,
    "",
    " -- $maintainer <$email>  $(strftime("%a, %d %b %Y %T %z", time()))"
  )
end

# Computes a bunch of standard names
function locations(package, version, workdir::String="workspace")
  const name = "$(package)-$version"
  const sourcedir = abspath(joinpath(workdir, name))
  const builddir = abspath(joinpath(workdir, "build", name))
  const tarfile = joinpath(builddir, "$(package)_$version.orig.tar.gz")
  name, sourcedir, builddir, tarfile
end

# Creates the source package and builds it cum binaries
function make(machine::Docker.ActiveMachine, package::String, version::String;
    image::String="packaging", workdir::String="workspace", clean::Bool=false, architecture="amd64",
    build_depends=[], license::String="")
  const name, sourcedir, builddir, tarfile = locations(package, version, workdir)
  machine = deepcopy(machine)

  machine.volumes[builddir] = "/$name"
  machine.workdir = "/$name/$name"

  env = {:LOGNAME => :RSDT, :DEBFULLNAME => maintainer, :EMAIL => email}
  create_image = Docker.image(machine, package, build_depends; image=image, env=env)

  cmd = "dh_make -i -a -r cdbs -l -f /$name/$(basename(tarfile))" *
    if length(license) > 0; " -c $license"; else "" end
  dhmake = command(machine, STDOUT, cmd; image=package, rm=true) do
    ""
  end
  args = if clean; "-tc"; else "" end * " -a$architecture"
  dhbuild = command(machine, "dpkg-buildpackage $args"; image=package, rm=true)
  debuild = command(machine, "debuild -us -uc -S"; image=package, rm=true)
  println("AM HERE ********************************")
  [create_image, dhmake, dhbuild, debuild]
end

function publish(machine::Docker.ActiveMachine, package::String, version::String;
  image::String="packaging", workdir::String="workspace", ppa::String=PPA, id::String=launchpadID)
  const name, sourcedir, builddir, tarfile = locations(package, version, workdir)
  const debname = "$(package)_$version"
  machine = deepcopy(machine)
  machine.volumes[builddir] = "/$name"
  machine.workdir = "/$name"
  open(joinpath(builddir, "secret-$gpgkey.asc"), "w") do file
    write(file, readall(`gpg --export-secret-keys -a $gpgkey`))
  end
  open(joinpath(builddir, "$gpgkey.asc"), "w") do file
    write(file, readall(`gpg --export -a $gpgkey`))
  end
  command(machine, STDOUT; image=image, rm=true) do
    "gpg --allow-secret-key-import --import secret-$gpgkey.asc\n" *
    "gpg --import $gpgkey.asc\n" *
    "debsign --re-sign $(debname)_source.changes -k $gpgkey\n" *
    "dput ppa:$id/$PPA $(debname)_source.changes"
  end
end

# Prepare git sources
function prepare_git_sources(
    package::String, version::String, url::String; workdir::String="workspace")
  const name, sourcedir, builddir, tarfile = locations(package, version, workdir)

  create_or_use_directory(sourcedir)
  create_or_use_directory(builddir)

  isdir(joinpath(sourcedir, ".git")) || run(`git clone $url $sourcedir`)
  cd(sourcedir) do
    if readchomp(`git tag -l v$version`) == "v$version"
      run(`git checkout v$version`)
    else
      run(`git checkout $version`)
    end
  end
  cd(workdir) do
    run(`tar -czvf $tarfile --exclude .git* $name`)
  end
  cd(builddir) do
    run(`tar -xvf $tarfile`)
  end
  builddir, tarfile
end

function rules(build::Symbol, args...; extra_flags::String="")
  if build == :cmake || build == :CMake
    specials = String["include /usr/share/cdbs/1/class/cmake.mk"]
    if length(extra_flags) > 0
      push!(specials, "DEB_CMAKE_EXTRA_FLAGS=$extra_flags")
    end
  elseif build == :make
    specials = String["include /usr/share/cdbs/1/class/makefile.mk"]
  end
  debian_file("rules",
    "#! /usr/bin/make -f",
    "include /usr/share/cdbs/1/rules/debhelper.mk",
    specials..., args...
  )
end
end
