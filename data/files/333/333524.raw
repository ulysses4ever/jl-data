module Debian
export debian_file, control, locations, make, prepare_git_sources

using Docker
using Convenience

const email = "rc-softdev@ucl.ac.uk"
const maintainer = "Research Software Development Team"

function debian_file(name, args...)
  dir = "debian"
  ispath(dir) || mkdir(dir)
  isdir(dir) || error("$dir exists but is not a directory")
  open(joinpath(dir, name), "w") do stream
    for u in args
      println(stream, u)
    end
  end
end

# Creates a control file for a source package declaring one or more binary packages
# >>> control(package, version;
#     build_deps=build_deps, homepage=homepage,
#     # binary package description, package name defaults to same as source
#     description="Library to do threads the intel way",
#     # development package
#     package="$package-dev",
#     architecture="all",
#     depends="$package",
#     description="Headers for intel threading library",
#     # debug package
#     package="$package-dbg",
#     description="Debug libraries for intel threading"
#   )
function control(package::String, version::String; section::String="devel",
    priority::String="optional", build_depends=String[], homepage::String="",
    maintainer::String=Debian.maintainer, email::String=Debian.email, kwargs...)

    # Transform variable keyword arguments into binary packages
    current = Dict{String, String}()
    binaries = Dict{String, String}[]
    for (key, value) in kwargs
      key = lowercase(string(key))
      if isa(value, Array) || isa(value, Tuple)
        value = join(value, if key == "description"; "\n" else ", " end)
      else
        value = string(value)
      end

      if key == "package"
        if length(current) > 0
          if !haskey(current, "package")
            current["package"] = package
          end
          push!(binaries, current)
          current = {key => string(value)}
        end
      else
        current[key] = value
      end
    end
    if length(current) > 0; push!(binaries, current) end
    if length(binaries) == 0; push!(binaries, {"package" => package}) end

    # Create list of lines
    args = String[
      "Source: $package",
      "Section: $section",
      "Priority: $priority",
      "Maintainer: $maintainer <$email>",
      "Standards-Version: 3.9.4",
    ]
    if length(homepage) > 0; push!(args, "Homepage: $homepage"); end
    if isa(build_depends, Array) || isa(build_depends, Tuple)
      build_depends = join(build_depends, ", ")
    end
    if length(build_depends) > 0
      push!(args, "Build-Depends: debhelper (>=9), $build_depends")
    else
      push!(args, "Build-Depends: debhelper (>=9)")
    end

    for binary in binaries
      name = pop!(binary, "package", package)
      desc = pop!(binary, "description", "")
      arch = pop!(binary, "architecture", "any")
      push!(args, "")
      push!(args, "Package: $name")
      push!(args, "Architecture: $arch")
      for (key, value) in binary
        key = "$(uppercase(key[1]))$(lowercase(key[2:end]))"
        push!(args, "$key: $value")
      end
      if length(desc) > 0; push!(args, "Description: $desc"); end
    end

    # now call function
    debian_file("control", args...)
end

function locations(package, version, workdir::String="workspace")
  const name = "$(package)-$version"
  const sourcedir = abspath(joinpath(workdir, name))
  const builddir = abspath(joinpath(workdir, "build", name))
  const tarfile = joinpath(builddir, "$(package)_$version.orig.tar.gz")
  name, sourcedir, builddir, tarfile
end

function make(machine::Docker.ActiveMachine, package::String, version::String;
    image::String="packaging", workdir::String="workspace", clean::Bool=false, architecture="amd64",
    build_depends=[], license::String="")
  const name, sourcedir, builddir, tarfile = locations(package, version, workdir)
  machine = deepcopy(machine)

  machine.volumes[builddir] = "/$name"
  machine.workdir = "/$name/$name"

  env = {:LOGNAME => :RSDT, :DEBFULLNAME => maintainer, :EMAIL => email}
  create_image = Docker.image(machine, package, build_depends; image=image, env=env)

  cmd = "dh_make -i -a -r cdbs -l -e \"$email\" -f /$name/$(basename(tarfile))" *
    if length(license) > 0; " -c $license"; else "" end
  dhmake = command(machine, STDOUT, cmd; image=package, rm=true) do
    ""
  end
  args = if clean; "-tc"; else "" end * " -a$architecture"
  dhbuild = command(machine, "dpkg-buildpackage $args"; image=package, rm=true)
  [create_image, dhmake, dhbuild]
end

#= function control(file, url, package::String, maintainer::String=maintainer; url="", homepage="", ) =#
#=     println(file, "Source: ", url) =#
#=     println(file, "Section: devel") =#
#=     println(file, "Priority: optional") =#
#=     println(file, "Maintainer: ", maintainer) =#
#=     println(file, "Build-Depends: debhelper (>=9), cmake") =#
#=     println(file, "Standard-Versions: 3.9.4") =#
#=     println(file, "Homepage: ", url, "\n") =#
#=     println(file, "Package: ", package) =#
#=     println(file, "Architecture: all") =#
#=     println(file, "Depends: cmake (>= 2.8)") =#
#=     println(file, "Description: CMake reciped") =#
#=     println(file, "- c++11 flags and features") =#
#=     println(file, "- macros to build/install python/cython package modules") =#
#=     println(file, "- lookup packages: recipes to find or install dependencies") =#
#=     println(file, "- lookup python packages: macros to find or install build dependencies") =#
#=     println(file, "- macros for in-build 'virtualenv'-like capabilities") =#
#=     println(file, "- various") =#
#= end =#
end

# Prepare git sources
function prepare_git_sources(
    package::String, version::String, url::String; workdir::String="workspace")
  const name, sourcedir, builddir, tarfile = locations(package, version, workdir)

  create_or_use_directory(sourcedir)
  create_or_use_directory(builddir)

  isdir(joinpath(sourcedir, ".git")) || run(`git clone $url $sourcedir`)
  cd(sourcedir) do
    if readchomp(`git tag -l v$version`) == "v$version"
      run(`git checkout v$version`)
    else
      run(`git checkout $version`)
    end
  end
  cd(workdir) do
    run(`tar -czvf $tarfile --exclude .git* $name`)
  end
  cd(builddir) do
    run(`tar -xvf $tarfile`)
  end
  builddir, tarfile
end
end
