module SortedStructures
#-----------------------------------------------------------
#PURPOSE
#	Colin T. Bowers module for nesting SortedDataVectors and SortedDataColumns
#NOTES
#LICENSE
#	MIT License (see github repository for more detail: https://github.com/colintbowers/SortedStructures.jl.git)
#-----------------------------------------------------------

#Load any entire modules that are needed (use using ModuleName1, ModuleName2, etc)
using SortedVectors

#Load any specific functions that are needed (use import ModuleName1.FunctionName1, ModuleName2.FunctionName2, etc)
import 	Base.string,
		Base.show,
		Base.getindex,
		Base.ndims,
		Base.length,
		Base.size,
		Base.sizeof,
		Base.eltype,
		Base.first,
		Base.last,
		Base.endof,
		Base.copy,
		Base.deepcopy,
		Base.issorted,
		Base.search,
		Base.searchsorted,
		Base.searchsortedfirst,
		Base.searchsortedlast,
		SortedVectors.searchfirst,
		SortedVectors.searchlast,
		Base.in,
		Base.==,
		Base.!=,
		Base.push!,
		Base.unshift!,
		Base.pop!,
		Base.shift!,
		Base.deleteat!,
		SortedVectors.deletenotat!,
		Base.empty!,
		Base.insert!,
		Base.intersect!,
		Base.intersect,
		Base.union!,
		Base.union,
		SortedVectors.trim!,
		SortedVectors.trim,
		SortedVectors.meshIndex,
		SortedVectors.mesh



#Specify the variables/functions to export (use export FunctionName1, FunctionName2, etc)
export 	SortedDataVector,
		SortedUniqueDataVector,
		SortedVectorStructure,
		SortedDataColumn,
		SortedUniqueDataColumn,
		SortedColumnStructure,
		SortedStructure,
		getlist,
		numcol,
		getx,
		getdata,
		getheader,
		searchlist,
		searchfirst,
		searchlast,
		replace!,
		deletenotat!,
		deleteatlist!,
		deleteat,
		deleteatlist,
		deletenotat,
		trim!,
		trim,
 		meshIndex,
		mesh


#Abstract super type to nest all types in this module
abstract SortedStructure{T1, T2, T3}


#----------------------------------------------------------
#TYPE
#	SortedDataVector
#	SortedUniqueDataVector
#FIELDS
#	list::SortedVector{T1} or SortedUniqueVector{T1}: A SortedVector or SortedUniqueVector that indexes the data in x
#	x::Vector{T2}: A vector of data indexed by list.
#	header::T3: A vector that provides a header for the data in x. Potentially useful if T2 is a custom type with multiple aspects to it.
#PURPOSE
#	This type allows the user to store a vector of data indexed by a sorted list and to dynamically grow or shrink them in assorted ways at run-time without trigerring memory allocation.
#CONSTRUCTORS
#	The constructors allow all types to be initialised without a header (default is ""::ASCIIString), with x expressed as a matrix, or with list expressed as a regular vector (or any combination of these).
#	There are also constructors that input datatypes in order to build an empty SortedDataVector or an empty SortedUniqueDataVector
#METHODS
#	There are many
#NOTES
#----------------------------------------------------------
#-------- TYPE DEFINITION -----------
#Abstract super-type
abstract SortedVectorStructure{T1, T2, T3} <: SortedStructure{T1, T2, T3}
#SortedDataVector
immutable SortedDataVector{T1, T2, T3} <: SortedVectorStructure{T1, T2, T3}
	list::SortedVector{T1}
	x::Vector{T2}
	header::T3
	function SortedDataVector{T1, T2, T3}(list::SortedVector{T1}, x::Vector{T2}, header::T3)
		length(list) != length(x) && error("Input vectors must have matching length")
		new(list, x, header)
	end
end
#SortedUniqueDataVector
immutable SortedUniqueDataVector{T1, T2, T3} <: SortedVectorStructure{T1, T2, T3}
	list::SortedUniqueVector{T1}
	x::Vector{T2}
	header::T3
	function SortedUniqueDataVector{T1, T2, T3}(list::SortedUniqueVector{T1}, x::Vector{T2}, header::T3)
		length(list) != length(x) && error("Input vectors must have matching length")
		new(list, x, header)
	end
end
#-------- CONSTRUCTORS -----------
#SortedDataVector Constructors
SortedDataVector{T1, T2, T3}(list::SortedVector{T1}, x::Vector{T2}, header::T3) = SortedDataVector{eltype(list), eltype(x), T3}(list, x, header)
SortedDataVector{T1, T2}(list::SortedVector{T1}, x::Vector{T2}) = SortedDataVector(list, x, "")
function SortedDataVector{T1, T2, T3}(list::SortedVector{T1}, x::Matrix{T2}, header::T3)
	size(x, 2) != 1 && error("Input matrix must have only one column")
	return(SortedDataVector(list, vec(x)), header)
end
SortedDataVector{T1, T2}(list::SortedVector{T1}, x::Matrix{T2}) = SortedDataVector(list, x, "")
SortedDataVector{T3}(T1::DataType, T2::DataType, header::T3) = SortedDataVector(SortedVector(T1), Array(T2, 0), header)
SortedDataVector(T1::DataType, T2::DataType) = SortedDataVector(SortedVector(T1), Array(T2, 0), "")
function SortedDataVector{T1, T2, T3}(list::Vector{T1}, x::Vector{T2}, header::T3; alreadySorted::Bool=false)
	if alreadySorted == true
		return(SortedDataVector(SortedVector(list, alreadySorted=true), x, header))
	else
		return(SortedDataVector(SortedVector(list[inds], alreadySorted=true), x[inds], header))
	end
end
SortedDataVector{T1, T2}(list::Vector{T1}, x::Vector{T2}; alreadySorted::Bool=false) = SortedDataVector(list, x, "", alreadySorted=alreadySorted)
function SortedDataVector{T1, T2, T3}(list::Vector{T1}, x::Matrix{T2}, header::T3; alreadySorted::Bool=false)
	size(x, 2) != 1 && error("Input matrix must have only one column")
	return(SortedDataVector(list, vec(x), header, alreadySorted=alreadySorted))
end
SortedDataVector{T1, T2}(list::Vector{T1}, x::Matrix{T2}; alreadySorted::Bool=false) = SortedDataVector(list, x, "", alreadySorted=alreadySorted)
#SortedUniqueDataVector Constructors
SortedUniqueDataVector{T1, T2, T3}(list::SortedUniqueVector{T1}, x::Vector{T2}, header::T3) = SortedUniqueDataVector{eltype(list), eltype(x), T3}(list, x, header)
SortedUniqueDataVector{T1, T2}(list::SortedUniqueVector{T1}, x::Vector{T2}) = SortedUniqueDataVector(list, x, "")
function SortedUniqueDataVector{T1, T2, T3}(list::SortedUniqueVector{T1}, x::Matrix{T2}, header::T3)
	size(x, 2) != 1 && error("Input matrix must have only one column")
	return(SortedUniqueDataVector(list, vec(x)), header)
end
SortedUniqueDataVector{T1, T2}(list::SortedUniqueVector{T1}, x::Matrix{T2}) = SortedUniqueDataVector(list, x, "")
SortedUniqueDataVector{T3}(T1::DataType, T2::DataType, header::T3) = SortedUniqueDataVector(SortedUniqueVector(T1), Array(T2, 0), header)
SortedUniqueDataVector(T1::DataType, T2::DataType) = SortedUniqueDataVector(SortedUniqueVector(T1), Array(T2, 0), "")
function SortedUniqueDataVector{T1, T2, T3}(list::Vector{T1}, x::Vector{T2}, header::T3; alreadySorted::Bool=false, alreadyUnique::Bool=false)
	if alreadySorted == true
		if alreadyUnique == false
			SortedVectors.isuniqueSort(list) == false && error("Input vector is not unique")
		end
		return(SortedUniqueDataVector(SortedUniqueVector(list, alreadySorted=true, alreadyUnique=true), x, header))
	else
		inds = sortperm(list)
		list = list[inds]
		if alreadyUnique == false
			SortedVectors.isuniqueSort(list) == false && error("Input vector is not unique")
		end
		return(SortedUniqueDataVector(SortedUniqueVector(list, alreadySorted=true, alreadyUnique=true), x[inds], header))
	end
end
SortedUniqueDataVector{T1, T2}(list::Vector{T1}, x::Vector{T2}; alreadySorted::Bool=false, alreadyUnique::Bool=false) = SortedUniqueDataVector(list, x, "", alreadySorted=alreadySorted, alreadyUnique=alreadyUnique)
function SortedUniqueDataVector{T1, T2, T3}(list::Vector{T1}, x::Matrix{T2}, header::T3; alreadySorted::Bool=false, alreadyUnique::Bool=false)
	size(x, 2) != 1 && error("Input matrix must have only one column")
	return(SortedUniqueDataVector(list, vec(x), header, alreadySorted=alreadySorted, alreadyUnique=alreadyUnique))
end
SortedUniqueDataVector{T1, T2}(list::Vector{T1}, x::Matrix{T2}; alreadySorted::Bool=false, alreadyUnique::Bool=false) = SortedUniqueDataVector(list, x, "", alreadySorted=alreadySorted, alreadyUnique=alreadyUnique)
#-------------------------------------
#-------- SIMPLE METHODS ----
Base.string(d::SortedVectorStructure) = "list = " * string(d.list) * ". header = " * string(d.header)
Base.show(d::SortedVectorStructure) = begin show(d.list); show(d.x); show(d.header); end
Base.ndims(d::SortedVectorStructure) = 1
getlist(d::SortedVectorStructure) = d.list
getlist(d::SortedVectorStructure, i::Int) = d.list[i] #returns scalar
getlist(d::SortedVectorStructure, inds::Vector{Int}) = d.list[inds]
getlist(d::SortedVectorStructure, inds::UnitRange) = d.list[inds]
getlist(d::SortedVectorStructure, inds::IntSet) = d.list[collect(inds)]
getx(d::SortedVectorStructure) = d.x #returns vector
getx(d::SortedVectorStructure, i::Int) = d.x[i] #returns scalar
getx{T<:Union(Vector{Int}, UnitRange)}(d::SortedVectorStructure, inds::T) = d.x[inds] #returns vector
getx(d::SortedVectorStructure, inds::IntSet) = d.x[collect(inds)] #returns vector
getx(d::SortedVectorStructure, iRow::Int, jCol::Int) = jCol == 1 ? getx(d, iRow) : error("Structure only contains one column") #returns scalar
getx{T<:Union(Vector{Int}, UnitRange)}(d::SortedVectorStructure, iRow::T, jCol::Int) = jCol == 1 ? getx(d, iRow) : error("Structure only contains one column") #returns vector
getx(d::SortedVectorStructure, iRow::IntSet, jCol::Int) = jCol == 1 ? getx(d, collect(iRow)) : error("Structure only contains one column") #returns vector
getx(d::SortedVectorStructure, iRow::Int, jCol::Vector{Int}) = jCol == [1] ? [getx(d, iRow)] : error("Structure only contains one column") #returns vector
getx(d::SortedVectorStructure, iRow::Int, jCol::UnitRange) = (jCol.start == 1 && jCol.stop == 1) ? [getx(d, iRow)] : error("Structure only contains one column") #returns vector
getx(d::SortedVectorStructure, iRow::Int, jCol::IntSet) = getx(d, iRow, collect(jCol)) #returns vector
getx{T<:Union(Vector{Int}, UnitRange, IntSet)}(d::SortedVectorStructure, iRow::T, jCol::Vector{Int}) = jCol == [1] ? getx(d, iRow)'' : error("Structure only contains one column") #returns matrix
getx{T<:Union(Vector{Int}, UnitRange, IntSet)}(d::SortedVectorStructure, iRow::T, jCol::UnitRange) = (jCol.start == 1 && jCol.stop == 1) ? getx(d, iRow)'' : error("Structure only contains one column") #returns matrix
getx{T<:Union(Vector{Int}, UnitRange, IntSet)}(d::SortedVectorStructure, iRow::T, jCol::IntSet) = getx(d, iRow, collect(jCol)) #returns matrix
Base.getindex(d::SortedVectorStructure, i::Int) = getx(d, i) #returns scalar
Base.getindex{T<:Union(Vector{Int}, UnitRange, IntSet)}(d::SortedVectorStructure, inds::T) = getx(d, inds) #returns vector
Base.getindex(d::SortedVectorStructure, iRow::Int, jCol::Int) = getx(d, iRow, jCol) #returns scalar
Base.getindex{T<:Union(Vector{Int}, UnitRange, IntSet)}(d::SortedVectorStructure, iRow::Int, jCol::T) = getx(d, iRow, jCol) #returns vector
Base.getindex{T<:Union(Vector{Int}, UnitRange, IntSet)}(d::SortedVectorStructure, iRow::T, jCol::Int) = getx(d, iRow, jCol) #returns vector
Base.getindex{T1<:Union(Vector{Int}, UnitRange, IntSet), T2<:Union(Vector{Int}, UnitRange, IntSet)}(d::SortedVectorStructure, iRow::T1, jCol::T2) = getx(d, iRow, jCol) #returns matrix
getdata{T1, T2, T3}(d::SortedDataVector{T1, T2, T3}, a::T1) = d[searchlist(d, a)] #returns vector
getdata{T1, T2, T3}(d::SortedUniqueDataVector{T1, T2, T3}, a::T1) = d[searchlist(d, a).start] #returns scalar (possibly revise to vector)
getheader(d::SortedVectorStructure) = d.header
Base.length(d::SortedVectorStructure) = length(d.list)
Base.size(d::SortedVectorStructure, i::Int) = i == 1 ? length(d) : error("Invalid size dimension")
Base.sizeof(d::SortedVectorStructure) = sizeof(d.list) + sizeof(d.x) + sizeof(d.header)
Base.first(d::SortedVectorStructure) = first(d.x)
Base.last(d::SortedVectorStructure) = last(d.x)
Base.endof(d::SortedVectorStructure) = endof(d.x)
Base.copy(d::SortedDataVector) = SortedDataVector(copy(d.list), copy(d.x), copy(d.header))
Base.copy(d::SortedUniqueDataVector) = SortedUniqueDataVector(copy(d.list), copy(d.x), copy(d.header))
Base.deepcopy(d::SortedDataVector) = SortedDataVector(deepcopy(d.list), deepcopy(d.x), deepcopy(d.header))
Base.deepcopy(d::SortedUniqueDataVector) = SortedUniqueDataVector(deepcopy(d.list), deepcopy(d.x), deepcopy(d.header))
Base.issorted(d::SortedVectorStructure) = issorted(d.list)
Base.searchsorted{T1, T2, T3}(d::SortedVectorStructure{T1, T2, T3}, a::T1) = searchsorted(d.list, a)
Base.searchsortedfirst{T1, T2, T3}(d::SortedVectorStructure{T1, T2, T3}, a::T1) = searchsortedfirst(d.list, a)
Base.searchsortedlast{T1, T2, T3}(d::SortedVectorStructure{T1, T2, T3}, a::T1) = searchsortedlast(d.list, a)
Base.search{T1, T2, T3}(d::SortedVectorStructure{T1, T2, T3}, a::T1) = searchsorted(d, a)
SortedVectors.searchfirst{T1, T2, T3}(d::SortedVectorStructure{T1, T2, T3}, a::T1) = searchsortedfirst(d, a)
SortedVectors.searchlast{T1, T2, T3}(d::SortedVectorStructure{T1, T2, T3}, a::T1) = searchsortedlast(d, a)
function searchlist{T1, T2, T3}(d::SortedVectorStructure{T1, T2, T3}, a::T1)
	r = search(d, a)
	r.start > r.stop && error("Unable to find matching element in SortedVectorStructure list")
	return(r)
end
Base.in{T1, T2, T3}(a::T1, d::SortedVectorStructure{T1, T2, T3}) = in(a, d.list)
#-------------------------------------
#-------- LONGER METHODS -----------
#eltype
function Base.eltype(d::SortedVectorStructure, i::Int)
	if i == 1
		return(eltype(d.list))
	elseif i == 2
		return(eltype(d.x))
	else
		error("Invalid dimension")
	end
end
#equal to, not equal to
function =={T1, T2, T3}(d1::SortedVectorStructure{T1, T2, T3}, d2::SortedVectorStructure{T1, T2, T3})
	if d1.list != d2.list
		return(false)
	elseif d1.x != d2.x
		return(false)
	end
	return(true)
end
#not equal to
!={T1, T2, T3}(d1::SortedVectorStructure{T1, T2, T3}, d2::SortedVectorStructure{T1, T2, T3}) = !(d1 == d2)
#pop!
function Base.pop!(d::SortedVectorStructure)
	pop!(d.list)
	pop!(d.x)
end
#shift!
function Base.shift!(d::SortedVectorStructure)
	shift!(d.list)
	shift!(d.x)
end
#push!
function push_unsafe!{T1, T2, T3}(d::SortedVectorStructure{T1, T2, T3}, listItem::T1, xItem)
	push!(d.list, listItem)
	push!(d.x, xItem)
end
Base.push!{T1, T2, T3}(d::SortedDataVector{T1, T2, T3}, listItem::T1, xItem) = listItem < d.list[end] ? error("push! operation will violate sort order") : push_unsafe!(d, listItem, xItem)
Base.push!{T1, T2, T3}(d::SortedUniqueDataVector{T1, T2, T3}, listItem::T1, xItem) = listItem <= d.list[end] ? error("push! operation will violate sort order") : push_unsafe!(d, listItem, xItem)
#unshift!
function unshift_unsafe!{T1, T2, T3}(d::SortedVectorStructure{T1, T2, T3}, listItem::T1, xItem)
	unshift!(d.list, listItem)
	unshift!(d.x, xItem)
end
Base.unshift!{T1, T2, T3}(d::SortedDataVector{T1, T2, T3}, listItem::T1, xItem) = listItem > d.list[1] ? error("unshift! operation will violate sort order") : unshift_unsafe!(d, listItem, xItem)
Base.unshift!{T1, T2, T3}(d::SortedUniqueDataVector{T1, T2, T3}, listItem::T1, xItem) = listItem >= d.list[1] ? error("unshift! operation will violate sort order") : unshift_unsafe!(d, listItem, xItem)
#insert!
function Base.insert!{T1, T2, T3}(d::SortedVectorStructure{T1, T2, T3}, listItem::T1, xItem)
	i = insert!(d.list, listItem)
	insert!(d.x, i, xItem)
	return(i)
end
function Base.insert!{T1, T2, T3}(d::SortedVectorStructure{T1, T2, T3}, listItem::Vector{T1}, xItem::Vector)
	length(listItem) != length(xItem) && error("listItem and xItem must have matching length")
	i = [ insert!(d, listItem[n], xItem[n]) for n = 1:length(listItem) ]
	return(i)
end
Base.insert!{T1, T2, T3}(d1::SortedVectorStructure{T1, T2, T3}, d2::SortedVectorStructure{T1, T2, T3}) = insert!(d1, d2.list.x, d2.x)
#replace!
function replace!{T1, T2, T3}(d::SortedVectorStructure{T1, T2, T3}, listItem::T1, xItem)
	r = searchlist(d, listItem)
	for i = r.start:r.stop
		d.x[i] = xItem
	end
	return(r)
end
function replace!{T1, T2}(d::SortedVectorStructure{T1, T2}, listItem::Vector{T1}, xItem::Vector)
	length(listItem) != length(xItem) && error("listItem and xItem must have matching length")
	r = [ replace!(d, listItem[n], xItem[n]) for n = 1:length(d) ]
	return(r)
end
#deleteat!
function Base.deleteat!{T<:Union(Int, UnitRange, Vector{Int})}(d::SortedVectorStructure, inds::T)
	deleteat!(d.list, inds)
	deleteat!(d.x, inds)
end
Base.deleteat!(d::SortedVectorStructure, inds::IntSet) = deleteat!(d, collect(inds))
#deletenotat!
SortedVectors.deletenotat!(d::SortedVectorStructure, r::UnitRange) = deleteat!(d, setdiffIndex(length(d), r))
SortedVectors.deletenotat!(d::SortedVectorStructure, inds::IntSet) = deleteat!(d, setdiffIndex(length(d), inds))
SortedVectors.deletenotat!(d::SortedVectorStructure, inds::Vector{Int}; alreadySorted::Bool=false) = deleteat!(d, setdiffIndex(length(d), inds, alreadySorted=alreadySorted))
#deleteatlist! (deleteat! for a given element of list)
deleteatlist!{T1, T2, T3}(d::SortedVectorStructure{T1, T2, T3}, a::T1) = deleteat!(d, search(d, a))
deleteatlist!{T1, T2, T3}(d::SortedVectorStructure{T1, T2, T3}, a::Vector{T1}) = [ deleteat!(d, a[n]) for n = 1:length(a) ]
#empty!
Base.empty!(d::SortedVectorStructure) = deleteat!(d, 1:length(d))
#deleteat
function deleteat{T<:Union(UnitRange, Vector{Int}, IntSet)}(d::SortedVectorStructure, inds::T)
	dCopy = deepcopy(d)
	deleteat!(dCopy, inds)
	return(dCopy)
end
#deletenotat
function deletenotat{T<:Union(UnitRange, Vector{Int}, IntSet)}(d::SortedVectorStructure, inds::T)
	dCopy = deepcopy(d)
	deletenotat!(dCopy, inds)
	return(dCopy)
end
#deleteatlist
function deleteatlist{T1, T2, T3}(d::SortedVectorStructure{T1, T2, T3}, a::Vector{T1})
	dCopy = deepcopy(d)
	deleteatlist!(dCopy, a)
	return(dCopy)
end
#intersect!
function intersect!{T1, T2, T3}(d1::SortedDataVector{T1, T2, T3}, s::SortedVector{T1})
	(inds, indsTemp1, indsTemp2, indsTemp3) = intersectIndex(d1.list, s)
	deletenotat!(d1, inds, alreadySorted=true)
end
function intersect!{T1, T2, T3}(d1::SortedDataVector{T1, T2, T3}, s::SortedDataVector{T1, T2, T3})
	#Need to think about how this works with respect to intersect
	error("This method is currently not available. For SortedDataVector, try intersect instead")
end
function intersect!{T1, T2, T3}(d1::SortedUniqueDataVector{T1, T2, T3}, s::SortedUniqueVector{T1})
	#Consider implementing a custom routine for speed
	(inds, indsTemp1) = intersectIndex(d1.list, s)
	deletenotat!(d1, inds, alreadySorted=true)
end
intersect!{T1, T2, T3}(d1::SortedUniqueDataVector{T1, T2, T3}, d2::SortedUniqueDataVector{T1, T2, T3}) = intersect!(d1, d2.list)
#intersect
function intersect{T1, T2, T3}(d1::SortedDataVector{T1, T2, T3}, d2::SortedDataVector{T1, T2, T3})
	(inds1, inds2, inds1Rec, inds2Rec) = intersectIndex(d1.list, d2.list)
	N = length(inds1) + length(inds2)
	listNew = Array(T1, N)
	xNew = Array(T2, N)
	listNew[inds1Rec] = d1.list[inds1]
	listNew[inds2Rec] = d2.list[inds2]
	xNew[inds1Rec] = d1.x[inds1]
	xNew[inds2Rec] = d2.x[inds2]
	return(SortedDataVector(SortedVector(listNew, alreadySorted=true), xNew, deepcopy(d1.header)))
end
function intersect{T1, T2, T3}(d1::SortedUniqueDataVector{T1, T2, T3}, s::SortedUniqueVector{T1})
	(inds1, inds2) = intersectIndex(d1.list, s)
	return(SortedUniqueDataVector(SortedUniqueVector(d1.list[inds1], alreadySorted=true, alreadyUnique=true), d1.x[inds1], deepcopy(d1.header)))
end
intersect{T1, T2, T3}(d1::SortedUniqueDataVector{T1, T2, T3}, d2::SortedUniqueDataVector{T1, T2, T3}) = intersect(d1, d2.list)
#union!
union!{T1, T2, T3}(d1::SortedDataVector{T1, T2, T3}, d2::SortedDataVector{T1, T2, T3}) = insert!(d1, d2)
function union!{T1, T2, T3}(d1::SortedUniqueDataVector{T1, T2, T3}, d2::SortedUniqueDataVector{T1, T2, T3}) #Custom routine for speed
	if length(d2) > 0
		if length(d1) == 0
			insert!(d1, d2)
		else
			for n = 1:length(d2)
				if d2.list[n] < d1.list[1]
					i = 1
				elseif d2.list[n] > d1.list[end]
					i = length(d1)+1
				else
					r = search(d1.list, d2.list[n])
					if isempty(r)
						i = r.start
					else
						i = -1
					end
				end
				if i != -1
					insert!(d1.list.x, i, d2.list[n])
					insert!(d1.x, i, d2.x[n])
				end
			end
		end
	end
	return(true)
end
#union
function union{T1, T2, T3}(d1::SortedVectorStructure{T1, T2, T3}, d2::SortedVectorStructure{T1, T2, T3})
	dNew = deepcopy(d1)
	union!(dNew, d2)
	return(dNew)
end
#trim!, trim
SortedVectors.trim!{T1, T2, T3}(d::SortedVectorStructure{T1, T2, T3}, LB::T1, UB::T1) = deletenotat!(d, trimRange(d.list, LB, UB))
function SortedVectors.trim{T1, T2, T3}(d::SortedVectorStructure{T1, T2, T3}, LB::T1, UB::T1)
	dCopy = deepcopy(d)
	trim!(dCopy, LB, UB)
	return(dCopy)
end
#meshIndex, mesh (note, output of mesh always SortedUnique since mesh always unique)
SortedVectors.meshIndex{T1, T2, T3}(d::SortedVectorStructure{T1, T2, T3}, m::SortedUniqueVector{T1}; allowForwardLooking::Bool=true) = meshIndex(d.list, m, allowForwardLooking=allowForwardLooking)
SortedVectors.mesh{T1, T2, T3}(d::SortedVectorStructure{T1, T2, T3}, m::SortedUniqueVector{T1}; allowForwardLooking::Bool=true) = SortedUniqueDataVector(m, d.x[meshIndex(d, m, allowForwardLooking=allowForwardLooking)])













#----------------------------------------------------------
#TYPE
#	SortedDataColumn{T1, T2, T3}
#	SortedUniqueDataColumn{T1, T2, T3}
#FIELDS
#	list::SortedVector{T1} or SortedUniqueVector{T1}: A SortedVector or SortedUniqueVector that indexes the data in x
#	x::Vector{Vector{T2}}: An outer vector (can be conceptually thought of as a row) containing a set of inner vectors (can be conceptually thought of as columns). Elements of inner vectors are indexed by list.
#	header::Vector{T3}: A vector that indexes the outer vector of x (conceptually can be thought of as column names)
#PURPOSE
#	This type allows the user to store multivariate sorted columns of data (of equal length) indexed by a sorted list, and to dynamically grow or shrink them in assorted ways at run-time without trigerring memory allocation.
#CONSTRUCTORS
#	The constructors allow all types to be initialised without a header (default is vector of empty ASCIIString), with x expressed as a matrix, or with list expressed as a regular vector (or any combination of these).
#	There are also constructors that input datatypes in order to build an empty SortedDataColumn or an empty SortedUniqueDataColumn
#METHODS
#	Many
#----------------------------------------------------------
#-------- TYPE DEFINITION -----------
#Unique and NotUnique types used to leverage type hierarchy
#Abstract super-type
abstract SortedColumnStructure{T1, T2, T3} <: SortedStructure{T1, T2, T3}
#SortedDataColumn
immutable SortedDataColumn{T1, T2, T3} <: SortedColumnStructure{T1, T2, T3}
	list::SortedVector{T1}
	x::Vector{Vector{T2}}
	header::Vector{T3}
	function SortedDataColumn{T1, T2, T3}(list::SortedVector{T1}, x::Vector{Vector{T2}}, header::Vector{T3})
		length(x) < 1 && error("Type must be initialised with at least one data column")
		length(header) != length(x) && error("Number of columns must equal number of headers")
		for n = 1:length(x)
			length(list) != length(x[n]) && error("Input list and columns must all have matching length")
		end
		new(list, x, header)
	end
end
#SortedUniqueDataColumn
immutable SortedUniqueDataColumn{T1, T2, T3} <: SortedColumnStructure{T1, T2, T3}
	list::SortedUniqueVector{T1}
	x::Vector{Vector{T2}}
	header::Vector{T3}
	function SortedUniqueDataColumn{T1, T2, T3}(list::SortedUniqueVector{T1}, x::Vector{Vector{T2}}, header::Vector{T3})
		length(x) < 1 && error("Type must be initialised with at least one data column")
		length(header) != length(x) && error("Number of columns must equal number of headers")
		for n = 1:length(x)
			length(list) != length(x[n]) && error("Input list and columns must all have matching length")
		end
		new(list, x, header)
	end
end
#SortedDataColumn Constructors
function SortedDataColumn{T1, T2, T3}(list::SortedVector{T1}, x::Vector{Vector{T2}}, header::Vector{T3})
	length(x) < 1 && error("Type must be initialised with at least one data column")
	return(SortedDataColumn{eltype(list), eltype(x[1]), eltype(header)}(list, x, header))
end
SortedDataColumn{T1, T2}(list::SortedVector{T1}, x::Vector{Vector{T2}}) = SortedDataColumn(list, x, buildAsciiVector(length(x)))
function SortedDataColumn{T1, T2, T3}(list::SortedVector{T1}, x::Vector{T2}, header::Vector{T3})
	xVec = Array(Vector{T2}, 1)
	xVec[1] = x
	return(SortedDataColumn(list, xVec, header))
end
SortedDataColumn{T1, T2}(list::SortedVector{T1}, x::Vector{T2}) = SortedDataColumn(list, x, "")
SortedDataColumn(T1::DataType, T2::DataType, T3::DataType, nCol::Int) = SortedDataColumn(SortedVector(T1, 0), [ Array(T2, 0) for n = 1:nCol ], Array(T3, nCol))
SortedDataColumn(T1::DataType, T2::DataType, nCol::Int) = SortedDataColumn(T1, T2, ASCIIString, nCol)
SortedDataColumn{T1, T2, T3}(list::SortedVector{T1}, x::Matrix{T2}, header::Vector{T3}) = SortedDataColumn(list, [ x[:, n] for n = 1:size(x, 2) ], header)
SortedDataColumn{T1, T2}(list::SortedVector{T1}, x::Matrix{T2}) = SortedDataColumn(list, x, buildAsciiVector(size(x, 2)))
function SortedDataColumn{T1, T2, T3}(list::Vector{T1}, x::Vector{Vector{T2}}, header::Vector{T3}; alreadySorted::Bool=false)
	length(x) < 1 && error("Type must be initialised with at least one data column")
	if alreadySorted == true
		return(SortedDataColumn(SortedVector(list, alreadySorted=true), x, header))
	else
		inds = sortperm(list)
		return(SortedDataColumn(SortedVector(list[inds], alreadySorted=true), [ x[n][inds] for n = 1:length(x) ], header))
	end
end
SortedDataColumn{T1, T2}(list::Vector{T1}, x::Vector{Vector{T2}}; alreadySorted::Bool=false) = SortedDataColumn(list, x, buildAsciiVector(length(x)), alreadySorted=alreadySorted)
function SortedDataColumn{T1, T2, T3}(list::Vector{T1}, x::Matrix{T2}, header::Vector{T3}; alreadySorted::Bool=false)
	size(x, 2) < 1 && error("Type must be initialised with at least one data column")
	if alreadySorted == true
		return(SortedDataColumn(SortedVector(list, alreadySorted=true), [ x[:, n] for n = 1:size(x, 2) ], header))
	else
		inds = sortperm(list)
		return(SortedDataColumn(SortedVector(list[inds], alreadySorted=true), [ x[inds, n] for n = 1:size(x, 2) ], header))
	end
end
SortedDataColumn{T1, T2}(list::Vector{T1}, x::Matrix{T2}; alreadySorted::Bool=false) = SortedDataColumn(list, x, buildAsciiVector(size(x, 2)), alreadySorted=alreadySorted)
#SortedUniqueDataColumn Constructors
function SortedUniqueDataColumn{T1, T2, T3}(list::SortedUniqueVector{T1}, x::Vector{Vector{T2}}, header::Vector{T3})
	length(x) < 1 && error("Type must be initialised with at least one data column")
	return(SortedUniqueDataColumn{eltype(list), eltype(x[1]), eltype(header)}(list, x, header))
end
SortedUniqueDataColumn{T1, T2}(list::SortedUniqueVector{T1}, x::Vector{Vector{T2}}) = SortedUniqueDataColumn(list, x, buildAsciiVector(length(x)))
function SortedUniqueDataColumn{T1, T2, T3}(list::SortedUniqueVector{T1}, x::Vector{T2}, header::Vector{T3})
	xVec = Array(Vector{T2}, 1)
	xVec[1] = x
	return(SortedUniqueDataColumn(list, xVec, header))
end
SortedUniqueDataColumn{T1, T2}(list::SortedUniqueVector{T1}, x::Vector{T2}) = SortedUniqueDataColumn(list, x, "")
SortedUniqueDataColumn(T1::DataType, T2::DataType, T3::DataType, nCol::Int) = SortedUniqueDataColumn(SortedUniqueVector(T1, 0), [ Array(T2, 0) for n = 1:nCol ], Array(T3, nCol))
SortedUniqueDataColumn(T1::DataType, T2::DataType, nCol::Int) = SortedUniqueDataColumn(T1, T2, ASCIIString, nCol)
SortedUniqueDataColumn{T1, T2, T3}(list::SortedUniqueVector{T1}, x::Matrix{T2}, header::Vector{T3}) = SortedUniqueDataColumn(list, [ x[:, n] for n = 1:size(x, 2) ], header)
SortedUniqueDataColumn{T1, T2}(list::SortedUniqueVector{T1}, x::Matrix{T2}) = SortedUniqueDataColumn(list, x, buildAsciiVector(size(x, 2)))
function SortedUniqueDataColumn{T1, T2, T3}(list::Vector{T1}, x::Vector{Vector{T2}}, header::Vector{T3}; alreadySorted::Bool=false, alreadyUnique::Bool=false)
	length(x) < 1 && error("Type must be initialised with at least one data column")
	if alreadySorted == true
		if alreadyUnique == false
			SortedVectors.isuniqueSort(list) == false && error("Input vector is not unique")
		end
		return(SortedUniqueDataColumn(SortedUniqueVector(list, alreadySorted=true, alreadyUnique=true), x, header))
	else
		inds = sortperm(list)
		list = list[inds]
		if alreadyUnique == false
			SortedVectors.isuniqueSort(list) == false && error("Input vector is not unique")
		end
		return(SortedUniqueDataColumn(SortedUniqueVector(list, alreadySorted=true, alreadyUnique=true), [ x[n][inds] for n = 1:length(x) ], header))
	end
end
SortedUniqueDataColumn{T1, T2}(list::Vector{T1}, x::Vector{Vector{T2}}; alreadySorted::Bool=false, alreadyUnique::Bool=false) = SortedUniqueDataColumn(list, x, buildAsciiVector(length(x)), alreadySorted=alreadySorted, alreadyUnique=alreadyUnique)
function SortedUniqueDataColumn{T1, T2, T3}(list::Vector{T1}, x::Matrix{T2}, header::Vector{T3}; alreadySorted::Bool=false, alreadyUnique::Bool=false)
	size(x, 2) < 1 && error("Type must be initialised with at least one data column")
	if alreadySorted == true
		if alreadyUnique == false
			SortedVectors.isuniqueSort(list) == false && error("Input vector is not unique")
		end
		return(SortedUniqueDataColumn(SortedUniqueVector(list, alreadySorted=true, alreadyUnique=true), [ x[:, n] for n = 1:size(x, 2) ], header))
	else
		inds = sortperm(list)
		list = list[inds]
		if alreadyUnique == false
			SortedVectors.isuniqueSort(list) == false && error("Input vector is not unique")
		end
		return(SortedUniqueDataColumn(SortedUniqueVector(list, alreadySorted=true, alreadyUnique=true), [ x[inds, n] for n = 1:size(x, 2) ], header))
	end
end
SortedUniqueDataColumn{T1, T2}(list::Vector{T1}, x::Matrix{T2}; alreadySorted::Bool=false, alreadyUnique::Bool=false) = SortedUniqueDataColumn(list, x, buildAsciiVector(size(x, 2)), alreadySorted=alreadySorted, alreadyUnique=alreadyUnique)
#-------------------------------------
#-------- SIMPLE METHODS ----
Base.string(d::SortedColumnStructure) = "list = " * string(d.list) * ". header = " * string(d.header)
Base.show(d::SortedColumnStructure) = begin show(d.list); show(d.x); show(d.header); end
Base.length(d::SortedColumnStructure) = length(d.list)
function Base.size(d::SortedColumnStructure, i::Int)
	i == 1 && return(length(d.list))
	i == 2 && return(length(d.header))
	error("Invalid dimension")
end
numcol(d::SortedColumnStructure) = length(d.header)
Base.sizeof(d::SortedColumnStructure) = sizeof(d.list) + sizeof(d.x)
Base.sizeof(d::SortedColumnStructure) = sizeof(d.list) + sizeof(d.x) + sizeof(d.header)
Base.ndims(d::SortedColumnStructure) = 2
getlist(d::SortedColumnStructure) = d.list
getlist(d::SortedColumnStructure, i::Int) = d.list[i]
getlist(d::SortedColumnStructure, r::UnitRange) = d.list[r]
getlist(d::SortedColumnStructure, i::Vector{Int}) = d.list[i]
getlist(d::SortedColumnStructure, inds::IntSet) = d.list[collect(inds)]
getx(d::SortedColumnStructure) = [ d.x[j][n] for n in 1:length(d), j in 1:numcol(d) ] #returns matrix
getx(d::SortedColumnStructure, iCol::Int, jRow::Int) = d.x[jRow][iCol] #Returns scalar
getx(d::SortedColumnStructure, rCol::UnitRange, jRow::Int) = d.x[jRow][rCol] #Returns vector
getx(d::SortedColumnStructure, indsCol::Vector{Int}, jRow::Int) = d.x[jRow][indsCol] #returns vector
getx(d::SortedColumnStructure, indsCol::IntSet, jRow::Int) = d.x[jRow][collect(indsCol)] #returns vector
getx(d::SortedColumnStructure, iCol::Int, jRow::UnitRange) = [ d.x[n][iCol] for n in jRow ]' #returns row matrix
getx(d::SortedColumnStructure, iCol::Int, jRow::Vector{Int}) = [ d.x[n][iCol] for n in jRow ]' #returns row matrix
getx(d::SortedColumnStructure, iCol::Int, jRow::IntSet) = [ d.x[n][iCol] for n in collect(jRow) ]' #returns row matrix
getx{T1<:Union(Vector{Int}, UnitRange), T2<:Union(Vector{Int}, UnitRange)}(d::SortedColumnStructure, indsCol::T1, indsRow::T2) = [ d.x[j][n] for n in indsCol, j in indsRow ] #returns matrix
getx{T<:Union(Vector{Int}, UnitRange)}(d::SortedColumnStructure, indsCol::T, indsRow::IntSet) = [ d.x[j][n] for n in indsCol, j in collect(indsRow) ] #returns matrix
getx{T<:Union(Vector{Int}, UnitRange)}(d::SortedColumnStructure, indsCol::IntSet, indsRow::T) = [ d.x[j][n] for n in collect(indsCol), j in indsRow ] #returns matrix
Base.getindex(d::SortedColumnStructure, i::Int, j::Int) = getx(d, i, j) #returns scalar
Base.getindex{T<:Union(Vector{Int}, UnitRange, IntSet)}(d::SortedColumnStructure, i::Int, j::T) = getx(d, i, j) #returns row matrix
Base.getindex{T<:Union(Vector{Int}, UnitRange, IntSet)}(d::SortedColumnStructure, i::T, j::Int) = getx(d, i, j) #returns vector
Base.getindex{T1<:Union(Vector{Int}, UnitRange, IntSet), T2<:Union(Vector{Int}, UnitRange, IntSet)}(d::SortedColumnStructure, i::T1, j::T2) = getx(d, i, j) #returns matrix
getheader(d::SortedColumnStructure) = d.header
getheader(d::SortedColumnStructure, i::Int) = d.header[i]
getheader(d::SortedColumnStructure, r::UnitRange) = d.header[r]
getheader(d::SortedColumnStructure, inds::Vector{Int}) = d.header[inds]
getheader(d::SortedColumnStructure, inds::IntSet) = d.header[collect(inds)]
getdata{T1, T2, T3}(d::SortedColumnStructure{T1, T2, T3}, a::T1) = d[searchlist(d, a), :] #returns matrix
Base.searchsorted{T1, T2, T3}(d::SortedColumnStructure{T1, T2, T3}, a::T1) = searchsorted(d.list, a)
Base.searchsortedfirst{T1, T2, T3}(d::SortedColumnStructure{T1, T2, T3}, a::T1) = searchsortedfirst(d.list, a)
Base.searchsortedlast{T1, T2, T3}(d::SortedColumnStructure{T1, T2, T3}, a::T1) = searchsortedlast(d.list, a)
Base.search{T1, T2, T3}(d::SortedColumnStructure{T1, T2, T3}, a::T1) = searchsorted(d.list, a)
searchfirst{T1, T2, T3}(d::SortedColumnStructure{T1, T2, T3}, a::T1) = searchsortedfirst(d.list, a)
searchlast{T1, T2, T3}(d::SortedColumnStructure{T1, T2, T3}, a::T1) = searchsortedlast(d.list, a)
function searchlist{T1, T2, T3}(d::SortedColumnStructure{T1, T2, T3}, a::T1)
	r = search(d, a)
	r.start > r.stop && error("Unable to find matching element in SortedColumnStructure list")
	return(r)
end
Base.first(d::SortedColumnStructure) = first(d.x)
Base.last(d::SortedColumnStructure) = last(d.x)
Base.endof(d::SortedColumnStructure) = endof(d.x)
Base.copy(d::SortedDataColumn) = SortedDataColumn(copy(d.list), copy(d.x), copy(d.header))
Base.copy(d::SortedUniqueDataColumn) = SortedUniqueDataColumn(copy(d.list), copy(d.x), copy(d.header))
Base.deepcopy(d::SortedDataColumn) = SortedDataColumn(deepcopy(d.list), deepcopy(d.x), deepcopy(d.header))
Base.deepcopy(d::SortedUniqueDataColumn) = SortedUniqueDataColumn(deepcopy(d.list), deepcopy(d.x), deepcopy(d.header))
Base.issorted(d::SortedColumnStructure) = issorted(d.list)
Base.in{T1, T2, T3}(a::T1, d::SortedColumnStructure{T1, T2, T3}) = in(a, d.list)
#-------------------------------------
#-------- LONGER METHODS -----------
#eltype
function Base.eltype(d::SortedColumnStructure, i::Int)
	size(d, 2) < 1 && error("SortedColumnStructure must contain at least one column")
	if i == 1
		return(eltype(d.list))
	elseif i == 2
		return(eltype(d.x[1]))
	elseif i == 3
		return(eltype(d.header))
	else
		error("Invalid dimension")
	end
end
#equal to / not equal to
function =={T1, T2, T3}(d1::SortedColumnStructure{T1, T2, T3}, d2::SortedColumnStructure{T1, T2, T3})
	if d1.list != d2.list
		return(false)
	elseif d1.x != d2.x
		return(false)
	elseif d1.header != d2.header
		return(false)
	end
	return(true)
end
!={T1, T2, T3}(d1::SortedColumnStructure{T1, T2, T3}, d2::SortedColumnStructure{T1, T2, T3}) = !(d1 == d2)
#pop!
function Base.pop!(d::SortedColumnStructure)
	pop!(d.list)
	[ pop!(d.x[n]) for n = 1:numcol(d) ]
end
#shift!
function Base.shift!(d::SortedColumnStructure)
	shift!(d.list)
	[ shift!(d.x[n]) for n = 1:numcol(d) ]
end
#push!
function Base.push!{T1, T2, T3}(d::SortedDataColumn{T1, T2, T3}, listItem::T1, xItem::Vector)
	length(xItem) != numcol(d) && error("Column number mismatch")
	listItem < d.list[end] && error("push! operation will violate sort order")
	push!(d.list, listItem)
	[ push!(d.x[n], xItem[n]) for n = 1:numcol(d) ]
end
function Base.push!{T1, T2, T3}(d::SortedUniqueDataColumn{T1, T2, T3}, listItem::T1, xItem::Vector)
	length(xItem) != numcol(d) && error("Column number mismatch")
	listItem <= d.list[end] && error("push! operation will violate sort order")
	push!(d.list, listItem)
	[ push!(d.x[n], xItem[n]) for n = 1:numcol(d) ]
end
#unshift!
function Base.unshift!{T1, T2, T3}(d::SortedDataColumn{T1, T2, T3}, listItem::T1, xItem::Vector)
	length(xItem) != numcol(d) && error("Column number mismatch")
	listItem > d.list[1] && error("unshift! operation will violate sort order")
	unshift!(d.list, listItem)
	[ unshift!(d.x[n], xItem[n]) for n = 1:numcol(d) ]
end
function Base.unshift!{T1, T2, T3}(d::SortedUniqueDataColumn{T1, T2, T3}, listItem::T1, xItem::Vector)
	length(xItem) != numcol(d) && error("Column number mismatch")
	listItem >= d.list[1] && error("unshift! operation will violate sort order")
	unshift!(d.list, listItem)
	[ unshift!(d.x[n], xItem[n]) for n = 1:numcol(d) ]
end
#insert!
function Base.insert!{T1, T2, T3}(d::SortedColumnStructure{T1, T2, T3}, listItem::T1, xItem::Vector)
	length(xItem) != numcol(d) && error("Column number mismatch")
	i = insert!(d.list, listItem)
	[ insert!(d.x[n], i, xItem[n]) for n = 1:numcol(d) ]
	return(i)
end
function Base.insert!{T1, T2, T3}(d::SortedColumnStructure{T1, T2, T3}, listItem::Vector{T1}, xItem::Matrix{T2})
	length(listItem) != size(xItem, 1) && error("Row number mismatch")
	return([ insert!(d, listItem[n], xItem[n, :]) for n = 1:length(listItem) ])
end
function Base.insert!{T1, T2, T3}(d1::SortedColumnStructure{T1, T2, T3}, d2::SortedColumnStructure{T1, T2, T3})
	numcol(d1) != numcol(d2) && error("Column number mismatch")
	for n = 1:length(d2)
		i = insert!(d1.list, d2.list[n])
		for j = 1:numcol(d2)
			insert!(d1.x[j], i, d2.x[j][n])
		end
	end
end
#deleteat!
function Base.deleteat!{T<:Union(Int, UnitRange, Vector{Int})}(d::SortedColumnStructure, inds::T)
	deleteat!(d.list, inds)
	[ deleteat!(d.x[n], inds) for n = 1:numcol(d) ]
end
Base.deleteat!(d::SortedColumnStructure, inds::IntSet) = deleteat!(d, collect(inds))
#deleteatlist! (deleteat! for a given element of list)
deleteatlist!{T1, T2, T3}(d::SortedColumnStructure{T1, T2, T3}, a::T1) = deleteat!(d, search(d, a))
deleteatlist!{T1, T2, T3}(d::SortedColumnStructure{T1, T2, T3}, a::Vector{T1}) = [ deleteatlist!(d, a[n]) for n = 1:length(a) ]
#empty!
Base.empty!(d::SortedColumnStructure) = deleteat!(d, 1:length(d))
#replace!
function replace!{T1, T2, T3}(d::SortedColumnStructure{T1, T2, T3}, listItem::T1, xItem::Vector)
	length(xItem) != numcol(d) && error("Column number mismatch")
	r = searchlist(d, listItem)
	for n = 1:length(xItem)
		for i = r.start:r.stop
			d.x[n][i] = xItem[n]
		end
	end
	return(r)
end
function replace!{T1, T2, T3}(d::SortedColumnStructure{T1, T2, T3}, listItem::T1, xItem::Matrix{T2})
	size(xItem, 1) != 1 && error("xItem must be a row matrix")
	replace!(d, listItem, vec(xItem))
end
function replace!{T1, T2, T3}(d::SortedColumnStructure{T1, T2, T3}, listItem::Vector{T1}, xItem::Matrix{T2})
	length(listItem) != size(xItem, 1) && error("listItem length must match number of rows in xItem")
	return([ replace!(d, listItem[n], xItem[n, :]) for n = 1:length(listItem) ])
end
#deletenotat!
SortedVectors.deletenotat!(d::SortedColumnStructure, r::UnitRange) = deleteat!(d, setdiffIndex(length(d), r))
SortedVectors.deletenotat!(d::SortedColumnStructure, inds::IntSet) = deleteat!(d, setdiffIndex(length(d), inds))
SortedVectors.deletenotat!(d::SortedColumnStructure, inds::Vector{Int}; alreadySorted::Bool=false) = deleteat!(d, setdiffIndex(length(d), inds, alreadySorted=alreadySorted))
#insert
function insert{T1, T2, T3}(d::SortedColumnStructure{T1, T2, T3}, listItem::Vector{T1}, xItem::Matrix{T2})
	dCopy = deepcopy(d)
	insert!(dCopy, listItem, xItem)
	return(dCopy)
end
insert{T1, T2, T3}(d1::SortedColumnStructure{T1, T2, T3}, d2::SortedColumnStructure{T1, T2, T3}) = insert(d1, d2.list, getmat(d2.x))
#deleteat
function deleteat{T<:Union(UnitRange, Vector{Int}, IntSet)}(d::SortedColumnStructure, inds::T)
	dCopy = deepcopy(d)
	deleteat!(dCopy, inds)
	return(dCopy)
end
#deletenotat
function deletenotat{T<:Union(UnitRange, Vector{Int}, IntSet)}(d::SortedColumnStructure, inds::T)
	dCopy = deepcopy(d)
	deletenotat!(dCopy, inds)
	return(dCopy)
end
#deleteatlist
function deleteatlist{T1, T2, T3}(d::SortedColumnStructure{T1, T2, T3}, a::Vector{T1})
	dCopy = deepcopy(d)
	deleteatlist!(dCopy, a)
	return(dCopy)
end
#intersect!
function intersect!{T1, T2, T3}(d1::SortedDataColumn{T1, T2, T3}, s::SortedVector{T1})
	(inds, indsTemp1, indsTemp2, indsTemp3) = intersectIndex(d1.list, s)
	deletenotat!(d1, inds, alreadySorted=true)
end
function intersect!{T1, T2, T3}(d1::SortedDataColumn{T1, T2, T3}, d2::SortedDataColumn{T1, T2, T3})
	#Need to think about how this works with respect to intersect
	error("This method is currently not available. For SortedDataColumn, try intersect instead")
end
function intersect!{T1, T2, T3}(d1::SortedUniqueDataColumn{T1, T2, T3}, s::SortedUniqueVector{T1})
	(inds, indsTemp1) = intersectIndex(d1.list, s)
	deletenotat!(d1, inds, alreadySorted=true)
end
intersect!{T1, T2, T3}(d1::SortedUniqueDataColumn{T1, T2, T3}, d2::SortedUniqueDataColumn{T1, T2, T3}) = intersect!(d1, d2.list)
#intersect
function intersect{T1, T2, T3}(d1::SortedDataColumn{T1, T2, T3}, d2::SortedDataColumn{T1, T2, T3})
	numcol(d1) != numcol(d2) && error("Column number mismatch")
	(inds1, inds2, inds1Rec, inds2Rec) = intersectIndex(d1.list, d2.list)
	N = length(inds1) + length(inds2)
	listNew = Array(T1, N)
	listNew[inds1Rec] = d1.list[inds1]
	listNew[inds2Rec] = d2.list[inds2]
	xNew = Array(T2, N, numcol(d1))
	xNew[inds1Rec, :] = d1[inds1, :]
	xNew[inds2Rec, :] = d2[inds2, :]
	return(SortedDataColumn(SortedVector(listNew, alreadySorted=true), xNew, deepcopy(d1.header)))
end
function intersect{T1, T2, T3}(d1::SortedUniqueDataColumn{T1, T2, T3}, s::SortedUniqueVector{T1})
	dCopy = deepcopy(d1)
	intersect!(dCopy, s)
	return(dCopy)
end
intersect{T1, T2, T3}(d1::SortedUniqueDataColumn{T1, T2, T3}, d2::SortedUniqueDataColumn{T1, T2, T3}) = intersect(d1, d2.list)
#union! (efficiency could be improved by explicit while loop over d1 and d2)
union!{T1, T2, T3}(d1::SortedDataColumn{T1, T2, T3}, d2::SortedDataColumn{T1, T2, T3}) = insert!(d1, d2)
function union!{T1, T2, T3}(d1::SortedUniqueDataColumn{T1, T2, T3}, d2::SortedUniqueDataColumn{T1, T2, T3})
	numcol(d1) != numcol(d2) && error("Column number mismatch")
	if length(d2) > 0
		if length(d1) == 0
			insert!(d1, d2)
		else
			for n = 1:size(d2, 1)
				if d2.list[n] < d1.list[1]
					unshift!(d1, d2.list[n], vec(d2[n, :]))
				elseif d2.list[n] > d1.list[end]
					push!(d1, d2.list[n], vec(d2[n, :]))
				else
					r = search(d1.list, d2.list[n])
					if isempty(r)
						insert!(d1.list.x, r.start, d2.list[n])
						[ insert!(d1.x[j], r.start, d2.x[j][n]) for j = 1:numcol(d2) ]
					end
				end
			end
		end
	end
	return(true)
end
#union
function union{T1, T2, T3}(d1::SortedColumnStructure{T1, T2, T3}, d2::SortedColumnStructure{T1, T2, T3})
	dCopy = deepcopy(d1)
	union!(dCopy, d2)
	return(dCopy)
end
#trim!, trim
SortedVectors.trim!{T1, T2, T3}(d::SortedColumnStructure{T1, T2, T3}, LB::T1, UB::T1) = deletenotat!(d, trimRange(d.list, LB, UB))
function SortedVectors.trim{T1, T2, T3}(d::SortedColumnStructure{T1, T2, T3}, LB::T1, UB::T1)
	dCopy = deepcopy(d)
	trim!(dCopy, LB, UB)
	return(dCopy)
end
#meshIndex, mesh (note, output of mesh always SortedUnique since mesh always unique)
SortedVectors.meshIndex{T1, T2, T3}(d::SortedColumnStructure{T1, T2, T3}, m::SortedUniqueVector{T1}; allowForwardLooking::Bool=true) = meshIndex(d.list, m, allowForwardLooking=allowForwardLooking)
SortedVectors.mesh{T1, T2, T3}(d::SortedColumnStructure{T1, T2, T3}, m::SortedUniqueVector{T1}; allowForwardLooking::Bool=true) = SortedUniqueDataColumn(m, d[meshIndex(d, m, allowForwardLooking=allowForwardLooking), :])










#Non-exported function for getting the complement of a set of indices over some range 1:N
function setdiffIndex(N::Int, inds::IntSet)
	indsOut = setdiff(IntSet(1:N), inds)
	return(collect(indsOut))
end
function setdiffIndex(N::Int, inds::Vector{Int}; alreadySorted::Bool=false)
	alreadySorted == false && sort!(inds)
	return(setdiffIndex(N, IntSet(inds)))
end
function setdiffIndex(N::Int, r::UnitRange)
	r.start < 1 && error("Bounds error on UnitRange")
	r.stop > N && error("Bounds error on UnitRange")
	return(setdiffIndex(N, IntSet([r.start:r.stop])))
end



#Non-exported function for building a vector of ASCIIString with each element set to ""
function buildAsciiVector(N::Int)
	x = Array(ASCIIString, N)
	fill!(x, "")
	return(x)
end























end # module
