module TensorBase

using Reexport

@reexport using Einsum

export unfold,
	   unfold_idx,
	   krprod

"""
    M = unfold(A, i)

Unfold tensor A along mode i. Returns a matrix M, with size(A,i) rows.
The columns are populated by linear indexing through A, ignoring mode i.
"""
function unfold{T<:Number,N}(A::Array{T,N},i::Integer)
	# dims not unfolded
	j = setdiff(1:N,i) 

	# Permute dims of A, bring unfolded dimension to front
	B = permutedims(A,vcat(i,j))

	# size of unfolded dimension
	n = size(B,1)
	
	return reshape(B,(n,div(length(B),n)))
end

"""
    M,idx = unfold_idx(A, i)

Unfold tensor A along mode i. Same as `unfold()` but, in addition to returning
the unfolded matrix, `M`, it also returns `idx` -- a Tuple of arrays
containing the indices of each column in the unfolded matrix.

For example, `M,idx = unfold_idx(randn(3,5,2),2)` produces
`idx = ([1,2,3,1,2,3],[1,1,1,2,2,2]))`
"""
function unfold_idx{T<:Number,N}(A::Array{T,N},i::Integer)
	# dims not unfolded
	j = setdiff(1:N,i) 
	jd = size(A, j...)

	# Permute dims of A, bring unfolded dimension to front
	B = permutedims(A,vcat(i,j))
	
	# size of unfolded dimension
	n = size(B,1)
	
	return ( reshape(B,(n,div(length(B),n))) , ind2sub(jd,1:prod(jd)) ) 
end

"""
    C = krprod(A, B)

Compute the Khatri-Rao product of two matrices, A * B.
"""
function krprod(A::Matrix, B::Matrix)
	
	# determine indices
	H = size(A,2)
	@assert H == size(B,2)
	IJ = size(A,1)*size(B,1)

	# preallocate result
	C = Array(typeof(A[1]*B[1]),IJ,H)
	
	# compute khatri-rao product
	for h = 1:H
		ij = 1
		for ai in sub(A,:,h)
			for bj in sub(B,:,h)
				C[ij,h] = ai*bj
				ij += 1
			end
		end
	end

	return C
end


end