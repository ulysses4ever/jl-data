# Linear fractional transformation "lift"

module Lifts

import Base.inv, Base.isequal, Base.show, Base.hash
import Base.==, Base.*, Base.getindex
export Lift, isequal, call


const complex_infinity = Inf + Inf * im

immutable Lift
    M::Array{Complex{Float64},2}
    function Lift(a, b, c, d)
        if isinf(a) || isinf(b) || isinf(c) || isinf(d)
            error("Arguments must be finite: " * string((a,b,c,d) ))
        end

        if a*d-b*c == 0
            error("Singularity detected: " * string((a,b,c,d)) )
        end

        new( [ a b; c d])
    end
end

function Lift(M::Array)
    return Lift(M[1,1], M[1,2], M[2,1], M[2,2])
end

function Lift()
    return Lift(1,0,0,1)
end

# a --> 0, b-->1, and c--> oo
function Lift(a::Number, b::Number, c::Number)
    if a==b || b==c || a==c
        error("Three arguments must be distinct: "*string((a,b,c)))
    end

    if isinf(a)
        return Lift(0, b-c, 1, -c)
    end

    if isinf(b)
        return Lift(1, -a, 1, -c)
    end

    if isinf(c)
        return Lift(1, -a, 0, b-a)
    end

    # if all args are finite
    aa = (b-c)
    bb = (-a)*(b-c)
    cc = (b-a)
    dd = (-c)*(b-a)
    return Lift(aa,bb,cc,dd)
end

# a-->aa, b-->bb, c-->cc
function Lift(a::Number, aa::Number,
              b::Number, bb::Number,
              c::Number, cc::Number)
    f = Lift(a,b,c)
    g = Lift(aa,bb,cc)
    return inv(g)*f
end


#### Equality checking ####

# These need to be rewritten

function isequal(f::Lift, g::Lift)
    return f[0]==g[0] && f[1]==g[1] && f[Inf]==g[Inf]
    # h = f * inv(g)
    # I = h.M
    # return I[1,1]==I[2,2] && I[1,2]==I[2,1]==0
end

==(f::Lift,g::Lift) = isequal(f,g)

# Inverse transformation
function inv(L::Lift)
    a = L.M[1,1]
    b = L.M[1,2]
    c = L.M[2,1]
    d = L.M[2,2]
    return Lift(d,-b,-c,a)
end

# Composition
*(A::Lift, B::Lift) = Lift(A.M * B.M)

# Function application
function getindex(A::Lift, x::Number)
    if isinf(x)
        a = A.M[1,1]
        b = A.M[2,1]
        if b==0
            return complex_infinity
        end
        return a/b
    end
    w = A.M * [ x+0im ; 1.+0im ]
    if w[2] == 0
        return complex_infinity
    end
    return w[1]/w[2]
end

# call(A::Lift, x::Number) = A[x]

(A::Lift)(x::Number) = A[x]

function show(io::IO, L::Lift)
    print(io, "Lift( ",
          L.M[1,1], " , ",
          L.M[1,2], " , ",
          L.M[2,1], " , ",
          L.M[2,2], " )"
          )
end


function hash(f::Lift, h::UInt64 = UInt64(0))
    z = 0. + 0.*im # kludge to make -0.0 and -0.0im into +versions
    a = f[0]+z
    b = f[1]+z
    c = f[Inf]+z
    return hash(a,hash(b,hash(c,h)))
end


end # end of module "Lifts"
