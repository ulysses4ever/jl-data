# Linear fractional transformation "lift"

module Lifts

import Base.inv, Base.isequal
export Lift, isequal


const complex_infinity = Inf + Inf * im

immutable Lift
    M::Array{Complex{Float64},2}
    function Lift(a, b, c, d)
        if isinf(a) || isinf(b) || isinf(c)
            error("Arguments must be finite: " * string((a,b,c,d) ))
        end

        dd = a*d-b*c
        if dd == 0
            error("Singularity detected: " * string((a,b,c,d)) )
        end

        new( [ a b; c d])
    end
end

function Lift(M::Array)
    return Lift(M[1,1], M[1,2], M[2,1], M[2,2])
end

function Lift()
    return Lift(1,0,0,1)
end

# a --> 0, b-->1, and c--> oo
function Lift(a::Number, b::Number, c::Number)
    if a==b || b==c || a==c
        error("Three arguments must be distinct: "*string((a,b,c)))
    end

    if isinf(a)
        return Lift(0, b-c, 1, -c)
    end

    if isinf(b)
        return Lift(1, -a, 1, -c)
    end

    if isinf(c)
        return Lift(1, -a, 0, b-a)
    end

    # if all args are finite
    aa = (b-c)
    bb = (-a)*(b-c)
    cc = (b-a)
    dd = (-c)*(b-a)
    return Lift(aa,bb,cc,dd)

end

#### Equality checking ####

# These need to be rewritten
# isequal(f::Lift, g::Lift) = f.M == g.M || f.M == -g.M
# ==(f::Lift,g::Lift) = isequal(f,g)

# Inverse transformation
function inv(L::Lift)
    a = L.M[1,1]
    b = L.M[1,2]
    c = L.M[2,1]
    d = L.M[2,2]
    return Lift(d,-b,-c,a)
end

# Composition
*(A::Lift, B::Lift) = Lift(A.M * B.M)

# Function application
function getindex(A::Lift, x::Number)
    if isinf(x)
        a = A.M[1,1]
        b = A.M[2,1]
        if b==0
            return complex_infinity
        end
        return a/b
    end
    w = A.M * [ x+0im ; 1.+0im ]
    if w[2] == 0
        return complex_infinity
    end
    return w[1]/w[2]
end


end # end of module "Lifts"
