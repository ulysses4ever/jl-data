include("Task_algo.jl")


#a(k)  need c(k-1)
#b(k)  need c(k-1)
#T(k) need a(k) and b(b) ;
#c(k) T(k) ;
#both action require 1 second to execute 



#Create the state model
etat = State() ;
tacheAcreer = ["a","b","c","T"] ;  
for i in tacheAcreer
    etat.states[i] = DictChannel() 
    put!(etat.states[i],0,true) ; 
end




#create the dependancy between state :

depend_tache_a = TaskDependancy() ; 
depend_tache_a.dependency = [("c",-1)] ; 

depend_tache_b = TaskDependancy() ; 
depend_tache_b.dependency = [("c",-1)] ; 

depend_tache_T = TaskDependancy() ; 
depend_tache_T.dependency = [("a",0),("b",0)] ; 



depend_tache_c = TaskDependancy() ; 
depend_tache_c.dependency = [("T",0)] ; 



#Create a node with one procesor :
node = Nodes(2) ; 
#create a canal connection of 10 Gbits/s
canal = Canal(10.0*1024) 

#create the task 
tache_a = Task_algo("a",depend_tache_a,1,1.0,node) ;
tache_b = Task_algo("b",depend_tache_b,1,1.0,node) ;
tache_c = Task_algo("c",depend_tache_c,1,1.0,node) ;
#create the Data Transfer :
tache_T = DataTransfer("T",depend_tache_T,1,32.0,canal)

##
#on se place dans le cas ou il y a deux proceseurs.

N_max = 10; 
keepGoing = true ; 



ListeAFaire = {tache_a,tache_b,tache_c,tache_T}  ; 


function eventloop(tache::Task_algo,etat::State,iterMax=100)
	iterationNumber=tache.iterationNumber
	taskName=tache.taskName
	isReady(tache,etat) ; 
	##on attent q'un processuer soit libre pour effectuer le calcul
	nodeToExecute = tache.nodeToExecute ;
	index_node =getOneProc(nodeToExecute)
	sleep(tache.timeToCompute) ; 
	nodeToExecute.availabeWorker[index_node] = true ; 
	notify(nodeToExecute.cond_take; all=false)

	put!(etat.states[taskName],iterationNumber,true) ;
	println(taskName)
	if (iterationNumber<iterMax)
		@schedule(eventloop(tache +1 ,etat,iterMax)) ;
	end
end



function eventloop(dataTransferTask::DataTransfer,etat::State,iterMax=100)
	iterationNumber=dataTransferTask.iterationNumber ; 
	taskName=dataTransferTask.taskName  
	
	#on attend que la tache soit faisable
	isReady(dataTransferTask,etat) ; 

	##on attent que le canal de communication soit libre
	canalToTransfer = dataTransferTask.canalToTransfer ;
	timeDataTrasnfer = dataTransferTask.dataSize/canalToTransfer.speed ; 

	if( !canalToTransfer.availabe )
		wait(canalToTransfer.cond_take)
	end
	canalToTransfer.availabe = false ; 
	
	sleep(timeDataTrasnfer) ; 
	canalToTransfer.availabe = true ; 
	notify(canalToTransfer.cond_take; all=false)

	put!(etat.states[taskName],iterationNumber,true) ;
	println(taskName)
	if (iterationNumber<iterMax)
		@schedule(eventloop(dataTransferTask +1 ,etat,iterMax)) ; #on 
	end
end





for t in ListeAFaire
	@async begin 
		eventloop(t,etat,N_max)
	end 
end




for i in ["a","b","c"]
	wait(etat.states[i],N_max)
end








