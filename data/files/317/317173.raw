
# an iterator for an NxT matrix, N is number of features, T is number of time points
type VectorTimeSeries
  X::Array
end

Base.start(v::VectorTimeSeries) = 1
Base.done(v::VectorTimeSeries, state) = size(v.X)[2] == state-1
Base.next(v::VectorTimeSeries, state) = v.X[:, state], state+1


# a simple spiking network
type SSNetwork

  t::Integer  # the number of steps that have been taken
  dt::Float64 # the time step of the network simulation

  num_neurons::Integer
  num_inputs::Integer
  spike_times::Array   # an array of the most recent spike times for each input and neuron
  tau::Array           # an array of membrane time constants

  W::SparseMatrixCSC   # a sparse matrix of network connection weights
  Win::SparseMatrixCSC # sparse input weight matrix

  input_stream::Type   # an iterable object

  tau_synapse::Float64 # synaptic output time constant for each input/neuron

  u:Array              # the membrane potential
  urest::Float64       # the resting membrane potential
  u0::Array            # the membrane potential threshold
  ualpha::Array        # the membrane potential scaling

  tau_abs:Float64      # the absolute refractory period
  tau_refr:Float64     # the soft refractory period

  r0::Array            # baseline firing rate

  function SSNetwork(num_neurons, num_inputs, dt=1e-4, spike_history_length=10)
    this = new()

    this.num_neurons = num_neurons
    this.num_inputs = num_inputs

    this.t = 0
    this.dt = dt

    this.state = zeros(num_neurons)
    this.tau = zeros(num_neurons)

    this.spike_times = ones(num_inputs+num_neurons, spike_history_length)*-Inf

    this.W = sparse([], [], [], num_neurons, num_neurons+num_inputs)

    this.tau_synapse = ones(num_neurons + num_inputs)*0.010

    this.u = ones(num_neurons)*-0.070
    this.urest = ones(num_neurons)*-0.070
    this.u0 = ones(num_neurons)*-0.055
    this.ualpha = 1

    this.r0 = ones(num_neurons)*5

    return this
  end
end


# run the network for a single time step
function step(net)

  the_t = net.t*net.dt

  # get the input spikes
  x = Array(Bool, net.num_inputs)
  if !done(net.input_stream, net.t)
    x,tt = next(net.input_stream, net.t)
  end

  # roll the input spikes that have occurred
  i = find(x)
  net.spike_times[i, 1:end-1] = net.spike_times[i, 2:end]
  net.spike_times[i, end] = the_t

  # compute the EPSPs
  total_psp = sum(synapse_function(net.t, net.spike_times, net.tau_synapse), 2)

  # update the membrane potential
  net.u = net.urest + net.W*total_psp
  net.t += 1

  # compute the gain function
  g = net.r0*log(1 + exp( (net.u - net.u0) / net.ualpha)

  # compute the refractory period
  rr = (the_t - net.spike_times[num_inputs:end, 1] - net.tau_abs).^2
  r = rr ./ (net.tau_refr.^2 + rr)

  # determine firing probabilites
  p = 1. / (1. + exp(-u))

  # sample from a uniform distribution to determine which neurons fire
  r = rand(net.num_neurons)
  i = find(r .> p) + net.num_inputs

  # add the new spike times to the spike times array
  net.spike_times[i, 1:end-1] = net.spike_times[i, 2:end]
  net.spike_times[i, end] = the_t

  # reset the state of the neurons that fired
  net.state[i] = 0

end

# computes an exponential PSP at time t resulting from input spikes at spike_times
function synapse_function(t, spike_times, time_const)
  return exp(-(t - spike_times) ./ time_const)
end


