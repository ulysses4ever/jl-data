using Wavelets

type DataSimulation
	timeToCompute_B::Float64 
	timeToCompute_X::Float64 
	timeToCompute_Wavelet_compute::Array{Float64,1} 
	timeToCOmpute_update::Float64 
	timeToCOmpute_Wavelet_sum::Float64 
	timeToCompute_P::Float64 
	timeToCompute_T::Float64 
	timeToCompute_Multiplier::Float64 
	timeToCompute_Dct::Float64 ;
	Nnode::Int64 ; 
	Nproc::Int64 ; 
	nfreq::Int64 ;
	nx::Int64  ;
	etat::State ;
	waveletList::Array{Any,1} ;
	canal::Canal ; 
	NprocDct::Int64 ; 
	DataSimulation()= new(0.,0.,[0.],0.,0.,0.,0.,0.,0.,0,0,0,0,State(),Array(Any,1),Canal(0.),0 ) ;

end 

function DataSimulation(nx::Int64,nfreq::Int64,waveletList)
	temp = DataSimulation()

	nrep = 2
	temp.timeToCompute_B = mean([ ComputeTime_B(n_x) for i in [1:nrep]])
	temp.timeToCompute_X = mean( [ComputeTime_X(n_x) for i in [1:nrep]])
	temp.timeToCompute_Wavelet_compute = [ mean( [Wavelet_compute(n_x,wt ) for i in [1:nrep]]) for wt in waveletList ]
	temp.timeToCOmpute_update = mean([ update_multiplier(n_x) for i in [1:nrep]]) 
	temp.timeToCOmpute_Wavelet_sum = mean([ Wavelet_sum(n_x,nWavelet) for i in [1:nrep]]) 
	temp.timeToCompute_P =  mean([ ComputeTime_P(n_x) for i in [1:nrep]])  ;
	temp.timeToCompute_T  =  mean([ ComputeTime_T(n_x) for i in [1:nrep]]) ;
	temp.timeToCompute_Multiplier = mean([ update_multiplier(n_x) for i in [1:nrep]]) ;
	temp.timeToCompute_Dct = mean([ dct_compute(n_x,nfreq) for i in [1:10]]) ;
	temp.nx= nx ; 
	temp.nfreq =nfreq ; 
	temp.NprocDct = 40 ; 
	return(temp) ; 
end

function timeOneStep(dataSim::DataSimulation)
	out = 0 ; 
	out += dataSim.timeToCompute_B ;
	out += dataSim.timeToCompute_X ;
	out += 2*sum(dataSim.timeToCompute_Wavelet_compute) ;
	out += dataSim.timeToCOmpute_update ;
	out += dataSim.timeToCOmpute_Wavelet_sum ;
	out += dataSim.timeToCompute_Multiplier ;
	out += 2*dataSim.timeToCompute_Dct ;
	return(out) ; 

end

function timeOneStep(dataSim::DataSimulation,nprocDCT::Int64)
	out = 0 ; 
	out += dataSim.timeToCompute_B ;
	out += dataSim.timeToCompute_X ;
	out += 2*sum(dataSim.timeToCompute_Wavelet_compute) ;
	out += dataSim.timeToCOmpute_update ;
	out += dataSim.timeToCOmpute_Wavelet_sum ;
	out += dataSim.timeToCompute_Multiplier ;
	out += 2*dataSim.timeToCompute_Dct/nprocDCT ;
	return(out) ; 

end



function ComputeTime_X(npix::Int64)
#Calcul du temps pour executer l'operation : 
#requiert le calcul d'une FFT + une FFT inverse sur
	Q_fft = randn(npix,npix) ; 
	B = randn(npix,npix) ; 
	X = zeros(npix,npix) ;
	tic();
	ifft(fft(B)./Q_fft)
	t=toc();

end



function ComputeTime_B(npix::Int64)
	#on  doit sommer 6 matrices de tailles npix*npix

	X = randn(npix,npix,6) ; 
	tic();
	sum(X,3)
	t=toc();

end


function ComputeTime_P(npix::Int64)
	#on  doit sommer 6 matrices de tailles npix*npix

	X = randn(npix,npix) ;
	gamma = randn(npix,npix) ; 
	tic();
	P = max(0,X - 0.5.*gamma)
	t=toc();

end


function ComputeTime_T(npix::Int64)
	#on  doit sommer 6 matrices de tailles npix*npix

	T = randn(npix,npix) ;
	Gamma =  randn(npix,npix) ;
	tic();
	T  = max(0,1- 0.5.*0.6./abs(T))
	t=toc();

end



function update_multiplier(npix::Int64)
	#on  doit sommer 6 matrices de tailles npix*npix
	gamma = randn(npix,npix)
	A = randn(npix,npix) ; 
	B = randn(npix,npix) ;
	

	tic();
	gamma += gamma + 0.05*(A-B) ;
	t=toc();

end




function Wavelet_sum(npix::Int64,nwavelet)
#Calcul du temps pour executer l'operation : 
#requiert le calcul d'une FFT + une FFT inverse sur
	X = randn(npix,npix,nwavelet)
	tic();
	sum(X,3)
	t=toc();

end


function Wavelet_sum(npix::Int64,nwavelet)
#Calcul du temps pour executer l'operation : 
#requiert le calcul d'une FFT + une FFT inverse sur
	X = randn(npix,npix,nwavelet)
	tic();
	sum(X,3)
	t=toc();

end


function Wavelet_compute(npix::Int64,wt)
	X = randn(npix,npix) ;
	tic() ; 
	dwt(X,wavelet(wt)) ; 
	toc() ;
end


function dct_compute(npix::Int64,nfreq::Int64)
	X = randn(128,128,nfreq) ;
	tic() ; 
	dct(X,3) ; 
	temp=toc() ;
	temp = npix*npix*temp/(128*128) ; 
end






function simulate(dataSim::DataSimulation,N_max::Int64)


	timeToCompute_B = dataSim.timeToCompute_B 
	timeToCompute_X = dataSim.timeToCompute_X  
	timeToCompute_Wavelet_compute = dataSim.timeToCompute_Wavelet_compute  
	timeToCOmpute_update = dataSim.timeToCOmpute_update 
	timeToCOmpute_Wavelet_sum = dataSim.timeToCOmpute_Wavelet_sum  
	timeToCompute_P = dataSim.timeToCompute_P
	timeToCompute_T = dataSim.timeToCompute_T  
	timeToCompute_Multiplier = dataSim.timeToCompute_Multiplier 
	timeToCompute_Dct = dataSim.timeToCompute_Dct 
	n_x = dataSim.nx ; 
	n_freq = dataSim.nfreq ; 
	NprocDct = dataSim.NprocDct ; 

	Nnode=dataSim.Nnode ; 
	Nproc=dataSim.Nproc; 
	etat = dataSim.etat ;
	canal = dataSim.canal ;

listTask = {}
#X term 

#on definit les nooeuds
node_2 = [Nodes(Nproc) for i in 1:Nnode] ; 
node_sync = Nodes(40) ; 
node_dct = Nodes(NprocDct) ;
node = Array(Nodes, 1) ; resize!(node,n_freq) ;
for i_freq in 1:nfreq
	index = i_freq%Nnode +1
	node[i_freq] = node_2[ index ]  ; 
end


	


for i_freq in 1:n_freq
	X = string("X_",i_freq) 
	Dependency_X = TaskDependancy([( string("B_",i_freq) ,0 )]) ;
	timeToCompute = timeToCompute_X
	temp =  Task_algo(X,Dependency_X,1,timeToCompute,node[i_freq]) 
	push!(listTask,temp)

	transfer_X__ = string("transfer_X_",i_freq) 
	Dependency_X = TaskDependancy([( string("X_",i_freq) ,0 )]) ;
	timeToCompute = timeToCompute_X
	temp =  DataTransfer(transfer_X__,Dependency_X,1,n_x*n_x*64.0/(1024*1024),canal) 
	push!(listTask,temp)

	B = string("B_",i_freq) 
	Dependency_B = TaskDependancy([( string("Wavelet_sum_",i_freq) ,0 ),(string("Gamma_P_",i_freq),-1),(string("transfer_S_",i_freq),0)  ]) ;
	timeToCompute =timeToCompute_B
	temp =  Task_algo(B,Dependency_B,1,timeToCompute,node[i_freq])
	push!(listTask,temp)
	
end


taskName = "transfer_X" ;
Dependency=Array((ASCIIString,Int64),1) ; resize!(Dependency,nfreq) ;
for i_freq in 1:nfreq
	Dependency[i_freq] = (string("transfer_X_",i_freq),0) ;
end
Dependency = TaskDependancy( Dependency);
temp =  Task_algo(taskName,Dependency,1,0.0001,node_sync)  
push!(listTask,temp) 





for i_freq in 1:nfreq
	Wavelet_sum_str = string("Wavelet_sum_",i_freq)  ; 
	dependency_string=Array((ASCIIString,Int64),1) ; resize!(dependency_string,nWavelet) ;
	for i_wavelet in [1:nWavelet] 
		dependency_string[i_wavelet] =( string("Wavelet_compute_transpose_",i_wavelet,"_",i_freq),0 )  ; 
	end
	
	Dependency_Wavelet_sum = TaskDependancy(dependency_string) ;
	timeToCompute =timeToCOmpute_Wavelet_sum ;
	temp =  Task_algo(Wavelet_sum_str,Dependency_Wavelet_sum,1,timeToCompute,node[i_freq]) 
	push!(listTask,temp)	
end


for i_freq in 1:nfreq , i_wavelet in [1:nWavelet]
	Wavelet_compute_transpose=string("Wavelet_compute_transpose_",i_wavelet,"_",i_freq)  ; 
	Dependency_Wavelet_compute_transpose = TaskDependancy( [( string("Gamma_T_",i_wavelet,"_",i_freq),-1 ) ] );
	timeToCompute = timeToCompute_Wavelet_compute[i_wavelet]
	temp =  Task_algo(Wavelet_compute_transpose,Dependency_Wavelet_compute_transpose,1,timeToCompute,node[i_freq]) 
	push!(listTask,temp)
end



##on ajoute les taches 



#P term 



Dependency_P = Dict() ;
P = [string("P_",i_freq) for i_freq in [1:nfreq] ]
for i_freq in 1:nfreq
	P = string("P_",i_freq)  ; 
	Dependency_P[i_freq] = TaskDependancy( [( string("X_",i_freq) ,0 ),(string("Gamma_P_",i_freq),-1)  ] );
	timeToCompute = timeToCompute_P ;
	temp =  Task_algo(P,Dependency_P[i_freq],1,timeToCompute,node[i_freq])  ;
	push!(listTask,temp) 	;
end

Dependency_Gamma_P = Dict() ;
for i_freq in 1:nfreq
	taskName = string("Gamma_P_",i_freq)
	Dependency_Gamma_P = TaskDependancy( [( string("X_",i_freq) ,0 ),(string("P_",i_freq),0)  ] ); 	
	timeToCompute = timeToCompute_Multiplier ;
	temp =  Task_algo(taskName,Dependency_Gamma_P,1,timeToCompute,node[i_freq]) 
	push!(listTask,temp) 
end






#S term 
for i_freq in 1:nfreq

	taskName = string("Compute_dct_X_",i_freq) ;
	Dependency = TaskDependancy( [(string("transfer_X"),0) ] );
	temp =  Task_algo(taskName,Dependency,1,timeToCompute_Dct/nfreq,node_dct)  ###A changer
	push!(listTask,temp) 


	taskName = string("S_",i_freq) ;
	Dependency = TaskDependancy( [(string("Compute_dct_X"),0) ] );
	temp =  Task_algo(taskName,Dependency,1,timeToCompute_Multiplier,node_dct)  ###A changer
	push!(listTask,temp) 


	taskName = string("Gamma_S_",i_freq) ;
	Dependency_Gamma_S_ = TaskDependancy( [( string("S_",i_freq) ,0 ) ] );
	temp =  Task_algo(taskName,Dependency_Gamma_S_,1,timeToCompute_Multiplier,node_dct) 
	push!(listTask,temp) 

	taskName = string("Compute_idct_S_",i_freq) ;
	Dependency = TaskDependancy( [(string("Gamma_S_",i_freq),-1) ] );
	temp =  Task_algo(taskName,Dependency,1,timeToCompute_Dct/nfreq,node_dct)  ###A changer
	push!(listTask,temp) 

	transfer_S  =  string("transfer_S_",i_freq) ;
	Dependency_transfer_S_ = TaskDependancy( [ ( "Compute_idct_S" ,0 ) ] );
	temp =  DataTransfer(transfer_S,Dependency_transfer_S_,1,n_x*n_x*64.0/(1024*1024),canal) ; 
	push!(listTask,temp) 

end




taskName = "Compute_dct_X" ;
Dependency=Array((ASCIIString,Int64),1) ; resize!(Dependency,nfreq) ;
for i_freq in 1:nfreq
	Dependency[i_freq] = (string("Compute_dct_X_",i_freq),0) ;
end
Dependency = TaskDependancy( Dependency);
temp =  Task_algo(taskName,Dependency,1,0.0001,node_sync)  ###A changer
push!(listTask,temp) 



taskName = "Compute_idct_S" ;
Dependency=Array((ASCIIString,Int64),1) ; resize!(Dependency,nfreq) ;
for i_freq in 1:nfreq
	Dependency[i_freq] = (string("Compute_idct_S_",i_freq),0);
end
Dependency = TaskDependancy( Dependency);
temp =  Task_algo(taskName,Dependency,1,0.0001,node_sync)  ###A changer
push!(listTask,temp) 





#T term 

for i_wavelet in [1:nWavelet] , i_freq in [1:nfreq]

	Gamma_T =  string("Gamma_T_",i_wavelet,"_",i_freq)  ;
	Dependency_Gamma_T = TaskDependancy( [(string("T_",i_wavelet,"_",i_freq) ,0 ) ] );
	temp =  Task_algo(Gamma_T,Dependency_Gamma_T,1,timeToCompute_Multiplier,node[i_freq])  ;  
	push!(listTask,temp) 

	T = string("T_",i_wavelet,"_",i_freq)   ; 
	Dependency_T  = TaskDependancy( [ (string("Wavelet_compute_",i_wavelet,"_",i_freq),0 ) ] );
	temp =  Task_algo(T,Dependency_T,1,timeToCompute_T,node[i_freq])  ;  
	push!(listTask,temp)

	Wavelet_compute_str=string("Wavelet_compute_",i_wavelet,"_",i_freq)  ; 
	Dependency_Wavelet_compute  = TaskDependancy( [ ( string("X_",i_freq) ,0 ) ] );
	temp =  Task_algo(Wavelet_compute_str,Dependency_Wavelet_compute,1,timeToCompute_Wavelet_compute[i_wavelet],node[i_freq])  ;  
	push!(listTask,temp)

end



shuffle!(listTask) ;


for a in  listTask
	i = a.taskName ; 
    etat.states[i] = DictChannel() 
    put!(etat.states[i],0,true) ; 
end



for t in listTask
	@async begin 
		eventloop(t,etat,N_max);
	end 
end


end
