# quicksort implementation from Alogrithms course

module MyQuickSort
export myQuickSort
export pivotFirstElement
export arrayToSort

# use a global for the array
manyArrays =
  Array[
    [1,2], #1
    [1,2,3], #2
    [2,3,1], #3
    [1,2,3,4], #4
    [1,2,3,4,5,6,7,8], #5
    [1,7,3,5,5,6,7,8], #6
    [7,5,1,4,8,3,10,2,6,9], #7
    [8,10,1,9,7,2,6,3,5,4] #8
  ]

f = open("/Users/stonefruit/Dropbox/coursera_algo/QuickSort.txt")
arrayOfStrings = readlines(f)
close(f)
arrayOfInts = map(x -> parse(rstrip(x)), arrayOfStrings)

arrayToSort = arrayOfInts
# arrayToSort = manyArrays[8]

function myQuickSort(firstIndex, lastIndex)
  if lastIndex == firstIndex
    return 0
  end
#   pivotIndex = firstIndex - 1 + pivotFirstElement(firstIndex, lastIndex)
#   pivotIndex = firstIndex - 1 + pivotLastElement(firstIndex, lastIndex)
  pivotIndex = pivotMedianOfThree(firstIndex, lastIndex)


  arrayToSort[firstIndex], arrayToSort[pivotIndex] = arrayToSort[pivotIndex], arrayToSort[firstIndex]

#   save dividing index
  dividerIndex = firstIndex
#   save lookup index
  lookupIndex = firstIndex + 1
#   comparisons = 0
#   compare lookup with pivot value
  for i = (firstIndex + 1):lastIndex
#     comparisons = comparisons + 1
    if arrayToSort[lookupIndex] < arrayToSort[firstIndex]
      dividerIndex = dividerIndex + 1
      arrayToSort[lookupIndex], arrayToSort[dividerIndex] = arrayToSort[dividerIndex], arrayToSort[lookupIndex]
      lookupIndex = lookupIndex + 1
    else
      lookupIndex = lookupIndex + 1
    end
  end
  arrayToSort[dividerIndex], arrayToSort[firstIndex] = arrayToSort[firstIndex], arrayToSort[dividerIndex]
  lowerDivider = dividerIndex - 1
  upperDivider = dividerIndex + 1
  firstHalf = 0
  secondHalf = 0
  if lowerDivider >= firstIndex
    firstHalf = myQuickSort(firstIndex, lowerDivider)
  end
  if upperDivider <= lastIndex
    secondHalf = myQuickSort(upperDivider, lastIndex)
  end

  return lastIndex - firstIndex + firstHalf + secondHalf
end

function pivotFirstElement(firstIndex, lastIndex)
  return 1
end

function pivotLastElement(firstIndex, lastIndex)
  return lastIndex - firstIndex + 1
end

function pivotMedianOfThree(firstIndex, lastIndex)
  numberOfElements = lastIndex - firstIndex + 1
  middleIndex = 0
  if numberOfElements % 2 == 1
    middleIndex = (lastIndex + firstIndex) ÷ 2 
  else
    middleIndex = (lastIndex + firstIndex - 1) ÷ 2
  end
  medianNum = median([arrayToSort[firstIndex], arrayToSort[lastIndex], arrayToSort[middleIndex]])
  if medianNum == arrayToSort[firstIndex]
    return firstIndex
  elseif medianNum == arrayToSort[lastIndex]
    return lastIndex
  else
    return middleIndex
  end
end


end

myQuickSort(1,10000)
# @show arrayOfInts

# @show arrayToSort
# Q1 - 162085
# Q2 - 164123
# Q3 - 138382


# before partition: [8, 10, 1, 9, 7, 2, 6, 3, 5, 4]
# comparison count: 9
# pivot: 7
# after partion: [4, 1, 2, 6, 3, 5, 7, 8, 10, 9]
# before partition: [4, 1, 2, 6, 3, 5]
# comparison count: 5
# pivot: 4
# after partion: [3, 1, 2, 4, 6, 5]
# before partition: [3, 1, 2]
# comparison count: 2
# pivot: 2
# after partion: [1, 2, 3]
# before partition: [6, 5]
# comparison count: 1
# pivot: 6
# after partion: [5, 6]
# before partition: [8, 10, 9]
# comparison count: 2
# pivot: 8
# after partion: [8, 10, 9]
# before partition: [10, 9]
# comparison count: 1
# pivot: 10
# after partion: [9, 10]
# TOTAL COMPARISONS: 20
