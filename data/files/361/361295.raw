# rewrites the expressions generated by clang

# node: the input obuff has the type annotations in the function signature and the types in the ccall as references to the same Expr object.  A deepcopy and overwrite is needed to fix hthis

# dictionary to map pointer types to desired type
# isdefined(modulename, :name) -> Bool
# use wrap_contex.commonbuf for dictionary of names that have been defined

# used to modify Petsc typealiases in function signatures
type_dict = Dict{Any, Any} (
:PetscScalar => :Float64,
:PetscReal => :Float64,
:PetscInt => :Int32,
)


# used to convert typealiases to immutable type definionts
# currently, if the key exists, it is converted
# some the values could be used in the future to specifiy additional
# behavior
typealias_dict = Dict{Any, Any} (
:Vec => 1,
:Mat => 1,
:KSP => 1,
:PC => 1,
:PetscViewer => 1,
:PetscOption => 1,
:IS => 1,
:ISLocalToGlobalMapping => 1,
:ISColoring => 1,
:PetscLayout => 1,
:VecScatter => 1
)


# dictionary for rewriting pointer type annotations in function signatures
# Ptrs are converted to Union(Ptr{ptype}, StridedArray{ptype}, Ptr{Void})
# the objects in the typealias_dict are added automatically
# the keys can be either symbols or expressions
# if the entire type annotation matches a key, it is replace
# if any symbol in the type annotation matches a key, it is replaced
ptr_dict = Dict{Any, Any} (
#:(Ptr{PetscInt}) => :(Union(Ptr{PetscInt}, StridedArray{PetscInt}, Ptr{Void}))
#:Mat => :Mat{S <: type_dict[:PetscScalar]}
)

for i in keys(typealias_dict)
  get!(ptr_dict, i, :($i{PetscScalar}))
end

println("ptr_dict = ", ptr_dict)


# used to replace symbols on the right hand side of constant definitions
# the type_dict is automatically includes
const_dict = Dict{Any, Any} (
:NULL => :C_NULL,
)


for i in keys(type_dict)
  get!(const_dict, i, type_dict[i])
end

# definitions that will be provided, but don't come from Petsc
# mostly MPI stuff
const_defs = Dict{Any, Any} (
:MPI_COMM_SELF => 1,
:MPI_Comm => 1,
:comm_type => 1,
)

# used to modify ccall arguments
# the contents of type_dict are automatically included
# the type paramaterizations are from the tyepalias_dict
# are also automatically included
ccall_dict = Dict{Any, Any} (
#:Mat => :(Ptr{Void}),
:MPI_Comm => :comm_type,  # need to change ccall arg name to argname.val
)

# suffixes to add ccall argument names based on the argument type
# ex arg1 => arg1.val
ccall_argdict = Dict{Any, Any} (
:comm_type => :val,
)

for i in keys(type_dict)
  get!(ccall_dict, i, type_dict[i])
end

for i in keys(typealias_dict)
  get!(ccall_dict, i, :(Ptr{Void}))
end

const petsc_libname = :petsc1




function petsc_rewriter(obuf)

  for i=1:length(obuf)
    println("i = ", i)
    ex_i = obuf[i]  # obuf is an array of expressions

    println("ex_i = ", ex_i)
    println("typeof(ex_i) = ", typeof(ex_i))

    if typeof(ex_i) == Expr
      head_i = ex_i.head  # function
      # each ex_i has 2 args, a function signature and a function body
      println("head_i = ", head_i)

      # figure out what kind of expression it is, do the right modification
      if head_i == :function  # function declaration
       obuf[i] = process_func(ex_i)
      elseif ex_i.head == :const  # constant declaration
        obuf[i] = process_const(ex_i)
      elseif ex_i.head == :typealias  # typealias definition
        obuf[i] = fix_typealias(ex_i)
      
      else  # some other kind of expression
        println("not processing expression", ex_i)
        
        # convert to concrete types
        for j in keys(type_dict)
          replace_symbol(ex_i, j, type_dict[j])
        end

        # purge anything unknown
        tmp = are_syms_defined(ex_i)
        if tmp != 0
          obuf[i] = "#= skipping undefined expression $ex_i =#"
        end

        # for types at least, arg[2] is the type name
        obj_name = ex_i.args[2]
        if haskey(wc.common_buf, obj_name)
          delete!(wc.common_buf, obj_name)
        end
        
      end

    elseif typeof(ex_i) == ASCIIString
      obuf[i] = process_string(ex_i)
    else
      println("not processing ", typeof(ex_i))
    end  # end if Expr


  end

  return obuf  # return modified obuf
end


##### functions to rewrite function signature #####
function process_func(ex)

  @assert ex.head == :function  # this is a function declaration

  rewrite_sig(ex.args[1])  # function signature
  rewrite_body(ex.args[2])  # function body

  # now check if any undefined type annotations remain

  sum = 0
  ex_sig = ex.args[1]
  ex_body = ex.args[2]

  for i=2:length(ex_sig.args)  # loop over all arguments to the function
    # get the type annotation Expr or symbol of argument i-1 
    ex_sig_i = ex_sig.args[i].args[2]
    sum += are_syms_defined(ex_sig_i)
  end

  # now check ccall argument types
  ex_ccall = ex_body.args[1]
  ex_ccall_types = ex_ccall.args[3]  # the tuple of argument types
  sum += are_syms_defined(ex_ccall_types)
    
  if sum != 0
    return "#= skipping function with undefined symbols: \n $ex \n=#"
  end

  return ex
end

function rewrite_sig(ex)  # rewrite the function signature

  @assert ex.head == :call  # verify this is a function signature expression

  # ex.args[1] = function name, as a symbol

   # check if function contains a PetscScalar

   # if yes, add paramterization, do search and replace PetscScalar -> S
   # also add macro

   println("rewrite_sig ex = ", ex)

  # Process all arguments of the function
  # Replace all pointers with Unions(Ptr, AbstractArray...) 
  # do any other transformations in ptr_dict
  for i=2:length(ex.args)
   # each of ex.args is an expression containing arg name, argtype
    println("typeof(ex.args[$i]) = ", typeof(ex.args[i]))
    @assert typeof(ex.args[i]) == Expr  || typeof(ex.args[i]) == Symbol  # verify these are all expressions
    process_sig_arg(ex.args[i])  # process each expression
  end



   # check for any symbol that will uniquely identify which 
   # version of petsc to call
   val = contains_symbol(ex, :PetscScalar)
   for i in keys(typealias_dict)
     val += contains_symbol(ex, i)
   end

   println("contains_symbol = ", val)

  println("adding dummy arg")
  if val == 0  # if no arguments will make the function signature unique
    add_dummy_arg(ex)
  end

  println("replacing typealiases")
  # do second pass to replace Petsc typealiases with a specific type
  for i=2:length(ex.args)  
    for j in keys(type_dict)  # check for all types

    println("replacing ", j, ", with ", type_dict[j])
      replace_symbol(ex.args[i], j, type_dict[j])
    end
  end

  println("after modification rewrite_sig ex = ", ex)
end

function process_sig_arg(ex)  
# take the expression that is an argument to the function and rewrite it

   @assert ex.head == :(::)
   
   # modify args here
#   arg_name = ex.args[1]  # symbol
#   arg_type = ex.args[2]  # Expr contianing type tag
   println("ex.args[2] = ", ex.args[2])
   println("type = ", typeof(ex.args[2]))

#   if typeof(ex.args[1]) == Symbol
     
   # get only typetag expression, modify it
   ex.args[2] = modify_typetag(ex.args[2])

end

function modify_typetag(ex)

  println("\nentered modify_typetag")
  # transform entire expressions
  println("transforming entire expression")
  println("before expression = ", ex)
#  ex = get(ptr_dict, ex, ex) 

  if typeof(ex) == Expr
    println("after, ex.head = ", ex.head)
    println("ex.args = ", ex.args)
    println("ex = ", ex)
  else
    println("typeof(ex) = ", typeof(ex))
  end



  # replace individual symbols
  println("\nreplacing symbols")
  cnt = 0
  for i in keys(ptr_dict)
    println("replacing symbols ", cnt)
    println("replacingabc ", i, " in expression ", ex, " with ", ptr_dict[i])
    ex = replace_symbol(ex, i, ptr_dict[i])
    println("after replacingabc, typeof(ex) = ", typeof(ex))
    println("ex = ", ex)
#=
    if typeof(ex) == Expr
      println("ex.head = ", ex.head)
      for i=1:length(ex.args)
        println("  typeof(ex.args[$i]) = ", typeof(ex.args[i]))
      end

      for i=1:length(ex.args)
        if typeof(ex.args[i]) == Expr
          println("  ex.args[$i].head = ", ex.args[i].head)
          for j=1:length(ex.args[i].args)
            println("  typeof(ex.args[$i].args[$j] = ", typeof(ex.args[i].args[j]))
            if typeof(ex.args[i].args[j]) == Expr
              println("    ex.args[$i].args[$j].head = ", ex.args[i].args[j].head)
              for k=1:length(ex.args[i].args[j].args)
                if typeof(ex.args[i].args[j].args[k]) == Expr
                  println("      ex.args[$i].args[$j].args[$k].head = ", ex.args[i].args[j].args[k].head)
#                  println("      ex.args[$i].args[$j].args[$k] = ", ex.args[i].args[j].args[k])
                 end
               end

            end
          end
        end
      end
#      println("number of symbols = ", count_depth(0, ex))      
      println("ex.args = ", ex.args)
    end
=#
    cnt += 1
    print("\n")
  end



#  @assert ex.head == :curly || ex.head == :symbol # verify this is a typetag
  if typeof(ex) == Expr
    # replace pointer with Union of ptr, array, c_null
    if ex.head == :curly && ex.args[1] == :Ptr
      ptr_type = ex.args[2]
      ex =  :(Union(Ptr{$ptr_type}, StridedArray{$ptr_type}, Ptr{Void}))
    end
  end


  return ex
end

function add_param(ex)
# add the {S <: PetscScalar} to a function declaration

  @assert typeof(ex) == Symbol  # make sure we don't already have a paramaterization

  # could do more extensive operations here
  return :($ex{S <: PetscScalars})
end
  
function add_dummy_arg(ex)
# add a dummy argument to the function argument list
# ex is the function name + args (ie. the entire function signature)

  println("adding dummy argument to ", ex)
  @assert ex.head == :call
  len = length(ex.args)
  resize!(ex.args, len + 1)


  println("length(ex.args) = ", length(ex.args))
  println("ex.args = ", ex.args)
  # shift  args up by one
  # first arg is function name, so don't modify it

  if length(ex.args) >= 3 # if there are any args to shift
    println("shifting arguments, length(ex.args) = ", length(ex.args))
    for i=length(ex.args):(-1):3
      ex.args[i] = ex.args[i-1]
      println("ex.args[$i] = ", ex.args[i])
    end
  end

  # insert dummy argument into first position
  # the PetscScalar will get rewritten to
  # appropriate type later
  ex.args[2] = :(arg0::Type{PetscScalar})

  println("finished adding dummy arg, ex = ", ex)

end

#####  function to  rewrite the body of the function #####
function rewrite_body(ex)  # rewrite body of a function


  @assert ex.head == :block
  # ex has only one argument, the ccall
  # could insert other statements arond the ccall here?

  process_ccall(ex.args[1])
end


function process_ccall(ex)

  @assert ex.head == :ccall  # verify this is the ccall statement
  # args[1] = Expr, tuple of fname, libname
  # args[2] = return type, symbol
  # args[3] = Expr, tuple of types to ccall
  # args[4] = symbol, first argument name,
  # ...

  ex.args[1] = modify_libname(ex.args[1])  # change the library name
  ex.args[3] = modify_types(ex.args[3])
  println("changing argument names")
  ex3 = ex.args[3]  # get expression of argument types
#  ex4 = ex.args[4]  # get expression argument names

  @assert ex3.head == :tuple

  # change argument names based on argument types
  for i in keys(ccall_argdict)
    for j=1:length(ex3.args)
      if ex3.args[j] == i
        println("found argument to change as position ", j)
        argname_orig = deepcopy(ex.args[j + 3])
        suffix = ccall_argdict[i]
        ex.args[j + 3] = Expr(:., argname_orig, QuoteNode(suffix))
#        ex.args[j + 3] = :($argname_orig.($suffix))
      end
    end
  end



end

function modify_types(ex)

  @assert ex.head == :tuple

#=
  for i=1:length(ex.args)
    for j in keys(ccall_dict)
      ex.args[i] = replace_symbol(ex.args[i], j, ccall_dict[j])
i#      ex.args[i] = get(ccall_dict, ex.args[i], ex.args[i])  # get the new argument type symbol from dictionary
  end                                                      # use existing type of no key found
=#

  new_ex = deepcopy(ex) 

  for i in keys(ccall_dict)
    new_ex = replace_symbol(new_ex, i, ccall_dict[i])
  end
     
  return new_ex
end
   
function modify_libname(ex)

  @assert ex.head == :tuple

  ex.args[2] = petsc_libname  # replace libname with a new one

  return ex
end
    
##### functions to make consts into global consts #####

function process_const(ex)

  @assert ex.head == :const

  # do any replacements
  for j in keys(const_dict)
    replace_symbol(ex, j, const_dict[j])
  end
 
  ex2 = ex.args[1]  # get the assignment
#  ex.args[1] = :(global $val)  # make it global

  
  rhs = ex2.args[2]
  tmp = are_syms_defined(rhs) 
  if tmp != 0  # something is undefined
#    println("returning comment message")
    lhs = ex2.args[1]
    delete!(wc.common_buf, lhs)  # remove lh from list of defined symbols
    return "#skipping undefined $ex"  # replace expression with constant
  end

  return deepcopy(ex)
  

end


function fix_typealias(ex)

  @assert ex.head == :typealias
  new_type = ex.args[1]

    if haskey(typealias_dict, new_type)
      # construct immutable type definition
      fields = Expr(:(::), :pobj, :(Ptr{Void}))
      body = Expr(:block, fields)
      typename = Expr(:curly, new_type, :T)  # add static parameter T
      ex_new = Expr(:type, false, typename, body)
      return ex_new
    end

    if haskey(type_dict, new_type)
      delete!(wc.common_buf, new_type)  # record that the lhs symbol is now undefined
      return "# omitting typealias $ex"
    end


    # check for undefined symbols

    rhs = ex.args[2]
    tmp = are_syms_defined(rhs)
    if tmp != 0
     delete!(wc.common_buf, new_type)  # record that the lhs symbol is now undefined
     return "# skipping undefined typealias $ex"
    end
#=
    ex2 = ex.args[2]
    @assert ex2.head == :curly
    str = string(ex2.args[2])  # get the pointee type name
    println("str = ", str)
    println("str[1] = ", str[1])
    if str[1] == '_'  # if it begin with an underscore
      println("rewriting typealias")
      ex2.args[2] = :Void  # make it a Ptr{Void}
      println("ex2 = ", ex2)
      println("ex = ", ex)
    end
    # else do nothing
=#

   # if no conditions met
   return ex
end

# string processing
function process_string(ex)

#=
  if ex[1] != '#'
   println("modifying string")
   return "# $ex"
  end
=#
  return "#= $ex =#"
end

##### Misc. functions ####

function contains_symbol(ex, sym::Symbol)
# do a recursive check to see if the expression ex contains a symbol

  @assert typeof(ex) == Expr

  sum = 0  

  if ex.head == :(::)  # if this expression is a type annotation
    for i=1:length(ex.args)
      if typeof(ex.args[i]) == Expr
        sum += check_annot(ex.args[i], sym)
        
      else  # this is a symbol
#        println("    comparing ", ex.args[i], " to ", sym)
        if ex.args[i] == sym
#          println("comparison true")
         return true
        end
#        println("comparison false")
     end  # end if ... else
    end  # end for

  else  # keep recursing

    for i=1:length(ex.args)
      if typeof(ex.args[i]) == Expr
#        println("  processing sub expression ", ex.args[i])
        sum += contains_symbol(ex.args[i], sym)
#        println("  sum = ", sum)
      end  # else let this expression fall out of loop
    end  # end loop over args

  end  # end if ... else

  return sum

end

function check_annot(ex, sym::Symbol)
# check a type annotation

  for i=1:length(ex.args)
#   println("  comparing ", ex.args[i], ", to ", sym)
   if ex.args[i] == sym
#    println("  comparison true")
    return true
   end
#   println("  comparsion false")
  end

  return false
end


function replace_symbol(ex, sym_old::Symbol, sym_new)
# do a recursive descent replace one symbol with another

#  @assert typeof(ex) == Expr
#  println("receiving expression ", ex)
#  println("typeof(ex) = ", typeof(ex))
#  println("typeof(sym_old) = ", typeof(sym_old))
#  println("typeof(sym_new) = ", typeof(sym_new))


  if typeof(ex)  == Expr  # keep recursing
  
    for i=1:length(ex.args)
#        println("  processing sub expression ", ex.args[i])
#         println("  recursing expression ", ex.args[i]) 
         tmp =  replace_symbol(ex.args[i], sym_old, sym_new)
#         println("tmp = ", tmp)
#         println("typeof(tmp) = ", typeof(tmp))
#=
         if typeof(tmp) == Expr
           println("tmp.args = ", tmp.args)
         end
=#
#         println("before assignment, ex.args[$i] = ", ex.args[i])
#         println("before assignment, typeof(ex.args[$i]) = ", typeof(ex.args[i]))
         if tmp != ex.args[i]
           println("replacing ", ex.args[i], " with ", tmp)
         end
         ex.args[i] = tmp  # this shouldn't be necessary?
         
#         println("after assignment typeof(ex.args[$i]) = ", typeof(ex.args[i]))
    end  # end loop over args
 

  elseif typeof(ex) == Symbol  # if this is a symbol
#      println("  found symbol ", ex)
      if ex == sym_old
#        println("  performing replacement ", ex, " with ", sym_new)
        return sym_new
      else
#        println("  returning original symbol")
        return ex
      end
        
 else # we don't know/care what this expression is
    println("  not modify unknown expression ", ex)
    return ex
  end  # end if ... elseifa
#=
  println("Warning, got to end of replace_symbol")
  println("typeof(ex) = ", typeof(ex))
  println("ex.head = ", ex.head)
  println("ex.args = ", ex.args)
  println("ex = ", ex)
  println("typeof(ex) = ", typeof(ex))
=#
  return ex

end

function count_depth(seed::Integer, ex)
# primative attempt to count number of nodes on tree
#  println("seed = ", seed)
  if typeof(ex) == Expr
    for i=1:length(ex.args)

      seed += count_depth(seed, ex.args[i])
    end
  else
      println("ex = ", ex, " returning 1")
      return 1
  end

#  println("at end, seed = ", seed)
  return seed
end

function are_syms_defined(ex)
# check all symbols, see if they are defined by julia or by
# the wrap contex

  undefined_syms = 0  # approximate counter of undefined symbols found

  if typeof(ex)  == Expr  # keep recursing
  
    for i=1:length(ex.args)
         undefined_syms +=  are_syms_defined(ex.args[i])
    end  # end loop over args
 

  elseif typeof(ex) == Symbol  # if this is a symbol
       if isdefined(ex) || haskey(wc.common_buf, ex) || haskey(const_defs, ex)
         if isdefined(ex)
           print("in Base ")
         elseif haskey(wc.common_buf, ex)
           print("in common_buf ")
         end
         println(ex, " is defined")
 
         return 0  # symbol is defined
       else
         println(ex, " is not defined")
        return 1
       end
 else # we don't know/care what this expression is
    println("  not counting unknown expression ", ex)
    return undefined_syms
  end  # end if ... elseifa

  return undefined_syms

end
#
