###
#  Perform binary Ideal Adsorbed Solution Theory
#  Author: CoryMSimon@gmail.om
###

using Optim
using Gadfly
using DataFrames
using Roots
include("trapz.jl")  # for trapezoid rule

###
#   Isotherm models
###
function LoadingLangmuir(K::Float64, M::Float64, P::Union(DataArray{Float64}, Array{Float64}, Float64))
    """
    Compute loading of Langmuir adsorption isotherm at pressure P

    K : Langmuir constant (units: 1 / P)
    M : Saturation loading
    """
    return M .* K .* P ./ (1.0 + K .* P)
end

function LoadingQuadratic(Ka::Float64, 
                          Kb::Float64,
                          M::Float64, 
                          P::Union(DataArray{Float64}, Array{Float64}, Float64))
    """
    Compute loading of Quadratic adsorption isotherm at pressure P, eqn (8) of Tarafder

    Ka : Constant (units: 1 / P)
    Kb : Constant (units: 1 / P^2)
    M : Half of the saturation loading
    """
    return M .* (Ka + 2 * Kb * P) .* P ./ (1.0 + Ka * P + Kb * P .^ 2)
end

###
#   Functions to fit isotherm models to adsorption isotherm data
###
function FitLangmuir(df::DataFrame, loading_key::Symbol, pressure_key::Symbol, plotflag::Bool=false)
    """
    Fits data to Langmuir isotherm
    returns K, M of best fit
    """
    # define residual sum of squares (RSS) to minimize
    # x := [K, M]
    RSS(x) = sum((df[loading_key] - LoadingLangmuir(x[1], x[2], df[pressure_key])) .^ 2)
    
    # initial guesses for parameters
    M_guess = df[loading_key][end]  # guess saturation loading to be highest loading
    K_guess = df[loading_key][1] / df[pressure_key][1] / (M_guess - df[pressure_key][1])  # guess K using M_guess and first point

    # use optimization routine to find best fit params
    res = optimize(RSS, [K_guess, M_guess], method = :l_bfgs)
    K = res.minimum[1]
    M = res.minimum[2]
    
    # plot resulting fit
    if (plotflag == true)
        P = logspace(log(minimum(df[pressure_key])), log(maximum(df[pressure_key])))
        fit = plot(
               layer(x=P, y=LoadingLangmuir(K, M, P), Geom.line),
               layer(x=df[pressure_key], y=df[loading_key], Geom.point),
               Scale.x_log10,
               Guide.xlabel("Pressure"), 
               Guide.ylabel("Loading $loading_key"),
               Guide.title("Langmuir isotherm fit")
               )
        draw(PNG(6inch, 3inch), fit)
    end
    return K, M
end

function FitQuadratic(df::DataFrame, loading_key::Symbol, pressure_key::Symbol, plotflag::Bool=false)
    """
    Fit data to Quadratic isotherm
    returns Ka, Kb, M of best fit
    """
    # define residual sum of squares to minimize
    # x := [Ka, Kb, M]
    RSS(x) = sum((df[loading_key] - LoadingQuadratic(x[1], x[2], x[3], df[pressure_key])) .^ 2)
    
    # initial guesses for parameters
    M_guess = df[loading_key][end] / 2.0  # guess 1/2 loading to be 1/2 loading at last point
    Ka_guess = df[loading_key][1] / df[pressure_key][1] / (M_guess - df[pressure_key][1])  # assume Langmuir
    Kb_guess = 0.0001 # start with Langmuir assumption (Kb \approx 0)
    
    # use optimization routine to find best fit params
    res = optimize(RSS, [Ka_guess, Kb_guess, M_guess], method = :l_bfgs)
    Ka = res.minimum[1]
    Kb = res.minimum[2]
    M = res.minimum[3]
    
    # plot resulting fit
    if (plotflag == true)
        P = logspace(log(minimum(df[pressure_key])), log(maximum(df[pressure_key])))
        fit = plot(
               layer(x=P, y=LoadingQuadratic(Ka, Kb, M, P), Geom.line),
               layer(x=df[pressure_key], y=df[loading_key], Geom.point),
               Scale.x_log10,
               Guide.xlabel("Pressure"), 
               Guide.ylabel("Loading $loading_key"),
               Guide.title("Quadratic isotherm fit")
               )
        draw(PNG(6inch, 3inch), fit)
    end
    return Ka, Kb, M
end

###
#   Functions to compute spreading pressures for isotherm models (eqn 4 of Tarafder)
#   \int_0^p q(\hat{p})/ \hat{p} d\hat{p} 
###
function Π_Langmuir(p, M, K)
    """
    Spreading pressure calculated from Langmuir isotherm
    eqn 13 of Tarafder

    M: saturation loading in Langmuir isotherm
    K: Langmuir parameter in Langmuir isotherm
    p: pressure of component
    """
    return M * log(1 + K * p)
end

function Π_Quadratic(p, M, Ka, Kb)
    """
    Spreading pressure calculated from Quadratic isotherm
    eqn 15 of Tarafder

    M: 1/2 saturation loading
    Ka, Kb: parameters in Quadratic isotherm
    p: pressure of component
    """
    return M * log(1 + Ka * p + Kb * p ^ 2)
end

function Π_Interpolate(p, interpolator::InterpIrregular, df::DataFrame, pressure_key::Symbol, loading_key::Symbol)
    """
    Spreading pressure calculated from trapezoid rule on isotherm
    eqn 4 in Tarafder
    """
    first_triangle = df[loading_key][1]  # area of first triangle in integral
    p_array = linspace(df[pressure_key][1], p)  # array of pressures
    l_array = interpolator[p_array] ./ p_array  # array of function loading / p 
    return trapz(l_array, p_array) + first_triangle
end

###
#   Perform IAST
###
function IAST(p::Array{Float64}, df::DataFrame, loading_keys::Array{Symbol}, pressure_key::Symbol; method="Langmuir", plotflag::Bool=false)
    """
    Perform IAST calculation

    Follows method outlined in A. Tarafder and M. Mazzotti. A method for deriving explicit binary isotherms obeying ideal adsorbed solution theory.
                               Chem. Eng. Technol. 2012, 35, No. 1, 102-108.
    """
    @printf("Performing IAST on loading columns %s and %s using method %s\n", loading_keys[1], loading_keys[2], method)

    if (method == "Langmuir")
        # fit isotherms to Langmuir model  
        K = zeros(2)
        M = zeros(2)
        K[1], M[1] = FitLangmuir(df, loading_keys[1], pressure_key, plotflag)
        K[2], M[2] = FitLangmuir(df, loading_keys[2], pressure_key, plotflag)
        
        # solve for mole fractions in adsorbed phase s.t. spreading pressures are equal
        f(x1) = Π_Langmuir(p[1]/x1, M[1], K[1]) - Π_Langmuir(p[2]/(1-x1), M[2], K[2])  # want to be zero
        x1 = fzero(f, 0.5)

        # mole fraction in adsorbed phase
        x = [x1, 1 - x1] 

        p0 = p ./ x

        # solve for the total gas adsorbed
        q_total = 1.0 / (x[1] / LoadingLangmuir(K[1], M[1], p0[1]) + x[2] / LoadingLangmuir(K[2], M[2], p0[2]))
        
        # get loading of each component by multiplying by mole fractions
        q = x * q_total
    end
    
    if (method == "Quadratic")
        # fit isotherms to Langmuir model  
        Ka = zeros(2)
        Kb = zeros(2)
        M = zeros(2)
        Ka[1], Kb[1], M[1] = FitQuadratic(df, loading_keys[1], pressure_key, plotflag)
        Ka[2], Kb[2], M[2] = FitQuadratic(df, loading_keys[2], pressure_key, plotflag)
        
        # solve for mole fractions in adsorbed phase s.t. spreading pressures are equal
        f(x1) = Π_Quadratic(p[1]/x1, M[1], Ka[1], Kb[1]) - Π_Quadratic(p[2]/(1-x1), M[2], Ka[2], Kb[2])  # want to be zero
        x1 = fzero(f, 0.5)

        # mole fraction in adsorbed phase
        x = [x1, 1 - x1] 

        p0 = p ./ x

        # solve for the total gas adsorbed
        q_total = 1.0 / (x[1] / LoadingQuadratic(Ka[1], Kb[1], M[1], p0[1]) + x[2] / LoadingQuadratic(Ka[2], Kb[2], M[2], p0[2]))
        
        # get loading of each component by multiplying by mole fractions
        q = x * q_total
   end
    
   if (method == "Interpolation")
        # create linear interpolators
        interpolator1 = Grid.InterpIrregular(convert(Array, df[pressure_key]), convert(Array, df[loading_keys[1]]), Grid.BCnan, Grid.InterpLinear)
        interpolator2 = Grid.InterpIrregular(convert(Array, df[pressure_key]), convert(Array, df[loading_keys[2]]), Grid.BCnan, Grid.InterpLinear)
        
        # plot resulting fit
        if (plotflag == true)
            P = linspace(minimum(df[pressure_key]), maximum(df[pressure_key]), 1000)
            fit = plot(
                   layer(x=P, y=interpolator1[P], Geom.line),
                   layer(x=df[pressure_key], y=df[loading_keys[1]], Geom.point),
                   Guide.xlabel("Pressure"), 
                   Guide.ylabel(@sprintf("Loading %s", loading_keys[1])),
                   Guide.title("Linear interpolation fit")
                   )
            draw(PNG(6inch, 3inch), fit)
            fit = plot(
                   layer(x=P, y=interpolator2[P], Geom.line),
                   layer(x=df[pressure_key], y=df[loading_keys[2]], Geom.point),
                   Guide.xlabel("Pressure"), 
                   Guide.ylabel(@sprintf("Loading %s", loading_keys[2])),
                   Guide.title("Linear interpolation fit")
                   )
            draw(PNG(6inch, 3inch), fit)
        end
        
        # solve for mole fractions in adsorbed phase s.t. spreading pressures are equal
        println(Π_Interpolate(200, interpolator1, df, pressure_key, loading_keys[1]))
        f(x1) = Π_Interpolate(p[1] / x1, interpolator1, df, pressure_key, loading_keys[1]) - Π_Interpolate(p[2] / (1 - x1), interpolator2, df, pressure_key, loading_keys[2])  # want to be zero
        x1 = linspace(0.0001, .999)
        y = zeros(length(x1))
        for i=1:length(y)
            y[i]=f(x1[i])
        end
        fit = plot(x=x1, y=y, Geom.line,  Guide.xlabel("x1"),Guide.ylabel("f(x)"),  Guide.title("ensureing roots"))                                                                                                 
        draw(PNG(6inch, 3inch), fit)

        x1 = fzero(f, 0.5)
        
        # mole fraction in adsorbed phase
        x = [x1, 1 - x1] 

        p0 = p ./ x

        # solve for the total gas adsorbed
        q_total = 1.0 / (x[1] / interpolator1[p0[1]] + x[2] / interpolator2[p0[2]])
        
        # get loading of each component by multiplying by mole fractions
        q = x * q_total
   end
        

   for i = 1:2
       @printf("IAST loading of adsorbate %s at p_%s = %f: %f\n", loading_keys[i], loading_keys[i], p[i], q[i])
   end
end
