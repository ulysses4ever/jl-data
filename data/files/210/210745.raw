module Symbolic

import Base.show
import Base.print

export @t, @s, Term, simplify

const ops = [:+, :-, :*, :/, :^]

#Datatype and constructors
immutable Term{S, Args<:Tuple}
    args::Args
end
Term(S, args::(Term...)) = Term{S, typeof(args)}(args)
Term(S, args...) = Term(S, map(Term, args))
Term(n::Int) = Term(n, ())
Term(n::Symbol) = Term(n, ())
Term(t::Term) = t
Term(ex::Expr) = begin
    @assert ex.head == :call
    term_args = map(Term, tuple(ex.args[2:]...))
    Term(ex.args[1], term_args)
end
macro t(ex)
    Term(ex)
end

#Infix printing
show(io::IO, t::Term) = print(io, t)
print{S}(io::IO, t::Term{S, ()}) = print(io, string(S))
print{S}(io::IO, t::Term{S}) = 
    if in(S, ops) && length(t.args) > 1
        print(io, "(")
        for i = 1:(length(t.args)-1)
            print(io, t.args[i])
            print(io, string(S))
        end
        print(io, t.args[end])
        print(io, ")")
    else
        print(io, string(S))
        print(io, "(")
        for i = 1:(length(t.args)-1)
            print(io, t.args[i])
            print(io, ",")
        end
        print(io, t.args[end])
        print(io, ")")
    end


#Simplification rules
#Addition
simplify{X}(t::Term{:+, (X, X)}) = Term(:*, 2, t.args[1])
simplify{X}(t::Term{:+, (X, Term{0, ()})}) = t.args[1]
simplify{X}(t::Term{:+, (Term{0, ()}, X)}) = t.args[2]

#Multiplication
simplify{X}(t::Term{:*, (X, X)}) = Term(:^, t.args[1], 2)

simplify{X}(t::Term{:*, (X, Term{1, ()})}) = t.args[1]
simplify{X}(t::Term{:*, (Term{1, ()}, X)}) = t.args[2]

simplify{X}(t::Term{:*, (X, Term{0, ()})}) = Term(0)
simplify{X}(t::Term{:*, (Term{0, ()}, X)}) = Term(0)

#Subtraction
simplify{X}(t::Term{:-, (X, X)}) = Term(0)
simplify{X}(t::Term{:+, (X, Term{:-, (X,)})}) = Term(0)

simplify{S}(t::Term{S, ()}) = t
simplify{S, Args}(t::Term{S, Args}) = Term(S, map(simplify, t.args))

macro s(ex)
    simplify(Term(ex))
end
symb{S}(t::Term{S}) = S

#Find the term matching a pattern.
find_path(pattern::Term, s::Symbol) = begin
    if length(pattern.args) == 0
        if s==symb(pattern)
            return Int[]
        else
            return nothing
        end
    else 
        for i = 1:length(pattern.args)
            res = find_path(pattern.args[i], s)
            if isa(res, Vector{Int})
                return [i, res]
            end
        end
        nothing
    end
end

#Should be a macro, producing target.args[1].args[2]...
extract(target::Term, pattern::Term, s::Symbol) = begin
    current_term = target
    path = find_path(pattern, s)
    for arg in path
        current_term = current_term.args[arg]
    end
    current_term
end
end
