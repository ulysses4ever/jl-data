using AbstractGPUArray, GLAbstraction, GLWindow, GeometryTypes, FixedSizeArrays
using FactCheck


w = createwindow("test", 10,10, debugging=true) # dummy window for opengl context

immutable Sprite{T} <: FixedVector{T, 1}
    attribute_id::T # lookup attribute_id for attribute texture
end
immutable SpriteStyle{T} <: FixedVector{T, 2}
    color_id::T # lookup attribute_id for attribute texture
    technique::T
end

typealias GLSprite Sprite{Uint32}
typealias GLSpriteStyle SpriteStyle{Uint16}

style = GPUVector(texture_buffer(fill(GLSpriteStyle(0,0), 50)))
last_selection = 1:39
style[last_selection] = fill(GLSpriteStyle(0,0), length(last_selection))
selection = 7:23
style[selection]      = fill(GLSpriteStyle(1,0), length(selection))


facts("splicing! texture_buffer") do
    for idx in Any[1, 2, 5, 9, 10, 1:0, 2:1, 1:1, 2:2, 1:2, 2:4, 9:8, 10:9, 9:9, 10:10,
                   8:9, 9:10, 6:9, 7:10]
        for repl in Any[Float32[], Float32[11], Float32[11,22], Float32[11,22,33,44,55]]
            a     = Float32[1f0:10f0;]
            acopy = copy(a)
            agpu  = GPUVector(texture_buffer(a))
            splice!(agpu, idx, repl)
            context("splicing $repl into index $idx") do
                @fact splice!(a, idx, repl)                 => acopy[idx]
                @fact gpu_data(agpu)                        => a
                @fact a                                     => [acopy[1:(first(idx)-1)]; repl; acopy[(last(idx)+1):end]]
            end
        end
    end
end

facts("push! into texture_buffer") do
    const A = rand(Float32, 3)
    const B = Point3{Float32}[rand(Point3{Float32}, -99999999f0:eps(Float32):9999999999f0) for i=1:77]
    BGPU    = GPUVector(texture_buffer(B))
    const C = Vector2{Cint}[rand(Vector2{Cint}, typemin(Cint):typemax(Cint)) for i=1:21]

    AGPU 	= GPUVector(texture_buffer(A))
    CGPU 	= GPUVector(texture_buffer(C))

    context("eltype + ndims + length + size + content") do
    	@fact eltype(AGPU)   => eltype(A)
        @fact eltype(BGPU)   => eltype(B)
        @fact eltype(CGPU)   => eltype(C)

        @fact ndims(AGPU)   => ndims(A)
        @fact ndims(BGPU)   => ndims(B)
        @fact ndims(CGPU)   => ndims(C)

        @fact length(AGPU)   => length(A)
        @fact length(BGPU)   => length(B)
        @fact length(CGPU)   => length(C)

        @fact size(AGPU)     => size(A)
        @fact size(BGPU)     => size(B)
        @fact size(CGPU)     => size(C)

        @fact gpu_data(AGPU) => A
        @fact gpu_data(BGPU) => B
        @fact gpu_data(CGPU) => C
        
    end

    append!(A, Float32[1f0, 2f0, 30f0])
    push!(A, 66f0, 0.3f0, 0.5555f0, 0.5555f0)
    push!(A, 42f0)

    append!(AGPU, Float32[1f0, 2f0, 30f0])
    push!(AGPU, 66f0, 0.3f0, 0.5555f0, 0.5555f0)
    push!(AGPU, 42f0)


    append!(B, Point3{Float32}[Point3{Float32}(1f0), Point3{Float32}(2f0), Point3{Float32}(7f0,7f0, 99f0)])
    push!(B, Point3{Float32}(1f0, 0.77f0, -0.0001f0), Point3{Float32}(0.00000000001f0), Point3{Float32}(999999999.7f0))
    push!(B, Point3{Float32}(42f0))

    append!(BGPU, Point3{Float32}[Point3{Float32}(1f0), Point3{Float32}(2f0), Point3{Float32}(7f0,7f0, 99f0)])
    push!(BGPU, Point3{Float32}(1f0, 0.77f0, -0.0001f0), Point3{Float32}(0.00000000001f0), Point3{Float32}(999999999.7f0))
    push!(BGPU, Point3{Float32}(42f0))
    

    append!(C, Vector2{Cint}[Vector2{Cint}(1), Vector2{Cint}(2), Vector2{Cint}(-7, -99)])
    push!(C, Vector2{Cint}(-1, typemax(Cint)), Vector2{Cint}(2), Vector2{Cint}(-77, 9973))
    push!(C, Vector2{Cint}(42))

    append!(CGPU, Vector2{Cint}[Vector2{Cint}(1), Vector2{Cint}(2), Vector2{Cint}(-7, -99)])
    push!(CGPU, Vector2{Cint}(-1, typemax(Cint)), Vector2{Cint}(2), Vector2{Cint}(-77, 9973))
    push!(CGPU, Vector2{Cint}(42))


    context("eltype + ndims + length + size + content after push!") do
    	@fact eltype(AGPU)   => eltype(A)
        @fact eltype(BGPU)   => eltype(B)
        @fact eltype(CGPU)   => eltype(C)

        @fact ndims(AGPU)   => ndims(A)
        @fact ndims(BGPU)   => ndims(B)
        @fact ndims(CGPU)   => ndims(C)

        @fact length(AGPU)   => length(A)
        @fact length(BGPU)   => length(B)
        @fact length(CGPU)   => length(C)

        @fact size(AGPU)     => size(A)
        @fact size(BGPU)     => size(B)
        @fact size(CGPU)     => size(C)

        @fact gpu_data(AGPU) => A
        @fact gpu_data(BGPU) => B
        @fact gpu_data(CGPU) => C
    end
end

