# !\usr\bin\julia

module Intervalos

import Base.in
import Base.intersect
import Base.exp
import Base.log
import Base.sin
import Base.cos


####################################
### Defino el tipo 'Intervalo'   ###
####################################

## Esta instruccion hace que el tipo Intervalo este disponible para importarse en otro modulo

export Intervalo


type Intervalo
    a
    b
    function Intervalo(a,b)
        if a > b
            a, b = b, a
        end
    	set_rounding(BigFloat, RoundDown)
			ab = BigFloat("$a")
		set_rounding(BigFloat, RoundUp)
			bb = BigFloat("$b")
		set_rounding(BigFloat,RoundNearest)
		new(ab,bb)
    end
end



## NOTA
## La instruccion 'using' para modulos hace que las definiciones exportadas en el modulo se puedan utilizar como definiciones
## construidas en el Main y las que no se importaron se puedan utilizar como objetos de MyModule, e.g. MyModule.p funcion en
## vez de p(), y que p no se exporto en el modulo. Pero si yo uso 'import' para añadir este modulo al workspace, entonces todas
## las definiciones seran usadas como objetos del modulo, independientemente de si se exportaron o no en el modulo, es decir, 
## x() no funciona, pero MyModule.x si funciona.


## Para usar un modulo desde un archivo ##
## Primero incluyo el archivo con
## 		include("/home/rocko/Documentos/Posgrado/julia/intervalos.jl")
## Segundo, import el modulo con:
## 		import Intervalos


#########################################################
### Defino operaciones de conjuntos para intervalos   ###
#########################################################


## Defino la operacion 'in'

function in(x, A::Intervalo)
    if A.a <= x <= A.b
        return true
    else
        return false
    end
end


## Defino la operacion 'intersect'

function intersect(A::Intervalo, B::Intervalo)
    if (B.a in A) & (B.b in A)
        return B
    elseif B.a in A 
        return Intervalo(B.a, A.b)
    elseif B.b in A
        return Intervalo(A.a, B.b)
    else
        if A.a in B
            return A
        else
            error("Conjunto vacío")
        end
    end
end



###########################################################
### Defino las operaciones aritmeticas para intervalos  ###
###########################################################


## Suma

function +(A::Intervalo, B::Intervalo)
    return Intervalo(A.a + B.a, A.b + B.b)
end

## Suma mas constante

function +(J::Intervalo, c::Real)
	return Intervalo(J.a + c, J.b + c)
end

## Constante mas Intervalo

function +(c::Real, J::Intervalo)
	return Intervalo(J.a + c, J.b + c)
end

## Resta

function -(A::Intervalo, B::Intervalo)
    return Intervalo(A.a - B.b, A.b - B.a)
end

## Resta menos constante

function -(J::Intervalo, c::Real)
	return Intervalo(J.a - c, J.b - c)
end

## Constante menos Intervalo

function -(c::Real, J::Intervalo)
	return Intervalo(J.a - c, J.b - c)
end

## Producto

function *(A::Intervalo, B::Intervalo)
    values = [A.a*B.a, A.a*B.b, A.b*B.a, A.b*B.b]
    return Intervalo(minimum(values), maximum(values))
end

## Producto por constante

function *(J::Intervalo, c::Real)
	return Intervalo(J.a*c, J.b*c)
end

## Constante por Intervalo

function *(c::Real, J::Intervalo)
	return Intervalo(J.a*c, J.b*c)
end

## Division

function /(A::Intervalo, B::Intervalo)
    if 0 in B
        error("División entre ::Intervalo que contiene el 0 no está definida")
    else
        values = [A.a/B.a, A.a/B.b, A.b/B.a, A.b/B.b]
        return Intervalo(minimum(values), maximum(values))
    end
end

## Division entre constante

function /(J::Intervalo, c::Real)
	if c == 0
		error("División entre cero")
	else
		return Intervalo(J.a/c, J.b/c)
	end
end

## Constante entre Intervalo

function /(c::Real, J::Intervalo)
	if 0 in J
		error("División entre ::Intervalo que contiene el 0 no está definida")
	else
		return Intervalo(c/J.b, c/J.a)
	end
end


#########################################
### Defino funciones para intervalos  ###
#########################################


## Potencia

function ^(J::Intervalo, n::Integer)   # Solo para potencias enteras
    if (J.a > 0) || (J.b < 0)
        return Intervalo(min(J.a^n, J.b^n), max(J.a^n, J.b^n))
    else
        return Intervalo(min(0, J.a^n, J.b^n), max(0,J.a^n, J.b^n))
    end
end


function ^(J::Intervalo, p::Real)   # Para potencias reales
    if p == int(p)
        return J^int(p)
    else
        I = intersect(J,Intervalo(0,Inf))
        return Intervalo(I.a^p, I.b^p)
    end
end



## Defino la operacion 'exp(Intervalo)'

function exp(J::Intervalo)
    return Intervalo(exp(J.a), exp(J.b))
end


## Defino la operacion 'log(Intervalo)'

function log(J::Intervalo)
    if J.a < 0 || J.b < 0
        error("Conjunto no contenido en el dominio de la función")
    else
        return Intervalo(log(J.a), log(J.b))
    end
end


###################################################################
### Funciones no monotonas elementales extendidas a intervalos  ###
###################################################################

############
### Seno ###
############

## Define los puntos criticos de la funcion seno

function sin_cp(n)
	a = Int64[]
	for i = 1:length(n)
		if iseven(n[i])
			push!(a,1)
		else
			push!(a,-1)
		end
	end
	return a
end


## Defino la operacion 'sin(Intervalo)'

function sin(J::Intervalo)
	m = int(ceil(J.a/pi - 0.5))
	M = int(ceil(J.b/pi - 0.5))
	a = [sin(J.a), sin(J.b), sin_cp(m:M-1)]
	return Intervalo(minimum(a), maximum(a))
end

##############
### Coseno ###
##############

## Define los puntos criticos de la funcion cos

function cos_cp(n)
	a = Int64[]
	for i = 1:length(n)
		if iseven(n[i])
			push!(a,1)
		else
			push!(a,-1)
		end
	end
	return a
end


## Defino la operacion 'cos(Intervalo)'

function cos(J::Intervalo)
	m = int(ceil(J.a/pi))
	M = int(ceil(J.b/pi))
	a = [cos(J.a), cos(J.b), cos_cp(m:M-1)]
	return Intervalo(minimum(a), maximum(a))
end


end
