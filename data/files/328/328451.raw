# #############################################################################
# #############################################################################
#Cavity analysis functions and global variables

#This file contains the main driving functions for evaluating a cavity, as well as the state variables and setting/getting functions for the simulation and cavity parameters. Typically, a control file will run on a multiprocess julia instance

#   shell-prompt> julia -p <num of parallel procs> <ctrlfile>

#The file starts with the declaration

#   @everywhere using CavChaos

#to initiate the module's methods into the namespace on every process. The following functions can then be used in a control file to set up a simulation run:

#=> Cavity properties

#   set_cavity_bnd(bnd::Boundary)
#   Sets the desired cavity boundary to <bnd>.

#   bnd = get_cavity_bnd()
#   Returns the current cavity boundary.

#   set_cavity_idx(idx::RefractiveIndex)
#   Sets the desired cavity index distribution to <idx>.

#   idx = get_cavity_idx()
#   Returns the current cavity index distribution.

#=> Solver parameters

#   set_solver_params(;kwargs...)
#   Sets the solver parameter represented by keywords to the numerical value associated to it in <kwargs>. Appropriate keywords are: maxpathlength, maxbounces, relativetolerance, absolutetolerance.

#   value = get_solver_param(key::Union(String,Symbol))
#   Returns the current value of the solver parameter represented by the symbol or string <key>.

#=> Initial conditions

#   set_init_params(;kwargs...)
#   Sets the initial conditions autogeneration parameter represented by keywords to the numerical value associated to it in <kwargs>. Appropriate keywords are: symmetry, thetares, sinchires, deviation.

#   value = get_init_param(key::Union(String,Symbol))
#   Returns the current value of the initial conditions autogeneration parameter represented by the symbol or string <key>.

#   set_pssinitarray(A::Array{Float64,2})
#   Sets the custom initial conditions as an array <A> of initial (theta,sinchi) values as its rows. If nonempty, the autogeneration parameters will be ignored, and the initial conditions fed to the solver will be computed from <A> directly. This is useful for choosing points on the Poincare Surface of Section for performing simulation runs.

#   pssinitarray = get_pssinitarray()
#   Returns the current custom/autogenerated (theta,sinchi)-based initial conditions array <pssinitarray>.

#   set_initarray(A::Array{Float64,2})
#   Sets the custom initial conditions as an array <A> of initial (r,theta,phi) values as its rows. If nonempty, the autogeneration parameters and the (theta,sinchi)-based custom initial conditions array will be ignored, and the initial conditions fed to the solver will be taken from <A> directly. This is useful for fine control over the initial ray position and direction when performing simulation runs.

#   initarray = get_initarray()
#   Returns the current custom/autogenerated (r,theta,phi)-based initial conditions array <initarray>.

#   initcond = get_initcond(resultid::Int64)
#   Returns the <resultid>th set <initcond> of (r,theta,phi)-based initial conditions, as a 1D array.

#=> Results to record

#   set_results(;kwargs...)
#   Sets the result represented by keywords to a boolean value associated to it in <kwargs>, indicating whether that result will be recorded. Appropriate keywords are: pssinitarray, initarray, initialconditions, raypath, bounceindices, bouncepoints, cavityimage, rayimage, pathlengths, actions, modeproperties, farfield.

#   set_results(args...)
#   unset_results(args...)
#   For a convenient syntax, if the above results keywords are passed as regular symbol or string arguments to set_results, then they will be recorded. If passed to unset_results, they will not.

#   boolean = get_results(key::Union(String,Symbol))
#   Returns whether the result represented by the keyword represented by the string or symbol <key> will be recorded.

#Finally, the actual run is started by a call to the function runcavity().


# #############################################################################
# #############################################################################
#Initiate

#Dependencies
#require("util.jl")
#require("boundary.jl")
#require("refractive_index.jl")
#require("solver.jl")
#require("io.jl")
#require("ray_plot.jl")
#require("analysis.jl")


# #############################################################################
# #############################################################################
#Settings as global state

#Cavity objects
cavity_bnd = FourierBnd()
cavity_idx = UniformIdx()

#Solver parameters
solver = Dict{Symbol,Number}()
solver[:maxpathlength] = 200.0
solver[:maxbounces] = 500
solver[:relativetolerance] = 1.0e-12
solver[:absolutetolerance] = 1.0e-12

#Initial conditions array
init = Dict{Symbol,Number}()
init[:symmetry] = 1
init[:thetares] = 25
init[:sinchires]= 25
init[:deviation] = 13
pssinitarray = Array(Float64,0,2)
initarray = Array(Float64,0,3)

#Results to record
results = Dict{Symbol,Bool}()
results[:pssinitarray] = false
results[:initarray] = true
results[:initialconditions] = false
results[:raypath] = false
results[:bounceindices] = false
results[:bouncepoints] = true
results[:cavityimage] = true
results[:rayimage] = true
results[:pathlengths] = true
results[:actions] = true
results[:modeproperties] = false
results[:farfield] = false


# #############################################################################
# #############################################################################
#Setters and unsetters and getters

#Set across all processors
function setworkers(setfunc,args...;kwargs...)
    for w in workers()
        @spawnat w setfunc(args...;kwargs...)
    end
end

#Cavity parameters
function set_cavity_bnd(bnd::Boundary)
    global cavity_bnd = bnd
    #Copy over workers
    if myid() == 1 && nprocs() > 1
        setworkers(set_cavity_bnd,bnd)
    end
    return nothing
end

function get_cavity_bnd()
    return cavity_bnd::Boundary
end

function set_cavity_idx(idx::RefractiveIndex)
    global cavity_idx = idx
    #Copy over workers
    if myid() == 1 && nprocs() > 1
        setworkers(set_cavity_idx,idx)
    end
    return nothing
end

function get_cavity_idx()
    return cavity_idx::RefractiveIndex
end

#Solver parameters
function set_solver_params(;kwargs...)
    for i=1:length(kwargs)
        if haskey(solver,kwargs[i][1])
            solver[kwargs[i][1]] = kwargs[i][2]
        else
            error("No solver parameter $(kwargs[i][1]).")
        end
    end
    #Copy over workers
    if myid() == 1 && nprocs() > 1
        setworkers(set_solver_params;kwargs...)
    end
    return nothing
end

function get_solver_param(key::Union(String,Symbol))
    return solver[symbol(key)]::Number
end

#Initial conditions parameters
function set_init_params(;kwargs...)
    for i=1:length(kwargs)
        if haskey(init,kwargs[i][1])
            init[kwargs[i][1]] = kwargs[i][2]
        else
            error("No initial conditions parameter $(kwargs[i][1]).")
        end
    end
    #Copy over workers
    if myid() == 1 && nprocs() > 1
        setworkers(set_init_params;kwargs...)
    end
    return nothing
end

function get_init_param(key::Union(String,Symbol))
    return init[symbol(key)]::Number
end

function set_pssinitarray(A::Array{Float64,2})
    if size(A,2) != 2
        error("PSS initial conditions array must have (theta,sinchi) pairs as rows.")
    end
    global pssinitarray = A
    #Copy over workers
    if myid() == 1 && nprocs() > 1
        setworkers(set_pssinitarray,A)
    end
    return nothing
end

function get_pssinitarray()
    return pssinitarray::Array{Float64,2}
end

function set_initarray(A::Array{Float64,2})
    if size(A,2) != 3
        error("Initial conditions array must have (r,theta,phi) values as rows.")
    end
    global initarray = A
    #Copy over workers
    if myid() == 1 && nprocs() > 1
        setworkers(set_initarray,A)
    end
    return nothing
end

function get_initarray()
    return initarray::Array{Float64,2}
end

function get_initcond(resultid::Int64)
    return initarray[resultid,:][:]::Array{Float64,1}
end

#Results parameters
function set_results(;kwargs...)
    for i=1:length(kwargs)
        if haskey(results,kwargs[i][1])
            results[kwargs[i][1]] = kwargs[i][2]
        else
            error("No result named $(kwargs[i][1]).")
        end
    end
    #Copy over workers
    if myid() == 1 && nprocs() > 1
        setworkers(set_results;kwargs...)
    end
    return nothing
end

function set_results(args...)
    set_results(;[(symbol(arg),true) for arg in args]...)
end

function unset_results(args...)
    set_results(;[(symbol(arg),false) for arg in args]...)
end

function get_results(key::Union(String,Symbol))
    return results[symbol(key)]::Bool
end

#Collect all run parameters together for obtaining a hash
function get_run_params()
    run_params::Array{Any,1} = cell(3)
    run_params[1] = solver
    run_params[2] = initarray
    run_params[3] = results
    return run_params
end


# #############################################################################
# #############################################################################
#Initial conditions generation

#Use PSS-spanning initial conditions
#Automatically generates an array of (theta,sinchi) pairs as rows, that covers as much of the Poincare Surface of Section plot up to a specified rotational symmetry. The points form a lattice that is "slanted" in order to maximize the density of sinchi values.
#TODO: Needs clearer documentation!
function gen_pssinitarray(thetares::Int64=25,sinchires::Int64=25,deviation::Int64=13,symmetry::Int64=1)
    #Setup initial conditions
    theta0::Array{Float64,1} = linspace(0,2*pi/symmetry,thetares+1)[1:end-1]
    sinchi0::Array{Float64,1} = linspace(0,1,sinchires+3)[1:end-3]
    offset::Array{Float64,1} = linspace(0,sinchi0[deviation],thetares+1)[1:end-1]
    
    theta0val::Array{Float64,2} = ones(Float64,sinchires)*transpose(theta0)
    sinchi0val::Array{Float64,2} = mod(sinchi0*ones(Float64,1,thetares) + ones(Float64,sinchires)*transpose(offset),sinchi0[end]+sinchi0[2]) + sinchi0[2]
    
    return [theta0val[:] sinchi0val[:]]
end

#Converts a (theta,sinchi)-based set initial conditions to a (r,theta,phi)-based one
function pss2raycoord(bnd::Boundary,theta::Float64,sinchi::Float64)
    r::Float64,alpha::Float64 = rsys(bnd,theta)
    phi::Float64 = alpha + asin(sinchi)
    return (r,theta,phi)
end

#Generates the (r,theta,phi)-based initial conditions array from a given (theta,sinchi)-based array.
function gen_initarray(bnd::Boundary,pssinitarray::Array{Float64,2})
    count::Int64 = size(pssinitarray,1)
    initA::Array{Float64,2} = Array(Float64,count,3)
    for i=1:count
        initA[i,1],initA[i,2],initA[i,3] = pss2raycoord(bnd,pssinitarray[i,1],pssinitarray[i,2])
    end
    return initA
end


# #############################################################################
# #############################################################################
#Main driver

#Main running function
function runcavity()
    tic()
    
    #Autogenerate init_array
    if isempty(get_initarray())
        if isempty(get_pssinitarray())
            set_pssinitarray(gen_pssinitarray(get_init_param(:thetares),
                                              get_init_param(:sinchires),
                                              get_init_param(:deviation),
                                              get_init_param(:symmetry)))
        end
        set_initarray(gen_initarray(get_cavity_bnd(),get_pssinitarray()))
    end
    
    #Get results directory
    const resultsdir::String = getresultsdir(hash(get_run_params()),get_cavity_bnd(),get_cavity_idx())
    
    #Write cavity image
    if get_results(:cavityimage)
        range::Array{Float64,1} = writecavityimg(resultsdir,get_cavity_bnd(),get_cavity_idx())
    else
        range = [-1,-1,1,1]
    end
    rayline = nothing
    
    #Write initial conditions arrays
    if get_results(:pssinitarray)
        writeresults(resultsdir,0,"pssinitarray",get_pssinitarray())
    end
    if get_results(:initarray)
        writeresults(resultsdir,0,"initarray",get_initarray())
    end
    
    #Initiate array types
    
    
    #Iterate through various initial conditions
    const num_of_runs::Int64 = size(get_initarray(),1)
    @sync begin
        @parallel for resultid = 1:num_of_runs
            
            #Run ray tracer
            (raypath::Array{Float64,2},
             bounceindices::Array{Int64,1},
             bouncepoints::Array{Float64,2}) = 
                rayevolve_gsl(
                    get_cavity_bnd(), get_cavity_idx(),
                    get_initcond(resultid);
                    tmax = get_solver_param(:maxpathlength),
                    bouncemax = get_solver_param(:maxbounces),
                    reltol = get_solver_param(:relativetolerance),
                    abstol = get_solver_param(:absolutetolerance))
            
            #Analyze results
            if get_results(:pathlengths) || get_results(:actions)
                #Compute 
                pathlengths,actions = 
                    getpathintegrals(raypath,get_cavity_idx(),bounceindices)
            end
            
            #Write results
            if get_results(:initialconditions)
                writeresults(resultsdir,resultid,
                             "initialconditions",get_initcond(resultid))
            end
            if get_results(:raypath)
                writeresults(resultsdir,resultid,"raypath",raypath)
            end
            if get_results(:bounceindices)
                writeresults(resultsdir,resultid,"bounceindices",bounceindices)
            end
            if get_results(:rayimage)
                if rayline == nothing
                    rayline = writerayimg(resultsdir,resultid,raypath,range)
                else
                    writerayimg(resultsdir,resultid,raypath,rayline)
                end
            end
            if get_results(:bouncepoints)
                writeresults(resultsdir,resultid,"bouncepoints",bouncepoints)
            end
            if get_results(:pathlengths)
                writeresults(resultsdir,resultid,"pathlengths",pathlengths)
            end
            if get_results(:actions)
                writeresults(resultsdir,resultid,"actions",actions)
            end
            
            #Mode detected! (not implemented yet)
            if false
                if get_results(:modeproperties)
                    
                end
                if get_results(:farfield)
                    
                end
            end
            
            #Display progress
            println("Completed $resultid of $(num_of_runs) run(s).")
        end
    end
    
    #End
    plt.close()
    println("Cavity analyzed in $(toq()) seconds.")
    
    return resultsdir
end
