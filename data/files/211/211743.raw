
#Originally produced by Joseph Vavra and David Berger
#Yale University

# modified to make this code compatible with julia
# by Yuta Takahashi
#
# Northwestern University 2013

# *** NOTE ***
# See the Berger's note.
# Dropbox/PDF/Berger/note
# QuantitiveSs.pdf

#clc
#clear all;
#close all;
tic()


#---------------------------------------------------------
# Preambles for julia
#---------------------------------------------------------

require("distributions")
require("GS_parameters_states") # specify parameters and states
require("fixed_random_number") # fix random numbers generated by rand
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------


#---------------------------------------------------------
# Krusell Smith iteration
#---------------------------------------------------------

#Initial guess for krusell smith: frictionless economy
a0=0;
a1=0;

difftrans=10; # initially set 10.  The difference between the previous iteration and new one of aggregate conjecture
iteration=0; # # of iteration

told=0;
tnew=0;
while difftrans>difftranstol

    iteration=iteration+1;
    #fprintf('This is #5.1f-th iteration \n',iteration);
    println("This is ", iteration, "-th iteration")
    tic()
    #Need xi to stay on grid, so calculate nearest point for Xi' (= Xiprime, next period state)
    # Pick a transition point
    # Example xi takes a value on 1 2 3
    # if xi=2.1, then xi=2.

    # xi' = log(p/S')=log(p)- log(S')=log(p)-(mu + epsilonS)

    Xiprime=zeros(xigridsize,moneygridsize);
    for i=1:xigridsize
        for j=1:moneygridsize
            diffxiprime=abs(a0+a1*xi [ i ]-mu*(1+(j-(moneygridsize+1)/2))-xi); #See p.45
            (value, Xiprime[i,j ] )=findmin(diffxiprime); # Xiprime are indexes. Value is not used
        end
    end

    # Modify this
    # Use the previous value does not work
    Vadjustold=zeros(zgridsize,xigridsize);
    policyadjust=zeros(zgridsize,xigridsize);

    Vnoadjustold=zeros(npgridsize,zgridsize,xigridsize);
    policy=zeros(npgridsize,zgridsize,xigridsize);
    policyold=policy;

    diffmax=10;
    policyiteration=0;


    #------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    while diffmax>0        # stop when the policies converge.

        print(".")

        #*** NOTE ***
        # NICE OVSEBATION

        #iterate until policy function unchanged
        #You could also iterate on value function convergence
        #but I find that the policy function has completely
        #converged somewhat before the value function has


        # prepare the boxes
        Vnoadjustnew=zeros(npgridsize,zgridsize,xigridsize);
        Vadjustnew=zeros(zgridsize,xigridsize);


        #----------------------------------------------------------
        # Computing Value function (Calculate expectations & continuation values)
        #----------------------------------------------------------



        #----------------------------------------------------------
        # Not adjusted value V^A
        #----------------------------------------------------------

        # Computing value function which is not adjusted
        # this part does not involve any optimization
        # Integration is just sum: int(f)= sum_i f_i *width

        for i=1:npgridsize
            for j=1:zgridsize
                for k=1:xigridsize

                    # Flow profit

                    # np = log( p/S ).  p/S = exp(np);
                    # (p/S - omega/productivity) * exp((a0 +a1*xi(k))*(theta-2))  * p/S ^-theta

                    Vnoadjustnew[i,j,k]=( exp(        np[i]  )-omega/exp(z[j] ) )*(exp( (a0 +a1*xi[k] )*(theta-2) )*exp(-theta*np[i]  ));

                    # Add continuation

                    for n=1:zgridsize # n for integration

                        for r=1:moneygridsize

                            # Prepare SDF
                            #  Q=beta*exp(-(a0+a1*xi(k)))/exp(-(a0+a1*xi(Xiprime(k,r))));
                            # function of k(zgrid) and r(moneygrid)
                            #Drop a0 in common

                            #If the money shock would push price off grid need to make sure it stays on grid

                            # (1+(r-(moneygridsize+1)/2)) means
                            # mu +epsilonS
                            # adding mu is the same as shifting 1 index
                            # since the grid width = mu




                            # in each step, in the last sentence
                            # calculate Vnoadjustnew(i,j,k)=Vnoadjustnew(i,j,k)+Probmoney(r)*Q*Probz(j,n)*Vold;
                            # where
                            # Q=beta*exp(-(a0+a1*xi(k)))/exp(-(a0+a1*xi(Xiprime(k,r))))
                            # SDF

                            if 1<=i-(1+(r-(moneygridsize+1)/2)) && npgridsize>=i-(1+(r-(moneygridsize+1)/2)) # when log(p/S) is in the bounds

                                #Vold=max(  Vnoadjustold(   i-1-(r-(moneygridsize+1)/2),n,Xiprime(k,r)  ),  Vadjustold(n,Xiprime(k,r))   );

                                Vnoadjustnew[i,j,k]=Vnoadjustnew[i,j,k]+Probmoney[r] * beta * exp(    -(a0+a1*xi [ k ]  ) )/exp(-(a0+a1* xi[ Xiprime [ k , r ]  ]    ))* Probz[ j , n ]*max(  Vnoadjustold[   i-1-(r-(moneygridsize+1)/2 ) , n , Xiprime[k,r]  ],  Vadjustold[n,Xiprime[k,r] ]   );

                            elseif 1>i-(1+(r-(moneygridsize+1)/2)) # when log(p/S') is out of the grid (too small)

                                #Vold=max(  Vnoadjustold( 1 , n,Xiprime(k,r)  ),  Vadjustold(n,Xiprime(k,r))   );

                                Vnoadjustnew[i,j,k]=Vnoadjustnew[i,j,k] + Probmoney[r]*  beta*   exp(-(a0+a1*   xi[k]   ))/exp(-(a0+a1*      xi[Xiprime[k,r]]      ))*Probz[j,n]*    max(  Vnoadjustold[ 1 , n,Xiprime[k,r]  ],  Vadjustold[n,Xiprime[k,r]]   );

                            else # when log(p/S) is too big

                                # Vold=max(  Vnoadjustold(npgridsize ,  n,Xiprime(k,r)),  Vadjustold(n,Xiprime(k,r))    );

                                Vnoadjustnew[i,j,k]= Vnoadjustnew[i,j,k] + Probmoney[r]*beta*exp(-(a0+a1*  xi[k]  ))/exp(-(a0+a1*         xi[Xiprime[k,r]]    ))*Probz[j,n]*max(  Vnoadjustold[npgridsize ,  n,Xiprime[k,r]],  Vadjustold[n,Xiprime[k,r]]    );
                            end

                        end

                    end


                end
            end
        end
        #----------------------------------------------------------


        #----------------------------------------------------------
        # Adjusted value V^A
        #----------------------------------------------------------


        #*** NOTE ***
        # This is clever
        #************

        #The value of adjusting will be the value of not adjusting at the
        #computed at the highest value price, minus the cost of adjusting
        #to that price


        for j=1:zgridsize
            for k=1:xigridsize
                (  Vadjustnew[j,k], policyadjust[j,k]   )  =  findmax(  Vnoadjustnew[:,j,k]  );
                Vadjustnew[j,k]=Vadjustnew[j,k]-fmenu*omega*exp( -(a0+a1*xi[k]  ) );
            end
        end

        #Policy is max of adjusting and not adjusting:
        for i=1:npgridsize
            for j=1:zgridsize
                for k=1:xigridsize
                    if Vnoadjustnew[i,j,k]>Vadjustnew[j,k]
                        policy[i,j,k]=i;
                    else
                        policy[i,j,k]=policyadjust[j,k];
                    end
                end
            end
        end

        #Converged when policy function doesn't change:
        diffmax=max((abs(policy-policyold)));
        policyold=policy;
        Vnoadjustold=Vnoadjustnew;
        Vadjustold=Vadjustnew;
    end
    # Here we dont't have to calculate the value function
    # Vnew=max(Vnoadjustold,Vadjustold)
    #------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    #fprintf('\n simulation starts \n')
    println("simulation starts")
    #Simulate the model and calculate simulated transition rule to compare to forecasted transition rule





#------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# simulation part

# originally 20000
numfirms=2000;  #You get good approximations for 10,000 firms but it starts to get a bit slow
numsim=500;

burnin=50;  #Throw out an initial burnin before computing stats
#rand('twister', 5489);  #Initialize random sequence so always the same
#rng('default'); # this is recommended by Matlab


#----------------------------------------------------------
# Initialize state variables
#----------------------------------------------------------

currentfirmstate=zeros(numfirms,3);
newfirmstate=zeros(numfirms,3);

# initial values start from median. (ex ante the same agents)

currentfirmstate[:,1]=round(npgridsize/2);
currentfirmstate[:,2]=round(zgridsize/2);
currentfirmstate[:,3]=round(xigridsize/2);


numup=0;
numdown=0;
sizeup=0;
sizedown=0;

#----------------------------------------------------------
# Aggregate variables
#----------------------------------------------------------

Csim=zeros(numsim+1,1);  #Simulated demand
xisim=zeros(numsim+1,1);  #Simulated Krusell-Smith moment
eps=zeros(numsim+1,1); #Money shock

#-------------------------------------------------------------------------------
# Just some holders for calculating different statistics that could
# sometimes be of interest:
#-------------------------------------------------------------------------------

frequp_t=zeros(numsim+1,1);
freqdown_t=zeros(numsim+1,1);
sizeup_t=zeros(numsim+1,1);
sizedown_t=zeros(numsim+1,1);
size_t=zeros(numsim+1,1);

inflation=zeros(numsim+1,1);  #keeps track of implied inflation
logPoverMregression=zeros(numsim,3);  #Variable for Krusell-Smith regression = 1/Csim

#-------------------------------------------------------------------------------
#Initialize some moments for statistics
#-------------------------------------------------------------------------------

xsd=0;
xsdholder=zeros(numsim,1);
meanpricechange=zeros(numsim,1);

#--------------------------------------------------------------------------------------------------------------------------------------------------------------
# Simulation part
#--------------------------------------------------------------------------------------------------------------------------------------------------------------

for k=1:numsim+burnin

    numup2=0;
    numdown2=0;
    sizeup2=0;
    sizedown2=0;
    size2=0;


    #-------------------------------------------------------------------------------
    #Calculate money shock and thus money tomorrow:
    #-------------------------------------------------------------------------------
    moneyrand=R[2*(k-1)+1,1]; # draw from uniform distribution
    #moneyrand=moneyrand[1,1] # array to float64 to compare with Probmoneycum[1]
    # inv(U)=d distribution(Money)
    # moneyholder = mu + epsilonS taking value in {-2,-1,...,}(index)

    if moneyrand<Probmoneycum[1] # moneyshock is 1-st grid
        moneyholder=1+(1-(moneygridsize+1)/2);
        moneyshockindex=1;
    else

        for j=1:moneygridsize-1
            if moneyrand>Probmoneycum [ j ] && moneyrand <= Probmoneycum[ j+1 ] # money shock is j+1
                moneyholder=1+(j+1-(moneygridsize+1)/2);
                moneyshockindex=j+1;
            end
        end
    end

    #--------------------------------------------------------------------------------------------------------------------------------------------------------------
    # Statistics about price
    #--------------------------------------------------------------------------------------------------------------------------------------------------------------
    pricetoday=zeros(numfirms,1); # for each firms

    # i is the index for firm

    for i=1:numfirms

        #Price today will be the price firms choose today (normalized by M)
        # policy: indexes
        pricetoday[i,1]=policy[currentfirmstate[i,1],currentfirmstate[i,2],currentfirmstate[i,3]];


        if k>burnin  #Calculate statistics:
            if pricetoday[i,1]>currentfirmstate[i,1] #<=> pricetoday(i,1)>price yesterday(i,1)
                numup=numup+1;
                numup2=numup2+1;
                sizeup=sizeup+np[ pricetoday [i,1] ] -np[ currentfirmstate[i,1 ] ];
                sizeup2=sizeup2+np[pricetoday[i,1]]-np[currentfirmstate[i,1]];
                size2=size2+np[pricetoday[i,1]]-np[currentfirmstate[i,1]];
            elseif pricetoday[i,1]<currentfirmstate[i,1]
                numdown=numdown+1;
                numdown2=numdown2+1;
                sizedown=sizedown+np[currentfirmstate[i,1]]-np[pricetoday[i,1]];
                sizedown2=sizedown2+np[currentfirmstate[i,1]]-np[pricetoday[i,1]];
                size2=size2+np[pricetoday[i,1]]-np[currentfirmstate[i,1]];
            end
        end

        #---------------------------------------------------
        # Transition for log(p-1/S)
        #---------------------------------------------------
        # Note that state = (log(p-1/S),log(z),xi)
        #Price tomorrow will be price today adjusted by money shock

        # newfirmstate(:,1)=log(p/S')= log(p/S) - (mu+epsilonS)
        newfirmstate [i,1]=pricetoday[i,1]-moneyholder;

        # Keep them stay in the grid
        if newfirmstate[i,1]<1
            newfirmstate[i,1]=1;
        elseif newfirmstate[i,1]>npgridsize
            newfirmstate[i,1]=npgridsize;
        end
        #-------------------------------------------------------------------------------
        # Transition for z
        #-------------------------------------------------------------------------------

        randz=R[2*k,1];
        #randz=randz[1,1]
        if randz<Probzcum[currentfirmstate[i,2],1]
            newfirmstate[i,2]=1;
        else
            for j=1:zgridsize-1
                if randz>Probzcum[currentfirmstate[i,2],j] && randz<=Probzcum[currentfirmstate[i,2],j+1]
                    newfirmstate[i,2]=j+1;
                end
            end
        end

    #--------------------------------------------------------------------------------------------------------------------------------------------------------------
    end

    #-------------------------------------------------------------------------------
    # Transition for xi : krusell-smith state (aggregate)
    #-------------------------------------------------------------------------------
    #Xiprime = function (xi,monetaryshock)
    # third element is an aggregate shock, which be common across the row.

    newfirmstate[:,3]=Xiprime[currentfirmstate[1,3],moneyshockindex];

    #-------------------------------------------------------------------------------
    # Calculate moments averaging across the agents
    #-------------------------------------------------------------------------------
    if k>burnin
        xsd=xsd+sum(            (        ( np[ pricetoday[:,1] ]  -np[ currentfirmstate[:,1] ] )     -    mean(    np[    pricetoday[:,1]   ]  -    np[    currentfirmstate[:,1]  ]  )         ).^2/numfirms)^.5;
        xsdholder[k-burnin]=sum(       (      (  np[pricetoday[:,1]]-np[currentfirmstate[:,1]]   )-mean (    np[pricetoday[:,1]] - np[currentfirmstate[:,1]]    )).^2/numfirms)^.5;
        meanpricechange[k-burnin]=mean(        np[pricetoday[:,1]]-np[currentfirmstate[:,1]]   );
    end


    #calculate simulated variables
    if k>burnin

        Csim[k-burnin]=1/ (sum(exp (  np[pricetoday[:,1]]  ).^(1-theta))/numfirms)^(1/(1-theta));

        xisim[k-burnin]=log((sum((exp(         np[currentfirmstate[:,1]]   )).^(1-theta))/numfirms)^(1/(1-theta)));
        eps[k-burnin]=moneyholder*mu;

        frequp_t[k-burnin,1]=numup2/numfirms;
        freqdown_t [k-burnin,1] =numdown2/numfirms;
        sizeup_t[k-burnin,1]=sizeup2/numup2;
        sizedown_t[k-burnin,1]=sizedown2/numdown2;
        size_t[k-burnin,1]=size2/(numup2+numdown2);
    end
    if k>burnin+1
        changemv=eps[k-burnin-1,1];
        changec=log(Csim[k-burnin]/Csim[k-burnin-1]);
        inflation[k-burnin]=changemv-changec;
    end

    currentfirmstate=newfirmstate;

end


#Setup matrix for krusell-smith regression
for k=1:numsim
    logPoverMregression[k,1]=log(1/Csim[k]);  #y variable
    logPoverMregression[k,2]=1;  #constant
    logPoverMregression[k,3]=xisim[k];  #x variable

end

#(X'X)^(-1)*X'Y:
coefficients=(logPoverMregression[:,2:3]'*logPoverMregression[:,2:3])\(logPoverMregression[:,2:3]'*logPoverMregression[:,1]);
a0new=coefficients[1];
a1new=coefficients[2];

yhat=logPoverMregression[:,2:3]*coefficients;

r2a=1-sum((logPoverMregression[:,1]-yhat).^2)/sum((logPoverMregression[:,1]-sum(logPoverMregression[:,1]/     max(  size (  logPoverMregression[:,1]  )       )      )).^2);
fracup=numup/(numup+numdown);
freq=(numup+numdown)/(numfirms*numsim);
avesizeup=sizeup/numup;
avesizedown=sizedown/numdown;
#------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


    #Calculate change in transition rule:
    #could also use absolute change instead of
    #percentage change.
    difftrans=max([abs((a0-a0new)/(.5*a0+.5*a0new)) abs((a1-a1new)/(.5*a1+.5*a1new))]);

    #    fprintf('difftrans: #5.3f\n', difftrans);
    println("difftrans:", difftrans)
    # Update the coefficients for aggregate state
    a0=a0new;
    a1=a1new;
    t=toq()
#    println(iteration,"-th outer loop takes",t/60,"min" )
println(t)
end

time=toq()

println("total running time:",time)

#fprintf(' #5.3f minutes\n',t/60);
#fprintf('total number of iteration: #5.1f \n', iteration)


