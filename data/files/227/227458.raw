###
#  Author: Cory M. Simon (CoryMSimon@gmail.com)
###
include("framework.jl")
include("forcefield.jl")
include("energyutils.jl")


function _accessible_at_pt!(x_f::Float64, y_f::Float64, z_f::Float64,
            pos_array::Array{Float64}, sigmas::Array{Float64},
            framework::Framework)
    """
    Accessible at fractional coordinate (x_f, y_f, z_f) based on hard-sphere model?
    returns 1 if accessible
    returns 0 if inaccessible
    """
    # loop over adjacent unit cells to implement periodic boundary conditions
    N_overlap = 0
    for rep_x = -1:1
        for rep_y = -1:1
            for rep_z = -1:1

                # vector of grid pt. Can effectively move grid point instead of adding rep_factors in fractional coords to framework atoms
                x_gridpt = [x_f + 1.0 * rep_x, 
                            y_f + 1.0 * rep_y,
                            z_f + 1.0 * rep_z]
                # what follows is vectorized over the framework atoms in the primitive unit cell
                # subtract from each framework atom position the grid point
                dx = broadcast(-, pos_array, x_gridpt)
                
                # transfer to Cartesian coords
                dx = framework.f_to_cartesian_mtrx * dx
                
                # compute distance squared between grid point and each framework atom, r2
                r2 = sum(dx .* dx, 1)
                
                # does adsorbate at this pt overlap with any framework atoms?
                N_overlap += sum(r2 .< (sigmas .^2))

                if N_overlap > 0
                    return 0 # inaccessible (0)
                end
            end  # end replication in x-direction
        end  # end replication in y-direction
    end  # end replication in z-direction

    # if no overlap found, accessible (1)
    return 1  
end

function writebinarygrid(adsorbate::String, structurename::String, forcefieldname::String; fractionalgridspacing=0.1)
    """
    Write a binary grid (0 or 1) for occupiable or not, based on hard-sphere model of atoms.
    Radii of atoms are taken from the force field.

    The grid is written to a file `structurename_binary.cube`, in Gaussian cube format. 

    :param: String adsorbate: the name of the adsorbate molecule, corresponding to the forcefield file
    """
    @printf("Constructing framework object for %s...\n", structurename)
    framework = constructframework(structurename)

    @printf("Constructing forcefield object for %s...\n", forcefieldname)
    forcefield = constructforcefield(forcefieldname, adsorbate)

    @assert(fractionalgridspacing < 1.0)
    
    # how many grid points in each direction? 
    N_x = int(1.0 / fractionalgridspacing) + 1
    N_y = int(1.0 / fractionalgridspacing) + 1
    N_z = int(1.0 / fractionalgridspacing) + 1
    @printf("Grid is %d by %d by %d points, a total of %d grid points.\n", N_x, N_y, N_z, N_x*N_y*N_z)
    # fractional grid point spacing. Think of grid points as center of voxels.
    dx_f = 1.0 / (N_x - 1)
    dy_f = 1.0 / (N_y - 1)
    dz_f = 1.0 / (N_z - 1)
    @printf("Fractional grid spacing: dx_f = %f, dy_f = %f, dz_f = %f\n", dx_f, dy_f, dz_f)

    # get fractional coords of energy grid. 
    xf_grid = linspace(0.0, 1.0, N_x)
    yf_grid = linspace(0.0, 1.0, N_y)
    zf_grid = linspace(0.0, 1.0, N_z)
    
    # get grid point spacing in Cartesian space, just for kicks ^.^
    cartesian_spacing = framework.f_to_cartesian_mtrx * [xf_grid[2]-xf_grid[1], yf_grid[2]-yf_grid[1], zf_grid[2]-zf_grid[1]]
    @printf("Grid spacing: dx = %.2f, dy = %.2f, dz = %.2f\n", cartesian_spacing[1], cartesian_spacing[2], cartesian_spacing[3])

    # get array of framework atom positions and corresponding epsilons and sigmas for speed
    pos_array, epsilons, sigmas = _generate_pos_array_epsilons_sigmas(framework, forcefield)
    
    # open grid file
    if ! isdir(homedir() * "/PEGrid_output")
       mkdir(homedir() * "/PEGrid_output") 
    end
    gridfile = open(homedir() * "/PEGrid_output/" * framework.structurename * "_" * forcefield.adsorbate * "_binary.cube", "w")

    # Format of .cube described here http://paulbourke.net/dataformats/cube/
    write(gridfile, "This is a grid file generated by PEviz\nLoop order: x, y, z\n")
    @printf(gridfile, "%d %f %f %f\n" , 0, 0.0, 0.0, 0.0)  # 0 atoms, then origin
    # TODO list atoms in the crystal structure
    @printf(gridfile, "%d %f %f %f\n" , N_x, framework.f_to_cartesian_mtrx[1,1] / (N_x - 1), 0.0, 0.0)  # N_x, vector along x-edge of voxel
    @printf(gridfile, "%d %f %f %f\n" , N_y, framework.f_to_cartesian_mtrx[1,2] / (N_y - 1), framework.f_to_cartesian_mtrx[2,2] / (N_y - 1), 0.0)  # N_y, vector along y-edge of voxel
    @printf(gridfile, "%d %f %f %f\n" , N_z, framework.f_to_cartesian_mtrx[1,3] / (N_z - 1), framework.f_to_cartesian_mtrx[2,3] / (N_z - 1), framework.f_to_cartesian_mtrx[3,3] / (N_z - 1))

    @printf("Writing grid...\n")
    # loop over [fractional] grid points, compute energies
    for i in 1:N_x  # loop over x_f-grid points
        # print progress
        if i % (int(N_x/10.0)) == 0
            @printf("\tPercent finished: %.1f\n", 100.0*i/N_x)
        end

        for j in 1:N_y  # loop over y_f-grid points
            for k in 1:N_z  # loop over z_f-grid points

                accessibility = _accessible_at_pt!(xf_grid[i], yf_grid[j], zf_grid[k], 
                                    pos_array, 
                                    sigmas, 
                                    framework)
                
                # write accessibility of this point to grid file
                @printf(gridfile, "%e ", accessibility)
                if (k % 6) == 0
                    @printf(gridfile, "\n")
                end

            end # end loop in z_f-grid points
            @printf(gridfile, "\n")
        end # end loop in y_f-grid points
    end # end loop in x_f-grid points
    close(gridfile)
    @printf("\tDone.\n")
end
