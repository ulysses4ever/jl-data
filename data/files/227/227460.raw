###
#  Author: Cory M. Simon (CoryMSimon@gmail.com)
###
include("framework.jl")
include("forcefield.jl")
include("energyutils.jl")


function _accessible_at_pt!(x_f::Float64, y_f::Float64, z_f::Float64,
            pos_array::Array{Float64}, sigmas::Array{Float64},
            framework::Framework)
    """
    Determine if point at fractional coordinate (x_f, y_f, z_f) is accessible based on hard-sphere model?
    returns 1 if accessible
    returns 0 if inaccessible
    """
    # loop over adjacent unit cells to implement periodic boundary conditions
    N_overlap = 0
    for rep_x = -1:1
        for rep_y = -1:1
            for rep_z = -1:1

                # vector of grid pt. Can effectively move grid point instead of adding rep_factors in fractional coords to framework atoms
                x_gridpt = [x_f + 1.0 * rep_x, 
                            y_f + 1.0 * rep_y,
                            z_f + 1.0 * rep_z]
                # what follows is vectorized over the framework atoms in the primitive unit cell
                # subtract from each framework atom position the grid point
                dx = broadcast(-, pos_array, x_gridpt)
                
                # transfer to Cartesian coords
                dx = framework.f_to_cartesian_mtrx * dx
                
                # compute distance squared between grid point and each framework atom, r2
                r2 = sum(dx .* dx, 1)
                
                # does adsorbate at this pt overlap with any framework atoms?
                N_overlap += sum(r2 .< (sigmas .^2))

                if N_overlap > 0
                    return 0 # inaccessible (0)
                end
            end  # end replication in x-direction
        end  # end replication in y-direction
    end  # end replication in z-direction

    # if no overlap found, accessible (1)
    return 1  
end

function WriteBinaryGrid(adsorbate::String, structurename::String, forcefieldname::String; fractionalgridspacing=0.1)
    """
    Write a binary grid for occupiable (1) or not (0), based on hard-sphere model of atoms.
    Radii of atoms are taken from the force field.

    The grid is written to a file `structurename_binary.cube`, in Gaussian cube format. 

    :param: String adsorbate: the name of the adsorbate molecule, corresponding to the forcefield file
    """
    @printf("Constructing framework object for %s...\n", structurename)
    framework = constructframework(structurename)

    @printf("Constructing forcefield object for %s...\n", forcefieldname)
    forcefield = constructforcefield(forcefieldname, adsorbate)

    @assert(fractionalgridspacing < 1.0)
    
    # how many grid points in each direction? 
    N_x = int(1.0 / fractionalgridspacing) + 1
    N_y = int(1.0 / fractionalgridspacing) + 1
    N_z = int(1.0 / fractionalgridspacing) + 1
    @printf("Grid is %d by %d by %d points, a total of %d grid points.\n", N_x, N_y, N_z, N_x*N_y*N_z)
    # fractional grid point spacing. Think of grid points as center of voxels.
    dx_f = 1.0 / (N_x - 1)
    dy_f = 1.0 / (N_y - 1)
    dz_f = 1.0 / (N_z - 1)
    @printf("Fractional grid spacing: dx_f = %f, dy_f = %f, dz_f = %f\n", dx_f, dy_f, dz_f)

    # get fractional coords of energy grid. 
    xf_grid = linspace(0.0, 1.0, N_x)
    yf_grid = linspace(0.0, 1.0, N_y)
    zf_grid = linspace(0.0, 1.0, N_z)
    
    # get grid point spacing in Cartesian space, just for kicks ^.^
    cartesian_spacing = framework.f_to_cartesian_mtrx * [xf_grid[2]-xf_grid[1], yf_grid[2]-yf_grid[1], zf_grid[2]-zf_grid[1]]
    @printf("Grid spacing: dx = %.2f, dy = %.2f, dz = %.2f\n", cartesian_spacing[1], cartesian_spacing[2], cartesian_spacing[3])

    # get array of framework atom positions and corresponding epsilons and sigmas for speed
    pos_array, epsilons, sigmas = _generate_pos_array_epsilons_sigmas(framework, forcefield)
    
    # open grid file
    if ! isdir(homedir() * "/PEGrid_output")
       mkdir(homedir() * "/PEGrid_output") 
    end
    gridfile = open(homedir() * "/PEGrid_output/" * framework.structurename * "_" * forcefield.adsorbate * "_binary.cube", "w")

    # Format of .cube described here http://paulbourke.net/dataformats/cube/
    write(gridfile, "This is a grid file generated by PEviz\nLoop order: x, y, z\n")
    @printf(gridfile, "%d %f %f %f\n" , 0, 0.0, 0.0, 0.0)  # 0 atoms, then origin
    # TODO list atoms in the crystal structure
    @printf(gridfile, "%d %f %f %f\n" , N_x, framework.f_to_cartesian_mtrx[1,1] / (N_x - 1), 0.0, 0.0)  # N_x, vector along x-edge of voxel
    @printf(gridfile, "%d %f %f %f\n" , N_y, framework.f_to_cartesian_mtrx[1,2] / (N_y - 1), framework.f_to_cartesian_mtrx[2,2] / (N_y - 1), 0.0)  # N_y, vector along y-edge of voxel
    @printf(gridfile, "%d %f %f %f\n" , N_z, framework.f_to_cartesian_mtrx[1,3] / (N_z - 1), framework.f_to_cartesian_mtrx[2,3] / (N_z - 1), framework.f_to_cartesian_mtrx[3,3] / (N_z - 1))

    @printf("Writing grid...\n")
    # loop over [fractional] grid points, compute energies
    for i in 1:N_x  # loop over x_f-grid points
        # print progress
        if N_x > 11
            if (i % int(N_x / 10)) == 0
                @printf("\tPercent finished: %.1f\n", 100.0*i/N_x)
            end
        end

        for j in 1:N_y  # loop over y_f-grid points
            for k in 1:N_z  # loop over z_f-grid points

                accessibility = _accessible_at_pt!(xf_grid[i], yf_grid[j], zf_grid[k], 
                                    pos_array, 
                                    sigmas, 
                                    framework)
                
                # write accessibility of this point to grid file
                @printf(gridfile, "%d ", accessibility)
                if (k % 6) == 0
                    @printf(gridfile, "\n")
                end

            end # end loop in z_f-grid points
            @printf(gridfile, "\n")
        end # end loop in y_f-grid points
    end # end loop in x_f-grid points
    close(gridfile)
    @printf("\tDone.\n")
end

function ReadBinaryGrid(adsorbate::String, structurename::String; lengthcheck=None)
    """
    Reads binary grid .cube file into Julia and returns a 1D array

    Does not count endpoints

    :int lengthcheck: check length of resulting vector, optional
    """
    gridfilename = homedir() * "/PEGrid_output/" * structurename * "_" * adsorbate * "_binary.cube"
    if ~ isfile(gridfilename)
        @printf("Binary grid file %s does not exist.\n", gridfilename)
    end
    gridfile = open(homedir() * "/PEGrid_output/" * structurename * "_" * adsorbate * "_binary.cube")

    # Waste first 3 lines
    readline(gridfile)
    readline(gridfile)
    readline(gridfile)

    # next 3 lines give number of points
    N_x = int(split(readline(gridfile))[1])
    N_y = int(split(readline(gridfile))[1])
    N_z = int(split(readline(gridfile))[1])

    @assert((N_x >= 2) & (N_y >= 2) & (N_z >= 2)) # otherwise no points in cube!

    N = N_x*N_y*N_z - N_x*N_y - N_z*(N_y-1) - (N_z-1)*(N_x-1) # total length of vector. Do not count edges
    if lengthcheck != None
        @assert(N == lengthcheck)
    end
    @printf("N = %d\n", N)

    # TODO: do not double count edges. Hm.
    feature = -1 * ones(Int, N) # will be -1 if somehow missed it.
    count = 0
    line = readline(gridfile)
    # loop over [fractional] grid points, compute energies
    for i in 1:N_x  # loop over x_f-grid points
        for j in 1:N_y  # loop over y_f-grid points
            for k in 1:N_z  # loop over z_f-grid points
                
 #                 @printf("i j k = %d %d %d\n", i, j, k)
 #                 @printf("calling entry %d\n", 1+mod(k-1,6))
 #                 print(line)
 #                 @printf("feature = %d\n ", int(split(line)[1 + mod(k - 1, 6)]))
 #                 @printf("count = %d\n", count)
 #                 @printf("\n")
                
                # do not double-count faces of unit cell
                if ((i != N_x) & (j != N_y) & (k != N_z))
                    count = count + 1
                    feature[count] = int(split(line)[1 + mod(k-1, 6)])
                end
                
                if (k % 6) == 0
                    line = readline(gridfile)
                end

            end # end loop in z_f-grid points
            line = readline(gridfile)
        end # end loop in y_f-grid points
    end # end loop in x_f-grid points

    @assert(count == N)
    close(gridfile)
    return feature
end

function JaccardSimilarity(x1, x2)
    """
    Computes Jaccard similarity between two feature vectors x1 and x2
    """
    n_both1 = sum((x1 + x2) .== 2)
    n_either = sum((x1 + x2) .>= 1)
    return 1.0 * n_both1 / n_either
end

function FractionMatch(x1, x2)
    """
    Computes Jaccard similarity between two feature vectors x1 and x2
    """
    return sum(x1 .== x2) / length(x2)
end
