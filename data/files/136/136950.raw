#
# Naive-Needleman-Wunsch
# Copyright (C) 2012  Khalique Williams
#
# This file is part of Naive-Needlemann-Wunch.
#
# Naive-Needleman-Wunsch is free software: you can redistribute it and/or modify
# it under the terms of the   GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Naive-Needleman-Wunsch is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Naive-Needleman-Wunsch.  If not, see <http://www.gnu.org/licenses/>.
#
# If you wish to contact the author of Naive-Needleman-Wunsch, you may do so at
# kwillia.pub@gmail.com
#

abstract IRecognitionMode

type RecognitionModeK1 <: IRecognitionMode
end

type RecognitionModeK2 <: IRecognitionMode
end

type NoRecognitionMode <: IRecognitionMode
end

abstract IState

type StateAndOutput
    _state::IState
    _output::Any
end

type State <: IState
    _id::Int64
    _transitions::Dict{Any,Any} # key will be StateAndOutput
end

type NullState <: IState
end

abstract IStateKey;

# State A is the first character considered in a repetitive seq. eg: A in AAA
type StateKeyA <: IStateKey
end

# State B is the second unique character considered in a repetitive seq. eg: B in ABABABAB
type StateKeyB <: IStateKey
end

# State C is the third unique character considered in a repetitive seq. eg: C in BACBACBACBAC
type StateKeyC <: IStateKey
end

# State A' is the first character considered in a repetitive seq. eg: A in AAA
type StateKeyAprime <: IStateKey
end

# State B' is the second unique character considered in a repetitive seq. eg: B in ABABABAB
type StateKeyBprime <: IStateKey
end

# State C' is the third unique character considered in a repetitive seq. eg: C in BACBACBACBAC
type StateKeyCprime <: IStateKey
end

type StateKeyNull <: IStateKey
end

type RecognitionStackEntry
    _recognitionMode::IRecognitionMode
    _currentIndexInTarget::Int64
    _target::Array{Char}
end

# organized with entries containing (repitionLength,currentPlace,"AB"}
type RecognitionStack
    _entries::Array{RecognitionStackEntry}
end

##################################################################################



##################################################################################

function getState(stateAndOutput::StateAndOutput)
    return stateAndOutput._state
end

function getOutput(stateAndOutput::StateAndOutput)
    return stateAndOutput._output
end

function hash(stateKey::StateKeyA)
    return 1
end

function hash(stateKey::StateKeyB)
    return 2
end

function hash(stateKey::StateKeyC)
    return 3
end

function hash(stateKey::StateKeyAprime)
    return 4
end

function hash(stateKey::StateKeyBprime)
    return 5
end

function hash(stateKey::StateKeyCprime)
    return 6
end

function hash(stateKey::StateKeyNull)
    return 7
end

function pop(array::Array{RecognitionStackEntry})
    if isempty(array)
        return RecognitionStackEntry(NoRecognitionMode(),0,[' '])
    else
        poppedElement = array[end]
        ccall(:jl_array_del_end, Void, (Any, Uint), array, 1)
        return poppedElement
    end
end

##################################################################################


##################################################################################

function pop(recognitionStack::RecognitionStack)
    return pop(recognitionStack._entries)
end

function nwstring(A::StateKeyA)
    return "<StateKey:A>"
end

function nwstring(B::StateKeyB)
    return "<StateKey:B>"
end

function nwstring(C::StateKeyC)
    return "<StateKey:C>"
end

# this is an abuse of notation\repr, but its essentially accurate (I think)
#  reason: mealy machine (MM) associates outputs to TRANSITIONS specifically
function nwstring(stateAndOutput::StateAndOutput)
    return strcat(nwstring(stateAndOutput._state),"/",stateAndOutput._output)
end

# we have to use this fn when printing State ob; to prevent print from trying recusrsively print 
#  all the State obj's member field details - because some objects are self-referencing through dictionaries
#  and type inference by default tries to evaluate the "whole type"...
function nwstring(state::State)
    return strcat("<State:",string(state._id),">")
end

function nwstring(state::NullState)
    return "<State:NullState>"
end

abstract PushDownAutomata

type RecognitionPDA <: PushDownAutomata
    _stack::RecognitionStack
    _startState::IState
    _currentState::IState
    _currentOutput::Any
    _visitedStates::Array{State}
    _corePattern::Array{State}
    _isCorePatternSet
end

##################################################################################

##################################################################################

function getTransitionMap(state::State)
    return state._transitions;
end

function createState(id::Int64)
    return State(id, Dict())
end

function init(state::State,transitions::Array{Dict{Any,Any}})
    del_all(getTransitionMap(state))

    print("\nInit(")
    print(state)
    println(")")

    for transition in transitions
        println(transition)
        state._transitions = merge(getTransitionMap(state), transition)
    end

    ## tests ##
    for transition in transitions
        ## for each dictionary check that the keys all address a value ##
        for key in keys(transition)
            val = get(getTransitionMap(state), key, NullState())
            
            print("\t -- ")
            print(key)
            print(" => ")
            show(nwstring(val))
            print("\n")
        end
    end

    print("\n")
end

function createRecognitionStack()
    return RecognitionStack([RecognitionStackEntry(NoRecognitionMode(),0,[' '])])
end

# note: maybe change the start output to be something that wont be mapped to a gap??
function createRecognitionPDA(stack::RecognitionStack,startState::IState)
    return RecognitionPDA(stack,startState,startState,0,[startState],[startState],false)
end

function addToVisitedStates(pda::RecognitionPDA,state::IState)
    push(pda._visitedStates,state)
end

function clearVisitedStates(pda::RecognitionPDA)
    del_all(pda._visitedStates)
    push(pda._visitedStates, pda._startState)
end

function getVisitedStates(pda::RecognitionPDA)
    return pda._visitedStates
end

function getEntries(stack::RecognitionStack)
    return stack._entries
end

function isCorePatternSet(pda::RecognitionPDA)
    return pda._isCorePatternSet
end

function getCurrentOutput(pda::RecognitionPDA)
    return pda._currentOutput
end

function getLengthOfCurrentPattern(pda::RecognitionPDA)
    if pda._isCorePatternSet
        println("returning length determined by known core pattern")
        return length(pda._)
    else
        println("returning length based on visited states, because we haven't yet determined a core pattern")
        return length(pda._visitedStates) - 1
    end
end

function pushToStack(pda::RecognitionPDA, entry::RecognitionStackEntry)
    pdaStack = pda._stack
    stackEntries = getEntries(pdaStack)
    push(stackEntries, entry)
end

function popTopOfStack(pda::RecognitionPDA)
    pdaStack = pda._stack
    stackEntries = getEntries(pdaStack)
    poppedEntry = pop(stackEntries)

    return poppedEntry
end

function getTargetFromTopOfStack(pda::RecognitionPDA)
    const topRecognitionStackEntry = popTopOfStack(pda)
    const retTarget = topRecognitionStackEntry._target
    pushToStack(pda, topRecognitionStackEntry)
    return retTarget
end

##################################################################################
##################################################################################

function getNextState(aState::IState, input::IStateKey)
    nextState = get(getTransitionMap(aState), input, NullState())
    return nextState
end

function getPatternInfo(pda::RecognitionPDA)
    const currentTarget = getTargetFromTopOfStack(pda)
    const lengthOfTarget = length(currentTarget)-1
    const lengthOfCorePattern = getCurrentOutput(pda)

    numberOfOccurences = 0
    if lengthOfCorePattern != 0
        numberOfOccurences = lengthOfTarget/lengthOfCorePattern
    end

    return (lengthOfTarget,lengthOfCorePattern,numberOfOccurences)
end

# creates push down automata for pattern recognition 
function createRecognitionPDA()
    ## state definitions ##
    s0 = createState(0)
    s1 = createState(1)
    s2 = createState(2)
    s3 = createState(3)
    s4 = createState(4)
    s5 = createState(5)
    s6 = createState(6)
    s7 = createState(7)
    s8 = createState(8)
    s9 = createState(9)
    s10 = createState(10)
    s11= createState(11)
    s12 = createState(12)
    s13 = createState(13)
    s14 = createState(14)
    s15 = createState(15)
    s16 = createState(16)
    s17 = createState(17)
    s18 = createState(18)
    s19 = createState(19)
    s20 = createState(20)
    s21 = createState(21)
    s22 = createState(22)
    s23= createState(23)
    s24 = createState(24)
    s25 = createState(25)
    s26 = createState(26)
    s27 = createState(27)
    s28 = createState(28)
    s29 = createState(29)
    s30 = createState(30)
    s31 = createState(31)
    s32 = createState(32)
    s33 = createState(33)
    s34 = createState(34)
    s35 = createState(35)
    s36 = createState(36)
    s37 = createState(37)
    s38 = createState(38)

   #btw StateAndOutput is just the number of elements in core repetition
   # we can also rework it so that it's something like ABC, or ABB to be
   # much more descriptive
   
    ## transition defns for Mealy Automata ##
   init(s0, [{StateKeyA()=>StateAndOutput(s1,1)}, {StateKeyAprime()=>StateAndOutput(s17,1)}])

    ## k1 ##
   init(s1, [{StateKeyA()=>StateAndOutput(s2,1)}, {StateKeyB()=>StateAndOutput(s7,2)}])
     init(s2, [{StateKeyA()=>StateAndOutput(s3,1)}, {StateKeyB()=>StateAndOutput(s4,3)}])
      init(s3, [{StateKeyA()=>StateAndOutput(s2,1)}])
      init(s4, [{StateKeyA()=>StateAndOutput(s5,3)}])
       init(s5, [{StateKeyA()=>StateAndOutput(s6,3)}])
        init(s6, [{StateKeyB()=>StateAndOutput(s4,3)}])
     init(s7, [{StateKeyA()=>StateAndOutput(s8,2)}, {StateKeyB()=>StateAndOutput(s33,3)}, {StateKeyC()=>StateAndOutput(s14,3)}])
      init(s8, [{StateKeyB()=>StateAndOutput(s9,2)}, {StateKeyA()=>StateAndOutput(s11,0)}]) # for StateKeyA, I also thought about using 3. But I think this may say more...
       init(s9, [{StateKeyA()=>StateAndOutput(s10,2)}])
        init(s10, [{StateKeyB()=>StateAndOutput(s9,2)}])
       init(s11, [{StateKeyB()=>StateAndOutput(s12,3)}])
        init(s12, [{StateKeyA()=>StateAndOutput(s13,3)}])
         init(s13, [{StateKeyA()=>StateAndOutput(s11,3)}])
       init(s33, [{StateKeyA()=>StateAndOutput(s34,3)}])
        init(s34, [{StateKeyB()=>StateAndOutput(s35,3)}])
         init(s35, [{StateKeyB()=>StateAndOutput(s33,3)}])
      init(s14, [{StateKeyA()=>StateAndOutput(s15,3)}])
       init(s15, [{StateKeyB()=>StateAndOutput(s16,3)}])
        init(s16, [{StateKeyC()=>StateAndOutput(s14,3)}])

    ## k2 ##
   init(s17,[{StateKeyAprime()=>StateAndOutput(s18,1)}, {StateKeyBprime()=>StateAndOutput(s23,1)}])
    init(s18, [{StateKeyAprime()=>StateAndOutput(s19,1)}, {StateKeyBprime()=>StateAndOutput(s20,2)}])
     init(s19, [{StateKeyAprime()=>StateAndOutput(s19,1)}])
     init(s20, [{StateKeyAprime()=>StateAndOutput(s21,3)}])
      init(s21, [{StateKeyAprime()=>StateAndOutput(s22,3)}])
       init(s22, [{StateKeyBprime()=>StateAndOutput(s20,3)}])
    init(s23, [{StateKeyAprime()=>StateAndOutput(s24,2)}, {StateKeyBprime()=>StateAndOutput(s36,3)}, {StateKeyCprime()=>StateAndOutput(s30,3)}]) 
     init(s24, [{StateKeyBprime()=>StateAndOutput(s25,2)}, {StateKeyAprime()=>StateAndOutput(s27,0)}])
      init(s25, [{StateKeyAprime()=>StateAndOutput(s26,2)}])
       init(s26, [{StateKeyBprime()=>StateAndOutput(s25,2)}])
      init(s27, [{StateKeyBprime()=>StateAndOutput(s28,3)}])
       init(s28, [{StateKeyAprime()=>StateAndOutput(s29,3)}])
        init(s29, [{StateKeyAprime()=>StateAndOutput(s27,3)}])
     init(s36, [{StateKeyAprime()=>StateAndOutput(s37,3)}])
      init(s37, [{StateKeyBprime()=>StateAndOutput(s38,3)}])
       init(s38, [{StateKeyBprime()=>StateAndOutput(s36,3)}])
     init(s30, [{StateKeyAprime()=>StateAndOutput(s31,3)}])
      init(s31, [{StateKeyBprime()=>StateAndOutput(s32,3)}])
       init(s32, [{StateKeyCprime()=>StateAndOutput(s30,3)}]) 

    ## tests ##
    testS0_1 = getNextState(s0, StateKeyC())
    println(nwstring(testS0_1))

    testS0_2 = getNextState(s0, StateKeyA())
    println(nwstring(testS0_2))

    if isa(typeof(testS0_1),Type{NullState})
        println("S0_1 Test Succeeded")
    else
        println("S0_1 Test Failed")
    end

    if isa(typeof(testS0_2),Type{NullState})
        println("S0_2 Test Failed\n")
    else
        println("S0_2 Test Succeeded\n")
    end

    recognitionStack = createRecognitionStack()

    recognitionPDA = createRecognitionPDA(recognitionStack, s0)

    # just testing out basic functionality of recognition stack
    topOfRecognitionStack = popTopOfStack(recognitionPDA)
    print("Test(1) - Top Of Recognition Stack: ")
    println(topOfRecognitionStack)

    topOfRecognitionStack._recognitionMode = RecognitionModeK1()
    topOfRecognitionStack._currentIndexInTarget = topOfRecognitionStack._currentIndexInTarget + 1
    topOfRecognitionStack._target = ['C']
    pushToStack(recognitionPDA, topOfRecognitionStack)

    topOfRecognitionStack1 = popTopOfStack(recognitionPDA)
    print("Test(2) - Top Of Recognition Stack: ")
    println(topOfRecognitionStack1)

    push(topOfRecognitionStack1._target, 'G')
    topOfRecognitionStack1._currentIndexInTarget = topOfRecognitionStack1._currentIndexInTarget + 1
    pushToStack(recognitionPDA, topOfRecognitionStack1)

    topOfRecognitionStack2 = popTopOfStack(recognitionPDA)
    print("Test(3) - Top Of Recognition Stack: ")
    println(topOfRecognitionStack2)

    return recognitionPDA
end


# todo:will - (1) we need to extract length of core repeition string once we know it.  DONE.
#  easiest way is to do this to keep a list of visited IStates, each time we comes accross
#  one we check it against all those in list, if one is matched that is NOT s0 or NullState, we know that
#  the core repition string is from the point  in the list matched and onward. Then we don't need to upate
#  the list while pattern is still valid. Once we get NullState or s0, we know to clear the array and start 
#  looking again.
# todo:will - (2) we need to switch from k1 to k2, and sort of get rid of the concept of tracking different
#  sequences, not sure what to call it - (we're really just creating two different contexts fro back to back
#  patterns each different. DONE.
function tickPDAGivenInput(pda::RecognitionPDA, input::Char)
    print("Ticking '")
    print(input)
    println("'")

    topRecognitionStackEntry = popTopOfStack(pda)

    print("  ")
    println(topRecognitionStackEntry)

    # if top of stack is empty, then we know:
    #   1) either PDA just initialized or reset due to non occurence
    #       of expected value in target pattern.
    #   2) _ index = 0 and _target=[] should be only StackEntry (if any).
    #   3) the choices for StateKey will be {StateKeyA,StateKeyAprime}, which one

    # Friday 11:00pm, new strategy.We choose StateKey(A_n) entirely by whether its the nth unique character
    # where A_n = (char) 125 + n   (ASCII - so 1st unique is 126, 2nd is 127, 3rd is 128. -- and it takes
    #                               no more than the target length to determine what n is. For our
    #                               purposes we have 4 letters in the alphabet, and the actual automata
    #                               currently only recognizes patterns only 3 letters at a time -
    #                               a fourth unique character in the input will always break the pattern.
    #                               More, generally another way of breaking the pattern would be to have
    #                               out of place characters in input. So say StateKeyA and StateKeyB
    #                               and StateKeyC are both valid and the pattern in some imaginary
    #                               automata is ABBA. Already we have "toot", a 't' input is valid
    #                               to make "toott", but after that we must have 2 "o"'s to keep with
    #                               the pattern.  In other words we need query the transitions in the
    #                               current state with  StateKeyB twice, each time setting the result
    #                               to be the current state. Alternatvely, can follow "toot" with 'y'
    #                               as the input, which would be the 3rd unique character in pattern,
    #                               prompting us to query the system with StateKeyC. But of course,
    #                               this should return the NullState b/c it doesn't conform to the pattern
    #                               in the automata. For it to conform the automata would need to
    #                               accept ABBAC. The final C allowing a third unique character, a 'y'
    #                               'or anything else but a 't' or an 'o'

    uniqueRank = 0
    uniquenessMap = {' '=>0 }

    del_all(uniquenessMap)

    # building uniquenessMap (maps a character c to N, N meaning c is the Nth unique character encountered
    place = 1
    for c in topRecognitionStackEntry._target
        if has(uniquenessMap, c) != true && c != ' ' 
            merge!(uniquenessMap, { c => place })
            place = place + 1     
        end
    end

    print("  ")
    println(uniquenessMap)

    uniqueRank = get(uniquenessMap, input, length(uniquenessMap)+1)

    print("    input: ")
    print(input)
    print(" is the ")
    print(uniqueRank)
    println(" unique character in target")

    # doing switch on unique rank to get proper StateKey
    stateKey = StateKeyA()

    if uniqueRank == 1
        if isa(typeof(topRecognitionStackEntry._recognitionMode),Type{RecognitionModeK1})
            stateKey = StateKeyA()
        elseif isa(typeof(topRecognitionStackEntry._recognitionMode),Type{RecognitionModeK2})
            stateKey = StateKeyAprime()
        end
    elseif uniqueRank == 2
        if isa(typeof(topRecognitionStackEntry._recognitionMode),Type{RecognitionModeK1})
            stateKey = StateKeyB()
        elseif isa(typeof(topRecognitionStackEntry._recognitionMode),Type{RecognitionModeK2})
            stateKey = StateKeyBprime()
        end
    elseif uniqueRank == 3
        if isa(typeof(topRecognitionStackEntry._recognitionMode),Type{RecognitionModeK1})
            stateKey = StateKeyC()
        elseif isa(typeof(topRecognitionStackEntry._recognitionMode),Type{RecognitionModeK2})
            stateKey = StateKeyCprime()
        end
    else
        # this sort of like insider knowledge, if were ever to accept MORE unique letters
        # in a sequence then we'd probably keep going: uniqueRank=3 giving StateKeyD or StateKeyDprime
        # and etc. Or use the @eval funtion...
        stateKey = StateKeyNull()
    end    

    print("    Chose the state key: ")
    println(stateKey)


    theNextStateAndOutput = getNextState(pda._currentState, stateKey)


    print("  The next state:")
    println(nwstring(theNextStateAndOutput))

    print("    Verdict: ")
    if isa(typeof(theNextStateAndOutput), Type{NullState})
        println("Pattern broken!")
        pda._currentState = pda._startState
        pda._currentOutput = 1;

        clearVisitedStates(pda)
        pda._isCorePatternSet = false

        recognitionMode = topRecognitionStackEntry._recognitionMode
        stateKeyAfterReset = StateKeyNull()

        # we switch between k1 and when patterns and broken (or dispelled)
        if isa(typeof(recognitionMode), Type{RecognitionModeK1})
            recognitionMode = RecognitionModeK2()
            stateKeyAfterReset = StateKeyAprime()
        elseif isa(typeof(recognitionMode), Type{RecognitionModeK2})
            recognitionMode = RecognitionModeK1()
            stateKeyAfterReset = StateKeyA()
        else
            recognitionMode = RecognitionModeK2() #k1 is the default, so a broken pattern means k2...not sure if this should ever happen 
            stateKeyAfterReset = StateKeyAprime()
        end

        theNextStateAndOutput = getNextState(pda._currentState, stateKeyAfterReset)
        pda._currentState = getState(theNextStateAndOutput)
        addToVisitedStates(pda, getState(theNextStateAndOutput))

        topRecognitionStackEntry._target = [' ', input]

        pushToStack(pda, RecognitionStackEntry(recognitionMode, 1, topRecognitionStackEntry._target))
    else
        println("Pattern ALIVE")
        pda._currentState = getState(theNextStateAndOutput)
        pda._currentOutput = getOutput(theNextStateAndOutput)

        if isa(typeof(topRecognitionStackEntry._recognitionMode),Type{NoRecognitionMode})
            # at first glance I should think this now only happens once, at the beginning...not entirely sure.
            println("  Top of stack is empty, initializing...")

            initialRecognitionStackEntry = RecognitionStackEntry(RecognitionModeK1(), 1, [' ',input])
            pushToStack(pda, initialRecognitionStackEntry)

            print("  ")
            println(initialRecognitionStackEntry)
        else
            println("  Top of stack NOT empty, appending new info to it...")

            # so I think 'target' instance variable may be confusing. As long as a pattern exists the
            # will always be appended to. We have another construct regarding core

            push(topRecognitionStackEntry._target,input)
            topRecognitionStackEntry._currentIndexInTarget = topRecognitionStackEntry._currentIndexInTarget + 1
            pushToStack(pda, topRecognitionStackEntry)        

            print("    ")
            println(topRecognitionStackEntry)

            # if we haven;t already found the core pattern:
            #  here we check for cycles. a cycle here would denote the bounds of core pattern + tell us its length

            const theNextStateFromStateAndOutput = getState(theNextStateAndOutput)

            if !isCorePatternSet(pda)
                print("    Checking for core pattern: ")
                print(nwstring(theNextStateFromStateAndOutput))
                print(" | ")
                visitedStates = getVisitedStates(pda)

                coreStartIndexInTarget = 1

                for aVisitedState in visitedStates
                    print(nwstring(aVisitedState))
                    print(", ")

                    if theNextStateFromStateAndOutput == aVisitedState
                        println("\n    Found Core Pattern!")

                        del_all(pda._corePattern)
 
                        isRecording = false

                        # the following works because we know for sure the core
                        # is from whenever bVisitedState is equal to getState(theNextStateAndOutput)
                        # until the end of the list of visited states we've recorded.
                        for bVisitedState in visitedStates
                            if getState(theNextStateAndOutput) == bVisitedState
                                isRecording = true
                                push(pda._corePattern,bVisitedState)
                            elseif isRecording
                                push(pda._corePattern,bVisitedState)
                            end
                        end

                        println("    Core pattern set!")
                        pda._isCorePatternSet = true

                        break
                    end

                    coreStartIndexInTarget = coreStartIndexInTarget + 1
                end

                if (pda._isCorePatternSet)
                    print("    Core Pattern <")
                    for stateInPattern in pda._corePattern
                        print(nwstring(stateInPattern))
                        print(",")
                    end
                    println(">")

                    # we recorded the index for the start of the core pattern in _target
                    print("    Core Pattern String \"")
                    for index=coreStartIndexInTarget:topRecognitionStackEntry._currentIndexInTarget
                        print(topRecognitionStackEntry._target[index])
                        print("-")
                    end
                    println("\"")
                else
                    # for debug only
                    print("\n")
                end
            end

            if !isCorePatternSet(pda)
                addToVisitedStates(pda,getState(theNextStateAndOutput))
            end
        end
    end

    #currentOutput = theNextStateAndOutput._output

    #print("\n  Total Length Of Current Pattern ~= ")
    #println((length(topRecognitionStackEntry._target)-1))
    #print("  Length Of Core Pattern ~= ")
    #println(currentOutput)

    #print("  Number Of Occurences Of Pattern ~= ")
    #if currentOutput != 0
    #    println((length(topRecognitionStackEntry._target)-1)/currentOutput)
    #else
    #    println("0")
    #end

    (lenOfTarget,lenOfCorePattern,numOfOccurences) = getPatternInfo(pda)
    print("  Len of target = ")
    println(lenOfTarget)
    print("  Len of core pattern = ")
    println(lenOfCorePattern)
    print("  Num of occurences = ")
    println(numOfOccurences)

end

