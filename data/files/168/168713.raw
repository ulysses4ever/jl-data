#include("units_test.jl")

#-------------------------------------------------------------------------------
#Main Units module
#-------------------------------------------------------------------------------
module Units
export val, Unit, ToUnit, ToSIUnits
export Distance, Meter, Inch
export Energy, Joule, Mass, KiloGram
export SIMeter, SIJoules, SIKiloGram

import SIUnits
const SI = SIUnits

#-----Useful Constants-----
const INCH_IN_METERS = .0254

#-----Unit Definitions-----
#NOTE: All Units must have a ".v" value and be immutable, for efficiency.
abstract Unit
val(x::Unit) = x.v
/{U<:Unit}(num::U, denom::U) = val(num)/val(denom)
+{U<:Unit}(x::U, y::U) = U(val(x)+val(y))
-{U<:Unit}(x::U, y::U) = U(val(x)-val(y))
*{U<:Unit}(x::U, f::Number) = U(val(x)*f)
*{U<:Unit}(f::Number, x::U) = x*f
/{U<:Unit}(x::U, f::Number) = U(val(x)/f)
/{U<:Unit}(f::Number, x::U) = U(f/val(x))

#-----Length Definitions-----
#Can this be generated by macro or something?
abstract Distance <: Unit
immutable type Meter{T<:Number} <: Distance
	v::T
end
immutable type Inch{T<:Number} <: Distance
	v::T
end

#Can this be made more generic (single line per convert)?
Base.convert(::Type{Inch}, x::Meter) = Inch(val(x)*(1/INCH_IN_METERS))
Base.convert{T}(::Type{Inch{T}}, x::Meter) = Inch(convert(T,val(x)*(1/INCH_IN_METERS)))
Base.convert(::Type{Meter}, x::Inch) = Meter(val(x)*INCH_IN_METERS)
Base.convert{T}(::Type{Meter{T}}, x::Inch) = Meter(convert(T,val(x)*INCH_IN_METERS))

#This can probably be made generic...
Meter(x::Meter) = x
Inch(x::Inch) = x
Meter(x) = convert(Meter, x)
Inch(x) = convert(Inch, x)

#-----Extra Definitions (to show interation with SIUnits)-----
abstract Energy <: Unit
immutable type Joule{T<:Number} <: Energy
	v::T
end
abstract Mass <: Unit
immutable type KiloGram{T<:Number} <: Mass
	v::T
end

typealias SIMeter{T} SI.SIQuantity{T, 1,0,0,0,0,0,0}
typealias SIJoules{T} SI.SIQuantity{T, 2,1,-2,0,0,0,0}
typealias SIKiloGram{T} SI.SIQuantity{T, 0,1,0,0,0,0,0}
Base.convert(::Type{Unit}, x::SIJoules) = Joule(x.val)
Base.convert(::Type{Unit}, x::SIKiloGram) = KiloGram(x.val)
KiloGram(x::KiloGram) = x
Joule(x::Joule) = x

ToUnit(x) = convert(Unit, x)
ToSIUnits(x::Meter) = val(x)*SI.Meter
ToSIUnits(x::KiloGram) = val(x)*SI.KiloGram

end

#-------------------------------------------------------------------------------
#Sample functions: Simple
#-------------------------------------------------------------------------------
using Units

#Option 1: Simple perimeter calc. Requires both dimensions to be of same type:
#NOTE: {Specialization} might get difficult to read if there are many types
perimeter{D<:Distance}(w::D, l::D) = 2*(w+l)

#Option 2: Write main algorithm in meters... for simplicity
#NOTE: Probably easier for beginners.
perimeter_meter(w::Meter, l::Meter) = 2*(w+l)
perimeter_meter(w::Distance, l::Distance) = perimeter_meter(Meter(w), Meter(l))

#Option 3: Uses first parameter type to decide returned distance:
#NOTE: A little akward, in my opinion - but might be useful in some cases
perimeter_arg1{D<:Distance}(w::D, l::Distance) = perimeter(w, convert(D,l))

#-------------------------------------------------------------------------------
#Sample functions: Returns different units
#-------------------------------------------------------------------------------
module Earth
	using Units
	import SIUnits
	SI = SIUnits
	#IMPORTANT!
	#   -g should be derived from Units as well... left as an exercise.
	const g = 9.81 #m/s2 (Should be derived from Units as well)
	const gsi = g*1SI.Meter/(1SI.Second^2) #If using SIUnits

	#Option 1: Compute potential energy, U, in Joules.
	#NOTE:
	#   -Result always in Joules: No point in specializing algorithm for
	#    arbitrary "Distance" type like done for "perimeter".  Instead: provide
	#    simple catch-all wrapper converting Distance->Meter automatically.
	potential_energy(m::KiloGram, h::Meter) = Joule(val(m)*g*val(h))
	potential_energy(m::Mass, h::Distance) = potential_energy(KiloGram(m), Meter(h))

	#Option 2: Use SIUnits module to auto-track unit conversions:
	potential_energySI(m::SIKiloGram, h::SIMeter) = m*gsi*h
	potential_energySI(m::Mass, h::Distance) = potential_energySI(ToSIUnits(m), ToSIUnits(h))
end

#-------------------------------------------------------------------------------
#Test code
#-------------------------------------------------------------------------------
x=Inch(12*5.0)
@show x, typeof(x), val(x), typeof(val(x))
@show Meter(x)
@show convert(Meter, x)
@show Inch(2.5) / Inch(1.1)
@show Inch(2.5) + Inch(1.1)
@show 5 * Inch(1.1)
@show perimeter(Meter(1.2), Meter(3.3))
@show perimeter_meter(Meter(1.2), Inch(36))
@show perimeter_arg1(Meter(1.2), Inch(36))
@show perimeter_arg1(Inch(36.0), Meter(1.2))
#Fails! Good! @show perimeter_arg1(Meter(1), Inch(36.0))
@show Earth.potential_energy(KiloGram(2.0), Inch(48))
@show Earth.potential_energy(KiloGram(2.0), Meter(1.1))
@show E=Earth.potential_energySI(KiloGram(4.0), Meter(2.2))
@show ToUnit(E)

true
