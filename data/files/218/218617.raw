#twiddle
#= 
	interleave bits with 64-bit multiply
=#
function mort2d(x::Uint64, y::Uint64)
	m1 = 0x0101010101010101
	m2 = 0x8040201008040201
	m3 = 0x0102040810204081
	a = (((x * m1) & m2) * m3) >> 49
	b = (((y * m1) & m2) * m3) >> 48
	return (a & 0x5555) | (b & 0xAAAA)
end

#= 
	is power of 2
=#
function ispow2(v::Uint64)
	return  (v != 0) && ((v & (v - 1)) == 0)
end


#= min, max  use julia min,  max =#

#= abs use julia abs =#

#= base 2 use julia base2 =#

# compute the next highest power of 2 of 64bit v
function nextpow2(v::Uint64)
	a = 0x0000000000000001
	b = 0x0000000000000002
	v > 0 && (v -= a) #avoid underflow wrap by unsigned(0) -1
	v |= v >> 1
	v |= v >> 2
	v |= v >> 4
	v |= v >> 8
	v |= v >> 16
	v > 0 && (
		v < b && (v += a); #fix 0 and 1 as next pow  == 2
		v < b && (v += a);
		v > b && (v += a);
	)
	return v
end

#= sign, use julia sign =#

#= opposite sign =# 
function isopsign(x::Integer, y::Integer)
	return (x $ y) < 0
end