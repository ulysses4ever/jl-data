import Base: write
using MIToS.Utils

# Write
# =====

function write{T<:Format}(filename::ASCIIString, msa::AbstractMultipleSequenceAlignment, format::Type{T}, mode::ASCIIString="w")
	open(filename, mode) do fh
		print(fh, msa, format)
	end
end

# Mappings
# ========

function _to_msa_mapping(sequences::Array{ASCIIString,1})
  nseq = size(sequences,1)
  nres = length(sequences[1])
  aln = Array(Residue,nres,nseq)
#  mapp = zeros(Int,nseq,nres) # This needs to be zeros
  mapp = Array(ASCIIString, nseq)
  seq_ann = Array(ASCIIString, nres)
  gaps = UInt8['.', '-']
  for i in 1:nseq
    init = 1
    seq = sequences[i].data
    if length(seq) == nres
      @inbounds for j in 1:nres
        res = seq[j]
        aln[j,i] = Residue( res )
        if !( res in gaps )
          seq_ann[j] = string(init)
#          mapp[i, j] = init
          init += 1
        else
          seq_ann[j] = ""
        end
      end
      mapp[i] = join(seq_ann, ',')
    else
      throw( ErrorException("There is and aligned sequence with different number of columns [ $(length(seq)) != $(nres) ]:\n$(ascii(seq))") )
    end
  end
  (aln', mapp)
end

function _to_msa_mapping(sequences::Array{ASCIIString,1}, ids::Array{ASCIIString,1})
  nseq = size(sequences,1)
  nres = length(sequences[1])
  aln = Array(Residue,nres,nseq)
#  mapp = zeros(Int,nseq,nres) # This needs to be zeros
  mapp = Array(ASCIIString, nseq)
  seq_ann = Array(ASCIIString, nres)
  gaps = UInt8['.', '-']
  sep = r"/|-"
  for i in 1:nseq
    fields = split(ids[i],sep)
    init = length(fields) == 3 ? parse(Int, fields[2]) : 1
    seq = sequences[i].data
    if length(seq) == nres
      @inbounds for j in 1:nres
        res = seq[j]
        aln[j,i] = Residue( res )
        if !( res in gaps )
          seq_ann[j] = string(init)
#          mapp[i, j] = init
          init += 1
        else
          seq_ann[j] = ""
        end
      end
      mapp[i] = join(seq_ann, ',')
    else
      throw( ErrorException("There is and aligned sequence with different number of columns [ $(length(seq)) != $(nres) ]:\n$(ascii(seq))") )
    end
    if (init - 1) != parse(Int, fields[3])
      throw( ErrorException("Different lengths: $(fields[3]) != $(init) for sequence $(ids[i])") )
    end
  end
  (aln', mapp)
end

# Delete Full of Gaps
# ===================

"""Deletes columns with 100% gaps, this columns are generated by inserts."""
function deletefullgaps!(msa::AbstractMultipleSequenceAlignment, annotate::Bool=true)
  mask = columngappercentage(msa) .!= one(Float64)
  number = sum(~mask)
  if number != 0
    annotate && annotate_modification!(msa, string("deletefullgaps! : Deletes ", number," columns full of gaps (inserts generate full gap columns on MIToS because lowercase and dots are not allowed)"))
    filtercolumns!(msa, mask, annotate)
  end
  msa
end
