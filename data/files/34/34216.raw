# Author: Thomas Macrina
# Email: tmacrina@princeton.edu
# Date: 150807
#
# Functions to load meshes, warp images via piecewise affine transforms, and
# display images with meshes.

include("incidence2triangles.jl")
include("piecewiseaffine_warp.jl")
include("visualization.jl")
include("Mesh.jl")

using JLD
using Images
using ImageView
using PiecewiseAffineTransforms
using Color
using FixedPointNumbers
using MeshModule
using Base.Test

const BUCKET = "."

xy2yx(r) = [r[:,2] r[:,1]]
xy2ij(nodes, height) = [height .- nodes[:, 2] nodes[:, 1]]
rawdata(img) = convert(Array{Float64, 2}, data(separate(img)))

function make_isotropic(img)
# Turn 2D array into Image object with isotropic pixel spacing for display
# Args:
#   img: 2D array
# Returns:
#   img: Image object for isotropic ImageView display
    img = Image(img)
    img["pixelspacing"] = [1, 1]
    return img
end

function load_mesh(mesh)
# Load mesh variables from JLD mesh file generated by Mesh.jl Mesh2JLD
# Args:
#   mesh_set: MeshSet object loaded from JLD mesh file
#   idx: index of mesh in mesh_set
# Returns:
#   src_nodes: 2xN array of original mesh nodes
#   dst_nodes: 2xN array of mesh nodes after elastic solving
#   mesh.edges: MxN array of edges as edge-node incidence matrix 
#   offset: spatial reference of mesh (2 element vector)
    src_nodes = hcat(mesh.nodes...)
    dst_nodes = hcat(mesh.nodes_t...)
    offset = convert(Array{Int64,1}, mesh.disp)
    src_nodes = src_nodes .- offset
    dst_nodes = dst_nodes .- offset
    return src_nodes, dst_nodes, mesh.edges, offset
end

function load_matches(matches)
# Load matches variables from JLD mesh file generated by Mesh.jl Mesh2JLD
# Args:
#   mesh_set: MeshSet object loaded from JLD mesh file
#   idx: index of mesh matches in mesh_set
# Returns:
#   src_pts: 2xN array of original mesh nodes
#   dst_pts: 2xN array of corresponding block matches
    src_offset = convert(Array{Int64,1}, matches.src_mesh.disp)
    src_nodes = hcat(matches.src_mesh.nodes...) .- src_offset
    src_idx = matches.src_pointIndices
    src_pts = src_nodes[:,src_idx]
    dst_offset = convert(Array{Int64,1}, matches.dst_mesh.disp)
    dst_pts = hcat(matches.dst_points...) .- dst_offset
    return src_pts, dst_pts
end

function find_node_extrema(initial_nodes, final_nodes, sz)
# Finds the extrema of the mesh, so we can pad the images accordingly
# Args:
#   initial_nodes: 2xN array of coordinates for initial mesh
#   final_nodes: 2xN array of coordinates for final mesh
#   sz: tuple for size of the 2D image
# Returns:
#   low: the amount to pad between the image and its local origin
#   xhigh: the amount to pad beyond the image, horizontally
#   yhigh: the amount to pad beyond the image, vertically
    xlow = Int64(floor(min(minimum(initial_nodes[1,:]), minimum(final_nodes[1,:]))))
    ylow = Int64(floor(min(minimum(initial_nodes[2,:]), minimum(final_nodes[2,:]))))
    xhigh = Int64(ceil(max(maximum(initial_nodes[1,:]), maximum(final_nodes[1,:]))))
    yhigh = Int64(ceil(max(maximum(initial_nodes[2,:]), maximum(final_nodes[2,:]))))
    low = min(xlow, ylow)
    high = max(xhigh, yhigh)
    low *= low < 0
    low = abs(low)
    xhigh = high-sz[2]
    yhigh = high-sz[1]
    xhigh *= xhigh > 0
    yhigh *= yhigh > 0   
    return low, xhigh, yhigh
end

function warp_tile(mesh, tile_path)
# Load mesh and image, then warp image by that mesh using piecewise affine
# Args:
#   mesh_path: string to the JLD file
#   tile_path: string to the image file
# Returns:
#   img_padded: tile image padded to match warped image dimensions
#   img_warped: tile image warped by piecewise affine solution of mesh
    initial_nodes, final_nodes, e, offset = load_mesh(mesh)

    img = rawdata(imread(tile_path))
    low, xhigh, yhigh = find_node_extrema(initial_nodes, final_nodes, size(img))
    img_padded = pad_image(img, low, low, xhigh, yhigh)

    src_nodes = xy2yx(initial_nodes') + low
    dst_nodes = xy2yx(final_nodes') + low

    node_dict = incidence2dict(e)
    triangles = dict2triangles(node_dict)

    img_warped = pa_warp2(img_padded, src_nodes, dst_nodes, triangles)
    # imgc = draw_mesh(make_isotropic(img_warped), dst_nodes, node_dict)
    return img_warped, offset
end

function render_section(tiles)
# Stitch together Tile objects
    for tile in tiles
        tile = mesh_warp(tile)
    end
    spatial_refs = Array{Int64,2}
    for tile in tiles
        spatial_refs = vcat(spatial_refs, tile.spatial_ref)
    end
    global_spatial_ref = min(spatial_refs)



end

function render_section(tile_array)
# Stitch together array of tile images and spatial references

end

function resample_to_new_spatial_ref(img, SR)
# Shift image to pixel grid of its global space (get an integer spatial ref)
end

function imfuse(A, SR_A, B, SR_B)
# Overlay two images on top of each other using their offsets. Colors one 
# image red, the other green, and the overlap yellow.
# Uses rounded interpolation.
# Args:
#   A: image A (2D array)
#   SR_A: spatial reference of image A (2 element offset vector)
#   B: image B (2D array)
#   SR_B: spatial reference of image B (2 element offset vector)
# Returns:
#   O: Image object combining both image A & B
    # pad to common origin
    SR_C = SR_B - SR_A
    if SR_C[1] > 0
        B = pad_image(B, SR_C[1], 0, 0, 0)
    elseif SR_C[1] < 0
        A = pad_image(A, -SR_C[1], 0, 0, 0)
    end 
    if SR_C[2] > 0
        B = pad_image(B, 0, SR_C[2], 0, 0)
    elseif SR_C[2] < 0
        A = pad_image(A, 0, -SR_C[2], 0, 0)
    end 
    # pad to match sizes
    szA = collect(size(A))
    szB = collect(size(B))
    szC = szB - szA
    if szC[1] > 0
        A = pad_image(A, 0, 0, 0, szC[1])
    elseif szC[1] < 0
        B = pad_image(B, 0, 0, 0, -szC[1])
    end 
    if szC[2] > 0
        A = pad_image(A, 0, 0, szC[2], 0)
    elseif szC[2] < 0
        B = pad_image(B, 0, 0, -szC[2], 0)
    end
    O = Overlay((A,B), (RGB(1,0,0), RGB(0,1,0)))
    SR_O = min(SR_A, SR_B)
    return O, SR_O
end

function pad_image(img, xlow::Int64, ylow::Int64, xhigh::Int64, yhigh::Int64)
# Pad image exterior to meet new_sz dimensions
#  _________________________________
# |                                 |
# |             ylow                |
# |         ______________          |
# |        |              |         |
# |  xlow  |     img      |  xhigh  |
# |        |              |         |
# |        |______________|         |
# |                                 |
# |             yhigh               |
# |_________________________________|
#
# Args:
#   img: 2D or 3D array
#   xlow: amount to pad in x prior to the image
#   ylow: amount to pad in y prior to the image
#   xhigh: amount to pad in x after to the image
#   yhigh: amount to pad in y after to the image
# Returns:
#   img: original img, extended with rows and columns of zeros
    sz = size(img)
    img = vcat(img, zeros(yhigh, sz[2]))
    sz = size(img)
    img = hcat(img, zeros(sz[1], xhigh))
    sz = size(img)
    img = vcat(zeros(ylow, sz[2]), img)
    sz = size(img)
    img = hcat(zeros(sz[1], xlow), img)
    return img
end

function demo_warp2()
# Demo the updated pa_warp2 function that runs faster than original package
    img = imread(joinpath(BUCKET, "test_images", "turtle.jpg"))
    img = convert(Array{Float64, 3}, data(separate(img)))[:,:,1]
    initial_nodes = [20.0 20.0;
                    620.0 20.0;
                    620.0 560.0;
                    20.0 560.0;
                    320.0 290.0]
    final_nodes = [20.0 20.0;
                    620.0 20.0;
                    620.0 560.0;
                    20.0 560.0;
                    400.0 460.0]
    incidence = [1 1 1 0 0 0 0 0;
                -1 0 0 1 1 0 0 0;
                0 0 0 -1 0 1 1 0;
                0 -1 0 0 0 0 -1 1;
                0 0 -1 0 -1 -1 0 -1]
    triangles = [1 2 5;
                1 4 5;
                2 3 5;
                3 4 5];
    src_nodes = xy2yx(initial_nodes)
    dst_nodes = xy2yx(final_nodes)
    node_dict = incidence2dict(incidence)
    draw_mesh(img, src_nodes, node_dict)
    println(size(img))

    warp = pa_warp2(img, src_nodes, dst_nodes, triangles)
    draw_mesh(warp, dst_nodes, node_dict)
    println(size(warp))
end

function demo_section()
    mesh_set = load(joinpath(BUCKET, "EM_images", "section20x5_blocksize20.jld"))["MeshSet"]
    matches = mesh_set.matches
    img_set = []
    for match in mesh_set.matches
        src_mesh =  match.src_mesh
        dst_mesh =  match.dst_mesh
        if src_mesh.index[3] > dst_mesh.index[3]
            tile_pathA = joinpath(BUCKET, src_mesh.path)
            A, SR_A = warp_tile(src_mesh, tile_pathA) 

            dst_mesh =  match.dst_mesh
            tile_pathB = joinpath(BUCKET, dst_mesh.path)
            B, SR_B = warp_tile(dst_mesh, tile_pathB)

            O, SR_O = imfuse(A, SR_A, B, SR_B)
            imwrite(O, joinpath("/usr/people/tmacrina/Desktop/W001_sec20_blocksize20", string(tile_pathA[15:end-4],"_",tile_pathB[15:end-4],".jpg") )) 
        end
    end
end

function demo_two_tiles_from_mesh_set()
# Load JLD file for MeshSet, warp images, then display
    mesh_set = load(joinpath(BUCKET, "EM_images", "Test.jld"))["MeshSet"]
    # r4_c2
    tile_pathA = joinpath(BUCKET, "EM_images", "Tile_r4-c2_S2-W001_sec20.tif")
    A, SR_A = warp_tile(mesh_set.meshes[1], tile_pathA) 
    
    # r4_c3
    tile_pathB = joinpath(BUCKET, "EM_images", "Tile_r4-c3_S2-W001_sec20.tif")
    # B, SR_B = warp_tile(mesh_set.meshes[2], tile_pathB)  

    src_pts, dst_pts = load_matches(mesh_set.matches[1])
    # draw_points(make_isotropic(rawdata(imread(tile_pathA))), src_pts)
    imgc, img2, h = draw_points(make_isotropic(rawdata(imread(tile_pathB))), dst_pts)
    O, SR_O = imfuse(A, SR_A, B, SR_B) 
    view(make_isotropic(O))
    return A, SR_A, B, SR_B
end

function test_pad_image()
    o = ones(5,2)
    po = pad_image(o, 0, 0, 0, 0)
    @test size(po, 1) == 5
    @test size(po, 2) == 2

    o = ones(5,2)
    po = pad_image(o, 1, 2, 3, 4)
    @test size(po, 1) == 11
    @test size(po, 2) == 6
    @test po[1,1] == 0

    o = ones(5,2)
    po = pad_image(o, 0, 1, 1, 0)
    @test size(po, 1) == 6
    @test size(po, 2) == 3
    @test po[6,3] == 0    

    o = convert(Array{Int64, 2}, ones(5,2))
    po = pad_image(o, 1, 2, 3, 4)
    @test size(po, 1) == 11
    @test size(po, 2) == 6
end

function test_imfuse()
    A = rand(5,5)
    B = rand(5,5)
    SR_A = [0, 0]
    SR_B = [0, 0]
    O, SR_O = imfuse(A, SR_A, B, SR_B)
    @test O.channels[1] == A
    @test O.channels[2] == B
    @test SR_O == SR_A
    @test SR_O == SR_B
end