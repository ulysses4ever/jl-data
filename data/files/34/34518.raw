# Author: Thomas Macrina
# Email: tmacrina@princeton.edu
# Date: 150807
#
# Functions to load meshes, warp images via piecewise affine transforms, and
# display images with meshes.

using HDF5
using JLD
using Images
using ImageView
using PiecewiseAffineTransforms
using Color
using FixedPointNumbers

include("incidence2triangles.jl")
include("piecewiseaffine_warp.jl")
include("visualization.jl")

const BUCKET = "."

xy2yx(r) = [r[:,2] r[:,1]]
xy2ij(nodes, height) = [height .- nodes[:, 2] nodes[:, 1]]
rawdata(img) = convert(Array{Float64, 2}, data(separate(img)))

type SpatialRef
    x::Float64
    y::Float64
end

function make_isotropic(img)
# Turn 2D array into Image object with isotropic pixel spacing for display
# Args:
#   img: 2D array
# Returns:
#   img: Image object for isotropic ImageView display
    img = Image(img)
    img["pixelspacing"] = [1, 1]
    return img
end

function load_mesh(mesh_set, idx)
    mesh = mesh_set["MeshSet"].meshes[idx]
    v = hcat(mesh.nodes...)
    vt = hcat(mesh.nodes_t...)
    offset = convert(Array{Int64,1}, mesh.disp)
    v[1,:] = v[1,:] - offset[1]
    v[2,:] = v[2,:] - offset[2]
    vt[1,:] = vt[1,:] - offset[1]
    vt[2,:] = vt[2,:] - offset[2]     
    return v, vt, mesh.edges, offset
end

function load_mesh2(mesh_path, offset)
# Load JLD mesh files generated by mesh.jl Mesh2JLD
# Args:
#   mesh_path: string to the JLD file
#   offset: 2-element array noting global offset of the images to adjust nodes
# Returns:
#   v: 2xN array of original mesh nodes
#   vt: 2xN array of mesh nodes after elastic solving
#   e: MxN array of edges as edge-node incidence matrix
    d = load(mesh_path)
    v = convert(Array{Float64,2}, d["nodes"])
    vt = convert(Array{Float64,2}, d["nodes_t"])
    e = convert(Base.SparseMatrix.SparseMatrixCSC{Float64,Int64}, d["edges"])
    v[1,:] = v[1,:] - offset[1]
    v[2,:] = v[2,:] - offset[2]
    vt[1,:] = vt[1,:] - offset[1]
    vt[2,:] = vt[2,:] - offset[2] 
    return v, vt, e, offset
end

function warp_tile2(mesh_set, tile_path, idx)
# Load mesh and image, then warp image by that mesh using piecewise affine
# Args:
#   mesh_path: string to the JLD file
#   tile_path: string to the image file
# Returns:
#   img_padded: tile image padded to match warped image dimensions
#   img_warped: tile image warped by piecewise affine solution of mesh
    initial_nodes, final_nodes, e, offset = load_mesh(mesh_set, idx)

    img = rawdata(imread(tile_path))
    xlow = Int64(floor(min(minimum(initial_nodes[1,:]), minimum(final_nodes[1,:]))))
    ylow = Int64(floor(min(minimum(initial_nodes[2,:]), minimum(final_nodes[2,:]))))
    xhigh = Int64(ceil(max(maximum(initial_nodes[1,:]), maximum(final_nodes[1,:]))))
    yhigh = Int64(ceil(max(maximum(initial_nodes[2,:]), maximum(final_nodes[2,:]))))
    low = min(xlow, ylow)
    high = max(xhigh, yhigh)
    low *= low < 0
    low = abs(low)
    xhigh = high-size(img,2)
    yhigh = high-size(img,1)
    xhigh *= xhigh > 0
    yhigh *= yhigh > 0
    println(tile_path)
    println(low)
    println(xhigh)
    println(yhigh)
    img_padded = pad_image(img, low, low, xhigh, yhigh)

    src_nodes = xy2yx(initial_nodes') + low
    dst_nodes = xy2yx(final_nodes') + low

    node_dict = incidence2dict(e)
    triangles = dict2triangles(node_dict)

    img_warped = pa_warp2(img_padded, src_nodes, dst_nodes, triangles)
    return img_padded, img_warped
end

function warp_tile(mesh_path, tile_path, offset)
# Load mesh and image, then warp image by that mesh using piecewise affine
# Args:
#   mesh_path: string to the JLD file
#   tile_path: string to the image file
# Returns:
#   img_padded: tile image padded to match warped image dimensions
#   img_warped: tile image warped by piecewise affine solution of mesh
    initial_nodes, final_nodes, e = load_mesh2(mesh_path, offset)

    img = rawdata(imread(tile_path))
    xlow = Int64(floor(min(minimum(initial_nodes[1,:]), minimum(final_nodes[1,:]))))
    ylow = Int64(floor(min(minimum(initial_nodes[2,:]), minimum(final_nodes[2,:]))))
    xhigh = Int64(ceil(max(maximum(initial_nodes[1,:]), maximum(final_nodes[1,:]))))
    yhigh = Int64(ceil(max(maximum(initial_nodes[2,:]), maximum(final_nodes[2,:]))))
    low = min(xlow, ylow)
    high = max(xhigh, yhigh)
    low *= low < 0
    low = abs(low)
    xhigh = high-size(img,2)
    yhigh = high-size(img,1)
    xhigh *= xhigh > 0
    yhigh *= yhigh > 0
    img_padded = pad_image(img, low, low, xhigh, yhigh)
    println(tile_path)
    println(low)

    src_nodes = xy2yx(initial_nodes') + low
    dst_nodes = xy2yx(final_nodes') + low

    node_dict = incidence2dict(e)
    triangles = dict2triangles(node_dict)

    img_warped = pa_warp2(img_padded, src_nodes, dst_nodes, triangles)
    return img_padded, img_warped
end

function imfuse(A, SR_A, B, SR_B)
# Incomplete
# Needs interpolation
    # pad to common origin
    SR_C = SR_B - SR_A
    if SR_C[1] > 0
        B = pad_image(B, SR_C[1], 0, 0, 0)
    elseif SR_C[1] < 0
        A = pad_image(A, -SR_C[1], 0, 0, 0)
    end 
    if SR_C[2] > 0
        B = pad_image(B, 0, SR_C[2], 0, 0)
    elseif SR_C[2] < 0
        A = pad_image(A, 0, -SR_C[2], 0, 0)
    end 
    # pad to match sizes
    szA = collect(size(A))
    szB = collect(size(B))
    szC = szB - szA
    if szC[1] > 0
        A = pad_image(A, 0, 0, 0, szC[1])
    elseif szC[1] < 0
        B = pad_image(B, 0, 0, 0, -szC[1])
    end 
    if szC[2] > 0
        A = pad_image(A, 0, 0, szC[2], 0)
    elseif szC[2] < 0
        B = pad_image(B, 0, 0, -szC[2], 0)
    end
    O = Overlay((A,B), (RGB(1,0,0), RGB(0,1,0)))  
end

function imfuse_meshes(Oc, O2, dst_nodes_A, SR_A, dst_nodes_B, SR_B)
# Incomplete
    SR_A = [0, 0]
    # SR_B = [7184.9, -178.7780] # NEED INTERPOLATION!
    SR_B = [7185, -179]
    SR_C = SR_B - SR_A
    if SR_C[1] > 0
        dst_nodes_B[:, 2] += SR_C[1]
    elseif SR_C[1] < 0
        dst_nodes_A[:, 2] -= SR_C[1]
    end 
    if SR_C[2] > 0
        dst_nodes_B[:, 1] += SR_C[2]
    elseif SR_C[2] < 0
        dst_nodes_A[:, 1] -= SR_C[2]
    end
    imgc, img2 = draw_mesh(imgc, img2, dst_nodes_B, node_dict_B, RGB(0,0,1))
    imgc, img2 = draw_mesh(imgc, img2, dst_nodes_A, node_dict_A, RGB(1,0,1))
end

function pad_image(img, xlow::Int64, ylow::Int64, xhigh::Int64, yhigh::Int64)
# Pad image exterior to meet new_sz dimensions
# Args:
#   img: 2D or 3D array
#   xlow: amount to pad in x prior to the image
#   ylow: amount to pad in y prior to the image
#   xhigh: amount to pad in x after to the image
#   yhigh: amount to pad in y after to the image
# Returns:
#   img: original img, extended with rows and columns of zeros
    
    sz = size(img)
    img = vcat(img, zeros(yhigh, sz[2]))
    sz = size(img)
    img = hcat(img, zeros(sz[1], xhigh))
    sz = size(img)
    img = vcat(zeros(ylow, sz[2]), img)
    sz = size(img)
    img = hcat(zeros(sz[1], xlow), img)
    return img
end

function demo_warp2()
# Demo the updated pa_warp2 function that runs faster than original package
    img = imread(joinpath(BUCKET, "test_images", "turtle.jpg"))
    img = convert(Array{Float64, 3}, data(separate(img)))[:,:,1]
    initial_nodes = [20.0 20.0;
                    620.0 20.0;
                    620.0 560.0;
                    20.0 560.0;
                    320.0 290.0]
    final_nodes = [20.0 20.0;
                    620.0 20.0;
                    620.0 560.0;
                    20.0 560.0;
                    400.0 460.0]
    incidence = [1 1 1 0 0 0 0 0;
                -1 0 0 1 1 0 0 0;
                0 0 0 -1 0 1 1 0;
                0 -1 0 0 0 0 -1 1;
                0 0 -1 0 -1 -1 0 -1]
    triangles = [1 2 5;
                1 4 5;
                2 3 5;
                3 4 5];
    src_nodes = xy2yx(initial_nodes)
    dst_nodes = xy2yx(final_nodes)
    node_dict = incidence2dict(incidence)
    draw_mesh(img, src_nodes, node_dict)
    println(size(img))

    warp = pa_warp2(img, src_nodes, dst_nodes, triangles)
    draw_mesh(warp, dst_nodes, node_dict)
    println(size(warp))
end

function demo_tiles()
# Demo the two tile case
    mesh_path = joinpath(BUCKET, "EM_images", "solvedMesh.jld")
    tile_path = joinpath(BUCKET, "EM_images", "Tile_r4-c2_S2-W001_sec20.tif")
    offset = [21906, 36429]
    img, img_warped = warp_tile(mesh_path, tile_path, offset)
end

function demo_two_tiles()
    # r4_c2
    mesh_path = joinpath(BUCKET, "EM_images", "r4c2_solved.jld")
    tile_path = joinpath(BUCKET, "EM_images", "Tile_r4-c2_S2-W001_sec20.tif")
    offset = [21906, 36429]
    low = 514
    initial_nodes, final_nodes, e = load_mesh2(mesh_path, offset)
    src_nodes_A = xy2yx(initial_nodes') + low
    dst_nodes_A = xy2yx(final_nodes') + low
    node_dict_A = incidence2dict(e)  
    imgA, imgA_warped = warp_tile(mesh_path, tile_path, offset)    
    imgAw = draw_mesh(make_isotropic(imgA_warped), dst_nodes_A, node_dict_A)
    
    # r4_c3
    mesh_path = joinpath(BUCKET, "EM_images", "r4c3_solved.jld")
    tile_path = joinpath(BUCKET, "EM_images", "Tile_r4-c3_S2-W001_sec20.tif")
    offset = [29090, 36251]
    low = 514
    initial_nodes, final_nodes, e = load_mesh2(mesh_path, offset)
    src_nodes_B = xy2yx(initial_nodes') + low
    dst_nodes_B = xy2yx(final_nodes') + low
    node_dict_B = incidence2dict(e)  
    imgB, imgB_warped = warp_tile(mesh_path, tile_path, offset)    
    imgBw = draw_mesh(make_isotropic(imgB_warped), dst_nodes_B, node_dict_B)
    return imgA_warped, imgB_warped
end

function demo_two_tiles_from_mesh_set()
    mesh_set = load(joinpath(BUCKET, "EM_images", "Test.jld"))
    # r4_c2
    tile_path = joinpath(BUCKET, "EM_images", "Tile_r4-c2_S2-W001_sec20.tif")
    imgA, imgA_warped = warp_tile2(mesh_set, tile_path, 1) 
    # imgAw = draw_mesh(make_isotropic(imgA_warped), dst_nodes_A, node_dict_A)
    view(make_isotropic(imgA_warped))
    
    # r4_c3
    tile_path = joinpath(BUCKET, "EM_images", "Tile_r4-c3_S2-W001_sec20.tif")
    imgB, imgB_warped = warp_tile2(mesh_set, tile_path, 2)  
    # imgBw = draw_mesh(make_isotropic(imgB_warped), dst_nodes_B, node_dict_B)
    view(make_isotropic(imgB_warped))
    return imgA_warped, imgB_warped
end

function demo_demo()
    A, B = demo_two_tiles_from_mesh_set()
    SR_A = [0, 0]
    SR_B = [29090-21906, 36251-36429]
    O = imfuse(A, SR_A, B, SR_B) 
    view(O)
end