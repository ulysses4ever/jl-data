# Author: Thomas Macrina
# Email: tmacrina@princeton.edu
# Date: 150807
#
# Functions to load meshes, warp images via piecewise affine transforms, and
# display images with meshes.

using HDF5
using JLD
using Images
using ImageView
using PiecewiseAffineTransforms
using Color
using FixedPointNumbers

include("incidence2triangles.jl")
include("piecewiseaffine_warp.jl")

const BUCKET = "/usr/people/tmacrina/seungmount/research/tommy/Julimaps"

xy2yx(r) = [r[:,2] r[:,1]]
xy2ij(nodes, height) = [height .- nodes[:, 2] nodes[:, 1]]
rawdata(img) = convert(Array{Float64, 2}, data(separate(img)))

function make_isotropic(img)
# Turn 2D array into Image object with isotropic pixel spacing for display
# Args:
#   img: 2D array
# Returns:
#   img: Image object for isotropic ImageView display
    img = Image(img)
    img["pixelspacing"] = [1, 1]
    return img
end

function draw_mesh(img, nodes, node_dict)
# Display mesh on image
# Args:
#   img: Image object
#   nodes: Nx2 array of mesh node positions
#   node_dict: dictionary of edges, indexed by node, containing connected nodes
# Returns:
#   imgc: Image canvas
#   img2: Image zoom
    imgc, img2 = view(img)
    lines = Array(Float64, 4, 0)
    for k in sort(collect(keys(node_dict)))
        for v in node_dict[k]
            a = reverse(vec(nodes[k,:]))
            b = reverse(vec(nodes[v,:]))
            lines = hcat(lines, vcat(a, b))
        end
    end
    annotate!(imgc, img2, AnnotationLines(lines, coord_order="xxyy"))
end

function pad_image(img, new_sz)
# Pad image exterior to meet new_sz dimensions
# Args:
#   img: 2D or 3D array
#   new_sz: 2-element array denoting desired size of padded image
# Returns:
#   img_padded: original img, extended with rows and columns of zeros
    sz = size(img)
    @assert sz[1] <= new_sz[1] && sz[2] <= new_sz[2]
    img_padded = vcat(img, zeros(new_sz[1]-sz[1], sz[2]))
    sz = size(img_padded)
    img_padded = hcat(img_padded, zeros(sz[1], new_sz[2]-sz[2]))
    return img_padded
end

function load_mesh(mesh_path)
# Load JLD mesh files generated by mesh.jl Mesh2JLD
# Args:
#   mesh_path: string to the JLD file
# Returns:
#   v: 2xN array of original mesh nodes
#   vt: 2xN array of mesh nodes after elastic solving
#   e: MxN array of edges as edge-node incidence matrix
    d = load(mesh_path)
    v = convert(Array{Float64,2}, d["nodes"])
    vt = convert(Array{Float64,2}, d["nodes_t"])
    e = convert(Base.SparseMatrix.SparseMatrixCSC{Float64,Int64}, d["edges"])
    return v, vt, e
end

function warp_tile(mesh_path, tile_path, offset)
# Load mesh and image, then warp image by that mesh using piecewise affine
# Args:
#   mesh_path: string to the JLD file
#   tile_path: string to the image file
#   offset: 2-element array noting global offset of the images to adjust nodes
# Returns:
#   img_padded: tile image padded to match warped image dimensions
#   img_warped: tile image warped by piecewise affine solution of mesh
    v, vt, e = load_mesh(mesh_path)
    initial_nodes = v
    final_nodes = vt
    initial_nodes[1,:] = v[1,:] - offset[1]
    initial_nodes[2,:] = v[2,:] - offset[2]
    final_nodes[1,:] = vt[1,:] - offset[1]
    final_nodes[2,:] = vt[2,:] - offset[2]    

    img = rawdata(imread(tile_path))
    high = Int64(ceil(max(maximum(initial_nodes), maximum(final_nodes))))
    img_padded = pad_image(img, (high, high))

    src_nodes = xy2yx(initial_nodes')
    dst_nodes = xy2yx(final_nodes')

    node_dict = incidence2dict(e)
    triangles = dict2triangles(node_dict)
    img_warped = pa_warp2(img_padded, src_nodes, dst_nodes, triangles)
    draw_mesh(make_isotropic(img_padded), src_nodes, node_dict)
    draw_mesh(make_isotropic(img_warped), dst_nodes, node_dict) 
    return img_padded, img_warped
end

function demo_mesh()
# Load a mesh and display it on a black background
    mesh_path = joinpath(BUCKET, "test_images", "solvedMesh.jld")
    v, vt, e = load_mesh(mesh_path)
    offset = [21906, 36429]
    incidence = e
    initial_nodes = v
    initial_nodes[1,:] = v[1,:] - offset[1]
    initial_nodes[2,:] = v[2,:] - offset[2]
    nodes = xy2yx(initial_nodes')
    node_dict = incidence2dict(incidence)
    sz = round(Int,maximum(nodes[:,1]))+10, round(Int,maximum(nodes[:,2]))+10
    img = zeros(Bool, sz...)

    println("Original images and shapes")
    draw_mesh(make_isotropic(img), nodes, node_dict)
end

function demo_warp2()
# Demo the updated pa_warp2 function that runs faster than original package
    img = imread(joinpath(BUCKET, "test_images", "turtle.jpg"))
    img = convert(Array{Float64, 3}, data(separate(img)))
    initial_nodes = [20.0 20.0;
                    620.0 20.0;
                    620.0 560.0;
                    20.0 560.0;
                    320.0 290.0]
    final_nodes = [20.0 20.0;
                    620.0 20.0;
                    620.0 560.0;
                    20.0 560.0;
                    400.0 460.0]
    incidence = [1 1 1 0 0 0 0 0;
                -1 0 0 1 1 0 0 0;
                0 0 0 -1 0 1 1 0;
                0 -1 0 0 0 0 -1 1;
                0 0 -1 0 -1 -1 0 -1]
    triangles = [1 2 5;
                1 4 5;
                2 3 5;
                3 4 5];
    src_nodes = xy2yx(initial_nodes)
    dst_nodes = xy2yx(final_nodes)
    node_dict = incidence2dict(incidence)
    draw_mesh(img, src_nodes, node_dict)
    println(size(img))

    warp = pa_warp2(img, src_nodes, dst_nodes, triangles)
    draw_mesh(warp, dst_nodes, node_dict)
    println(size(warp))
end

function demo_tiles()
# Demo the two tile case
    mesh_path = joinpath(BUCKET, "test_images", "solvedMesh.jld")
    tile_path = joinpath(BUCKET, "test_images", "Tile_r4-c2_S2-W001_sec20.tif")
    offset = [21906, 36429]
    img, img_warped = warp_tile(mesh_path, tile_path, offset)
end
