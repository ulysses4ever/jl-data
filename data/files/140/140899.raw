# @doc+ """
# getSolver(url,token,solver_name) just gets the solver through the API.
# """->
function getSolver(url,token,name)
  solver = None #getSolver(url,token,name)
  while solver == None
    try
      remote_connection = dwave_sapi.RemoteConnection(url,token)
    #solver_names =  remote_connection[:solver_names]()
    solver = remote_connection[:get_solver](name)
    # solver=getSolver(url,token,name)
    catch y
      if isa(y,InterruptException)
        throw(InterruptException())
      end
    end
  end
	return solver
end

# @doc+ """
# Pass the solver from getSolver and it'll get the hardware adjacency.
# """->
function getAdjacency(solver::PyObject,M=8,N=8,dimV=4)
  A=dwave_sapi.get_hardware_adjacency(solver)
  things = (Int64,Int64)[]
  for x in A
    push!(things,x)
  end
  adjMatrix = zeros(Bool,2*M*N*dimV,2*M*N*dimV)
  for x in things
    adjMatrix[x[1]+1,x[2]+1]=true
  end
  return adjMatrix
end

function inst2py(dwi::ProblemInstance)
  h = PyVector(dwi.h)
  J = PyDict([(i-1,j-1)=>dwi.J[i,j] for i=1:size(dwi.J,1),j=1:size(dwi.J,2)])
  return h,J
end

# @doc+ """
# Tries to find the D-Wave embedding using the heuristic embedder. Returns a SAPIEmbedding. Accepts the instance,
# the solver from getSolver, and the chain strength you want.
# """->
function dw_find_embedding(dwi,solver,J_F)
  h = dwi.h
  J = cast_to_upper_triangular(dwi.J)
  adjMat = int(J.!=0)
  h2,J2 = inst2py(dwi)
  adj = dwave_sapi.get_hardware_adjacency(solver)
  adjMat_embed = getAdjacency(solver)
  #nq = sum(getUsedQubits(zeros(Int64,size(adjMat_embed,1)),int(adjMat_embed)))
  embedding = dwave_sapi.find_embedding(J2,size(J,1),adj,size(adjMat_embed,1))
  jl_embedding = Vector{Int64}[]
  for i=1:length(embedding)
   push!(jl_embedding,[int(x)+1 for x in embedding[i]]) # +1 moves from 0 indexing in Python to 1 in Julia.
  end
  return SAPIEmbedding(jl_embedding,sparse(adjMat),sparse(adjMat_embed),J_F)
end

function solve_ising(solver,dwi;anneal_time_per_run=20,programming_thermalization_time=20000,
                     readout_thermalization_time=10,answer_mode="raw",numreads = 10^4,to_rescale=true)
  to_rescale ? inst=rescale(dwi) : inst=dwi
  hmat=inst.h
  Jmat=full(inst.J)
  h,J=inst2py(inst)
  const T=eltype(dwi.J)
  answer=dwave_sapi.solve_ising(solver,h,J,num_reads=numreads, auto_scale=false,
                                programming_thermalization_time=programming_thermalization_time,
                                readout_thermalization_time=readout_thermalization_time,
                                answer_mode=answer_mode,
                                anneal_time_per_run=anneal_time_per_run)
  #energies=copy(answer["energies"])
  solutions=copy(answer["solutions"]')
  energies = [get_energy(dwi,solutions[:,i])::T for i=1:numreads]
  usedQubits = zeros(Bool,size(solutions,1))
  usedQubits[find(solutions[:,1].!=3)] = true
  solutions[solutions.==3]=0 # unused=0
  solutions[solutions.<0]=0 # -1 = 0
  timing = copy(answer["timing"])
  solutions=bitpack(solutions)
  return energies,solutions,timing,usedQubits
end

function runProgrammingCycle(solver,dwi,tann,numReads,to_rescale=true)
  energies = nothing
  solutions = nothing
  timing = nothing
  usedQubits = nothing
  while energies == nothing
    try
      energies,solutions,timing,usedQubits = solve_ising(solver,dwi;anneal_time_per_run = tann,numreads=numReads,to_rescale=to_rescale)
    catch y
      if isa(y,InterruptException)
        throw(InterruptException())
      else
        println(y)
      end
    end
  end
  d = time() # d for date, meh.
  return energies,solutions,timing,usedQubits,d
end

# @doc+ """
# input arugments: ProblemInstance, savepath, Vector{(Embedding,annealing_time,url,solver,number_of_reads)},token,skip=true.
# url, solver, token are all strings of the D-Wave API url, token, and the solver you want to use.

# output: none, except a saved .jld file with the follows keys, all strings, (i.e. key `energies` is the string "energies") :
# 1. "energies" which are the energies of each solution found by running get_energy(instance,solution). A vector of vectors,
#  one for each programming cycle.
# 2. "solutions", a vector of BitArrays of true/false values transformed back to Ising as 2*sols-1 (true=>1,false=>-1).
# For Vesuvius, each BitArray is 512xnumReads.
# 3. "dates" is a simple vector of Unix time in seconds.
# 4. "timing" is a vector of dictionaries, storing the datastructure from the D-Wave API.
# 5. "sweeps" which is just a vector of the annealing times.
# 6. "instance" which is the instance.
# """->
function run_instance_DW{T,X<:Tuple{Embedding,Int64,AbstractString,AbstractString,Int64}}(dwi::ProblemInstance{T},savepath,
  progcycles::Vector{X},token;skip=true,to_rescale=true,tosave=true)
  # forced to have nonstandard/improper function call b/c we don't want to store the token in the
  # saved files
  # progcycle: embedding, t_ann, url, solver, numReads
  # embeddings is a vector of embeddings, for simplicity
  run_progcycles = (Embedding,Int64,AbstractString,AbstractString,Int64)[]
  if haskey(dwi.properties,:filename)
    fn = savepath*dwi.properties[:filename]*".jld"
  else
    fn = savepath*string(hash(dwi))*".jld"
  end
  hasold = isfile(fn)
  if hasold
    progcycles_old = load(fn,"progcycles")
    for progcycle in progcycles
      if sum(progcycle.==progcycles_old)==0
        push!(run_progcycles,progcycle) #unique across all if skip
        #push!(progcycles_old,progcycle)
      end
    end
  else
    run_progcycles = copy(progcycles)
  end
  if !skip
    run_progcycles = copy(progcycles) # run everybody if not skip
  end
  if length(run_progcycles)>0
    if hasold
      energies_old = load(fn,"energies")
      solutions_old = load(fn,"solutions")
      dates_old = load(fn,"dates")
      timing_old = load(fn,"timing")
      sweeps_old = load(fn,"sweeps")
    end
    embed1 = applyEmbedding(run_progcycles[1][1],dwi)
    dates = Float64[] #zeros(Float64,length(run_progcycles))
    energies = Vector{T}[] #zeros(T,numReads)
    solutions = BitArray{2}[] #falses(length(dwi.h),numReads)
    numtrees = Vector{Int64}[] #zeros(Int64,numReads)
    sweeps = Vector{Float64}[] #zeros(Float64,numReads)
    timing = Dict[]
    for progcycle in run_progcycles
      embedding,tann,url,solver_name,numReads = progcycle
      solver = getSolver(url,token,solver_name)
      dwi_g = applyEmbedding(embedding,dwi)
      eg,sg,tg,ug,dg = runProgrammingCycle(solver,dwi_g,tann,numReads,to_rescale)
      push!(energies,eg)
      push!(solutions,sg)
      push!(timing,tg)
      push!(sweeps,ones(size(eg,1)).*tann)
      push!(dates,dg)
    end
    if hasold
      progcycles = vcat(progcycles_old,run_progcycles)
      energies = vcat(energies_old,energies)
      solutions = vcat(solutions_old,solutions)
      dates = vcat(dates_old,dates)
      timing = vcat(timing_old,timing)
      sweeps = vcat(sweeps_old,sweeps)
    end
    if tosave
      save(fn,Dict("progcycles"=>progcycles,"energies"=>energies,"solutions"=>solutions,"dates"=>dates,"timing"=>timing,"sweeps"=>sweeps,"instance"=>dwi),compress=true)
    else
      return energies,solutions,progcycles,dates,sweeps,timing,dwi
    end
  end
  return nothing
end

run_instance_DW{T,X<:Tuple{Embedding,Int64,AbstractString,AbstractString,Int64}}(dwi::ProblemInstance{T},savepath,
  progcycles::X;skip=true,numReads=10^4) = run_instance_DW(dwi,savepath,(progcycles...,numReads),skip)
run_instance_DW{T,X<:Tuple{Embedding,Int64,Real,Real}}(dwi::ProblemInstance{T},savepath,
  progcycles::Vector{X};skip=true,numReads=10^4) = run_instance_DW(dwi,savepath,[(x...,numReads)::([[X...],Int64]...) for x in progcycles],skip=skip)
run_instance_DW{T,X<:Tuple{Embedding,Int64,Real,Real,Int64}}(dwi::ProblemInstance{T},savepath,
  progcycles::X;skip=true)=run_instance_DW(dwi,savpeath,[progcycles],skip=skip)

function runInstance(url,token,name,dwi,savepath,embeddings,rescale=false,skip=true,numReads=10^4,tanns=[20])
  # embeddings is a vector of embeddings, for simplicity
  # THIS FUNCTION IS RETAINED ONLY FOR BACKWARDS COMPATIBILITY
  # USER runInstance_DW for the future
  solver=getSolver(url,token,name)
  progcycles = (Union(Embedding,Vector{Embedding}),Int64)[]
  run_progcycles = (Union(Embedding,Vector{Embedding}),Int64)[]
  for embedding in embeddings
    for tann in tanns
      push!(progcycles,(embedding,tann))
    end
  end
  if haskey(dwi.properties,:filename)
    fn = savepath*dwi.properties[:filename]*".jld"
  else
    fn = savepath*string(hash(dwi))*".jld"
  end
  hasold = isfile(fn)
  if hasold
    progcycles_old = load(fn,"progcycles")
    # timing_old = load(fn,"timing")
    # Es_old = load(fn,"energies")
    # sols_old = load(fn,"solutions")
    # dates_old = load(fn,"dates")
    for progcycle in progcycles
      if sum(progcycle.==progcycles_old)==0
        push!(run_progcycles,progcycle) #unique across all if skip
        push!(progcycles_old,progcycle)
      end
    end
  else
    for progcycle in progcycles
      if sum(progcycle.==run_progcycles)==0
        push!(run_progcycles,progcycle) # unique if skip
      end
    end
  end
  if !skip
    run_progcycles = copy(progcycles) # run everybody if not skip
  end
  if length(run_progcycles)>0
    if hasold
      timing_old = load(fn,"timing")
      Es_old = load(fn,"energies")
      sols_old = load(fn,"solutions")
      dates_old = load(fn,"dates")
    end
    h=dwi.h
    J=cast_to_upper_triangular(dwi.J)
    props=dwi.properties
    files = readdir(savepath)
    embed1 = applyEmbedding(run_progcycles[1][1],dwi)
    usedQubits = getUsedQubits(embed1)
    nq = size(embed1.h,1)
    num_cycles = length(run_progcycles)
    Es = zeros(typeof(embed1.J[1]),numReads,num_cycles)
    solutions = bitpack(zeros(Bool,nq,numReads,num_cycles))
    timing = Dict[]
    date_run = zeros(Float64,num_cycles)
    index = 1
    for progcycle in run_progcycles
      embedding,tann = progcycle
      dwi_g = applyEmbedding(embedding,dwi)
      eg,sg,tg,ug,dg = runProgrammingCycle(solver,dwi_g,tann,numReads)
      (usedQubits!=ug) && error("Mismatched qubits between problem and programming cycle, wtf?")
      #eg2,sg2 = reverseEmbedding(embedding,dwi,eg,sg)
      Es[:,index]=eg
      solutions[:,:,index]=sg
      push!(timing,tg)
      date_run[index] = dg
      index+=1
    end
    if hasold
      progcycles = vcat(progcycles_old,run_progcycles)
      Es = cat(2,Es_old,Es)
      solutions = cat(3,sols_old,solutions)
      date_run = vcat(dates_old,date_run)
      timing = vcat(timing_old,timing)
    end
    save(fn,Dict("progcycles"=>progcycles,"energies"=>Es,"solutions"=>solutions,"dates"=>date_run,"timing"=>timing,"instance"=>dwi))
  end
  return nothing
end
