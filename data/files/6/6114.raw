#################################################################
#
#    Main file of MCMC.jl module
#
#################################################################

module MCMC

using Distributions # logcdf() and Normal() are used in src/bayesglmmodels.jl (log-likelihood of Bayesian probit model)

import Base.*, Base.show
export show, *
export MCMCTask, MCMCChain

###########  Models and autodiff  ##########
include("modellers/mcmcmodels.jl")      #  include model types definitions		
include("modellers/bayesglmmodels.jl") # include Bayesian GLM models, such as logit and probit

include("modellers/parsing.jl")     #  include model expression parsing function
include("modellers/diff.jl")        #  include derivatives definitions
include("modellers/distributions.jl")    #  include distributions definitions


### MCMCTask type, generated by combining a MCMCModel with a MCMCSampler
type MCMCTask
	task::Task
	model::MCMCModel
end
reset(t::MCMCTask, x) = t.task.storage[:reset](x)

#############  samplers  ########################
include("samplers/samplers.jl")  # Common definitions for samplers

include("samplers/RWM.jl")    # Random-walk Metropolis sampler
include("samplers/MALA.jl")   # Metropolis adjusted Langevin algorithm sampler
include("samplers/HMC.jl")    # Hamiltonian Monte-Carlo sampler

#  Definition of * as a shortcut operator for model and sampler combination 
*{M<:MCMCModel, S<:MCMCSampler}(m::M,        s::S       ) = spinTask(m, s)
*{M<:MCMCModel, S<:MCMCSampler}(m::Array{M}, s::S       ) = map((me) -> spinTask(me, s), m)
*{M<:MCMCModel, S<:MCMCSampler}(m::M,        s::Array{S}) = map((se) -> spinTask(m, se), s)

### MCMCChain, the result of running a MCMCTask
type MCMCChain
   samples::Dict
   weights::Vector{Float64}  # weight of sample, used for sequential MC
   task::MCMCTask
   runTime::Float64
 end
MCMCChain(s::Dict, t::MCMCTask) = MCMCChain(s, t, NaN)
MCMCChain(s::Dict, t::MCMCTask, ti::Float64) = MCMCChain(s, Float64[], t, ti)

function show(io::IO, res::MCMCChain)
	local samples = 0
	for v in keys(res.samples)
		print("$v$(size(res.samples[v])[1:end-1]) ")
		samples = size(res.samples[v])[end]
	end 
	print("by $samples samples, ")
	println("$(round(res.runTime,1)) sec.")
end

#############  runners    ########################

include("runners/run.jl")      # Vanilla runner
include("runners/seqMC.jl")    # Sequential Monte-Carlo runner
include("runners/serialMC.jl")    # Serial Tempering Monte-Carlo runner

end
