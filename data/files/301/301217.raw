module MarketRisk

using Base.Dates
using InterestRates

export
	HistoricalData, Index, SpreadCurve, RiskFactor, SpotCurrency, 
	IRCurveRisk, getname, PricingModel, FinancialContract, FixedIncome, Bullet, 
	Scenario, price

import Base.hash, Base.isequal

abstract HistoricalData

type Index <: HistoricalData
	name::ASCIIString
end

# Not bound to maturity. Is bound to entire term structure.
type SpreadCurve <: HistoricalData
	name::ASCIIString
end

abstract RiskFactor

type SpotCurrency <: RiskFactor
	name::ASCIIString
end

# Not bound to maturity. Is bound to entire term structure.
type IRCurveRisk <: RiskFactor
	name::ASCIIString
end

# TODO: generate code for getname function
getname(rf::SpotCurrency) = rf.name
getname(rf::IRCurveRisk) = rf.name
getname(hd::Index) = hd.name
getname(hd::SpreadCurve) = hd.name

hash(rf::RiskFactor) = hash(getname(rf))
isequal(x::RiskFactor, y::RiskFactor) = getname(x) == getname(y)

hash(hd::HistoricalData) = hash(getname(hd))
isequal(x::HistoricalData, y::HistoricalData) = getname(x) == getname(y)

abstract PricingModel
abstract FixedIncome <: PricingModel

type Bullet <: FixedIncome
	currency::SpotCurrency
	basecurve::IRCurveRisk
	spreadcurve::SpreadCurve
end

type Scenario
	date :: Date
	data :: Dict{Union{HistoricalData, RiskFactor}, Union{Float64, AbstractIRCurve}}
end

getfunctionalcurrency() = error("Function getfunctionalcurrency should be overloaded.")

abstract AbstractFinancialContract
type FinancialContract <: AbstractFinancialContract
	id::Int
	portfolio::Vector{ASCIIString}
	model::PricingModel
	attributes::Dict{ASCIIString, Union{Float64, Int, ASCIIString, Date}}
	log::Vector{ASCIIString}

	FinancialContract(id::Int, portfolio::Vector{ASCIIString}, model::PricingModel) = new(id, portfolio, model, Dict{ASCIIString, Union{Float64, Int, ASCIIString, Date}}(), Vector{ASCIIString}())
end

projectCashFlows(c::FinancialContract, s::Scenario) = error("projectCashFlows not defined for $(p) and $(s)")

# Let's multiple-dispatch on pricing models
price(c::FinancialContract, s::Scenario) = _price(c.model, c, s)

_currencyvalue(c::SpotCurrency, s::Scenario) = getfunctionalcurrency() == c ? 1.0 : s.data[c]

function _price(b::Bullet, c::FinancialContract, s::Scenario)
	cur = _currencyvalue(b.currency, s)
	maturity::Date = c.attributes["MATURITY"]
	discountfactor_base = discountfactor(s.data[b.basecurve], maturity)
	discountfactor_spread = discountfactor(s.data[b.spreadcurve], maturity)
	notional::Float64 = c.attributes["NOTIONAL"]
	asset_liability_multiplier = c.attributes["ASSET_LIABILITY"] == "a" ? 1.0 : -1.0
	
	push!(c.log, "discountfactor_base=$discountfactor_base")
	push!(c.log, "discountfactor_spread=$discountfactor_spread")
	
	return asset_liability_multiplier * cur * notional * discountfactor_base * discountfactor_spread
end

end # module MarketRisk