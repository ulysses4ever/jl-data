
# Pricing functions for MarketRisk module

function _price(b::Bullet, c::FinancialContract, s::Scenario)
	cur = _currencyvalue(b.currency, s)
	maturity::Date = c.attributes["MATURITY"]
	discountfactor_base = discountfactor(s.data[b.basecurve], maturity)
	discountfactor_spread = discountfactor(s.data[b.spreadcurve], maturity)
	notional::Float64 = c.attributes["NOTIONAL"]
	asset_liability_multiplier = c.attributes["ASSET_LIABILITY"] == "a" ? 1.0 : -1.0
	
	push!(c.log, "currency=$(cur)")
	push!(c.log, "discountfactor_base=$(discountfactor_base)")
	push!(c.log, "discountfactor_spread=$(discountfactor_spread)")

	# Using ForwardDiff to obtain partial derivatives
	riskfactors_values = [ cur, discountfactor_base ]
	_pricingkernel_(x) = asset_liability_multiplier * notional * discountfactor_spread * x[1] * x[2]
	_grad_ = forwarddiff_gradient(_pricingkernel_, Float64, fadtype=:typed)
	out_price = _pricingkernel_(riskfactors_values)
	out_riskfactors = [ b.currency, IRCurveRiskVertex(b.basecurve, maturity) ]
	out_exposures = riskfactors_values .* _grad_(riskfactors_values)

	# Hard coded partial derivatives : it's 6 times faster
	#out_price = asset_liability_multiplier * notional * discountfactor_spread * cur * discountfactor_base
	#out_riskfactors = [ b.currency, IRCurveRiskVertex(b.basecurve, maturity) ]
	#out_exposures = [ out_price, out_price ]

	return out_price, out_riskfactors, out_exposures
end

function _price(b::ForwardCurrency, c::FinancialContract, s::Scenario)
	
	# Payoff is S - K
	# price is : f = S*PU(currency) - K*PU(base_curve)
	# where S is spot currency value, and K is forward price of the contract

	cur = _currencyvalue(b.currency, s)
	maturity::Date = c.attributes["MATURITY"]
	discountfactor_base = discountfactor(s.data[b.basecurve], maturity)
	discountfactor_currency = discountfactor(s.data[b.currencycurve], maturity)
	notional::Float64 = c.attributes["NOTIONAL"]
	asset_liability_multiplier = c.attributes["ASSET_LIABILITY"] == "a" ? 1.0 : -1.0
	K = c.attributes["FORWARD_PRICE"]
	
	push!(c.log, "currency=$(cur)")
	push!(c.log, "discountfactor_base=$(discountfactor_base)")
	push!(c.log, "discountfactor_currency=$(discountfactor_currency)")

	# Using ForwardDiff to obtain partial derivatives
	riskfactors_values = [ cur, discountfactor_currency, discountfactor_base ]
	_pricingkernel_(x) = asset_liability_multiplier * notional * (x[1] * x[2] - K * x[3])
	_grad_ = forwarddiff_gradient(_pricingkernel_, Float64, fadtype=:typed)
	out_price = _pricingkernel_(riskfactors_values)
	out_riskfactors = [ b.currency, IRCurveRiskVertex(b.currencycurve, maturity), IRCurveRiskVertex(b.basecurve, maturity) ]
	out_exposures = riskfactors_values .* _grad_(riskfactors_values)

	# Hard coded partial derivatives : about the same performance
	#out_price = asset_liability_multiplier * notional * (cur * discountfactor_currency - K * discountfactor_base)
	#out_riskfactors = [ b.currency, IRCurveRiskVertex(b.currencycurve, maturity), IRCurveRiskVertex(b.basecurve, maturity) ]
	#bond = asset_liability_multiplier * notional * cur * discountfactor_currency
	#out_exposures = [ bond, bond, -asset_liability_multiplier * notional * K * discountfactor_base ]

	return out_price, out_riskfactors, out_exposures
end