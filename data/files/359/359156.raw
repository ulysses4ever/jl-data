# CLUSTERING ==========================================================================================================

# https://github.com/JuliaStats/Clustering.jl
# Documentation at http://clusteringjl.readthedocs.org/en/latest/.

using Clustering

# CHOOSE DATA ---------------------------------------------------------------------------------------------------------

using RDatasets

# Check out some of the available clustering data sets.
#
RDatasets.datasets("cluster")

# -> Bivariate Data Set with 3 Clusters
#
xclara = dataset("cluster", "xclara");
#
# Rename columns.
#
names!(xclara, [symbol(i) for i in ["x", "y"]]);

using Gadfly

# Visually identify three clusters.
#
plot(x = xclara[:x], y = xclara[:y], Geom.point())

# -> Isotopic Composition Plutonium Batches
#
pluton = dataset("cluster", "pluton");

# DATA PREPARATION ----------------------------------------------------------------------------------------------------

# Convert to an Array
#
xclara = convert(Array, xclara);

# Transpose (Each sample should be in a separate column for generating distance matrix).
#
xclara = xclara';

# And do the same for our Plutonium data.
#
pluton = convert(Array, pluton);
pluton = pluton';

# DISTANCE MATRIX -----------------------------------------------------------------------------------------------------

using Distances

dclara = pairwise(SqEuclidean(), xclara);   # The squared Euclidean distance
dclara[1:5, 1:5]

# INITIALISATION ------------------------------------------------------------------------------------------------------

# Only need one of the following.

initseeds(:rand, xclara, 3)                 # Random selection
seeds = initseeds(:kmpp, xclara, 3)         # Kmeans++ algorithm
initseeds(:kmcen, xclara, 3)                # Select samples with highest centrality

initseeds_by_costs(:rand, dclara, 3)
initseeds_by_costs(:kmpp, dclara, 3)
initseeds_by_costs(:kmcen, dclara, 3)

# K-MEANS -------------------------------------------------------------------------------------------------------------

# Perform k-means clustering, returning an object of type KmeansResult.
#
xclara_kmeans = kmeans(xclara, 3)

# Plot points coloured with cluster assignment.
#
plot(x = xclara[1,:], y = xclara[2,:], color = assignments(xclara_kmeans), Geom.point(),
     Scale.color_discrete_manual("blue", "red", "green"))

# Cluster centers
#
xclara_kmeans.centers

# Cluster assignments and counts.
#
xclara_kmeans.assignments
assignments(xclara_kmeans)
#
xclara_kmeans.counts

# Check that we got the specified number of clusters.
#
@assert nclusters(xclara_kmeans) == 3

# Perform k-means clustering using initial seeds. You can either specity the method or a vector of seeds generated by
# one of the initialisation methods above.
#
# Options for display are :none, :iter and :final.
#
xclara_kmeans = kmeans(xclara, 3, init = :kmpp, display = :iter)

# K-MEDIODS -----------------------------------------------------------------------------------------------------------

# Perform k-mediods clustering, returning an object of type KmedoidsResult. Note that, in contrast to k-means which
# uses the Euclidean metric, k-medoids can work with any metric. So the distance matrix passed as the first argument
# could be generated by Euclidean, squared Euclidean, cityblock, Mahalanobis etc.
#
xclara_kmedoids = kmedoids(dclara, 3)

# Cluster centers
#
xclara_kmedoids.medoids

# Cluster assignments and counts.
#
xclara_kmedoids.assignments
assignments(xclara_kmedoids)
#
xclara_kmedoids.counts
counts(xclara_kmedoids)

# Plot points coloured with cluster assignment.
#
plot(x = xclara[1,:], y = xclara[2,:], color = assignments(xclara_kmedoids), Geom.point(),
     Scale.color_discrete_manual("blue", "red", "green"))

# Perform k-mediods clustering using initial seeds.
#
xclara_kmedoids = kmedoids(dclara, 3, init = seeds, display = :final)

# DBSCAN --------------------------------------------------------------------------------------------------------------

# DBSCAN is a density based clustering algorithm.

# Perform DBSCAN clustering, returning an object of type DbscanResult.
#
xclara_dbscan = dbscan(dclara, 10, 40)

plot(x = xclara[1,:], y = xclara[2,:], color = assignments(xclara_dbscan), Geom.point(),
     Scale.color_discrete_manual("blue", "red", "green", "black"))

# AFFINITY PROPAGATION ------------------------------------------------------------------------------------------------

# affinityprop() performs affinity propagation, returning an object of type AffinityPropResult.

# QUICKSHIFTCLUSTERING ================================================================================================

# Hierarchical clustering.

using QuickShiftClustering

clusters = quickshift(xclara)
labels = quickshiftlabels(clusters)
quickshiftplot(clusters, xclara, labels)
