############################   MAIN FUNCTIONS ###############################

# Main function that takes care of translating the model into source code
# of target language
function generate_code!(ode_model::dt.OdeModel; language = "julia",
                        unit_analysis = true, name = "autogenerated_model",
                        file = "autogenerated_model", jacobian = false,
                        sensitivities = false)


  # Create dictionaries containing the default values of the inputs (at the reference scale)
  # and the conversion coefficients for the units. This prepares the inputs for the
  # code generation functions
  coef_observed = OrderedDict{ASCIIString, Float64}()
  for i in ode_model.NamesObserved
    coef_observed[i] = ode_model.Equations[i].Units.f
  end
  named_states = OrderedDict{ASCIIString, Float64}()
  coef_states = OrderedDict{ASCIIString, Float64}()
  for (key,val) in ode_model.States
    named_states[key] = val.Value * val.Units.f
    coef_states[key] = val.Units.f
  end
  named_parameters = OrderedDict{ASCIIString, Float64}()
  coef_parameters = OrderedDict{ASCIIString, Float64}()
  for (key,val) in ode_model.Parameters
    named_parameters[key] = val.Value * val.Units.f
    coef_parameters[key] = val.Units.f
  end
  forcings = OrderedDict{ASCIIString,Any}()
  coef_forcings = OrderedDict{ASCIIString,Float64}()
  c = 0
  for (key,value) in ode_model.Forcings
      c += 1
      forcings[key] = (float(value.Time), float(value.Value)*value.Units.f)
      coef_forcings[key] = value.Units.f
  end

  # Write a file with the default inputs for the model in JSON format
  write_inputs!(named_states,coef_states, named_parameters, coef_parameters,
               forcings, coef_forcings, ode_model.NamesObserved,coef_observed,
               file)

  # Sort the equations of the model
  sorted_model = OdeSorted(ode_model)

  # Check the physical dimensions of the equations in the model (if demanded)
  unit_analysis &&  check_units(sorted_model)

  # Generate the rhs function (includes observed variables)
  # If DynamicType = DAE generate semiexplicit representation of dae model
  if (sorted_model.DynamicType == "ODE")
    model_function = create_derivatives(language, sorted_model, name)
    if(language == "cpp")
      observed_function = ""
    else 
      observed_function = create_observed(language, sorted_model, name)
    end
  else
    error("Only DynamicType = \"ode\" is currently supported")
  end


  # Write down the code!
  write_code!(language, ode_model.DynamicType, model_function, observed_function, name, file)

  nothing

end


############################ WRITE TIME DERIVATIVES ################################

# This function writes the source for calculating the time derivatives and observed variables
# and it dispatches the correct function depending on the language argument
function create_derivatives(language, sorted_model, name)
  if (language == "julia")
    return create_derivatives_julia(sorted_model, name)
  elseif (language == "cpp")
    return create_derivatives_rcpp(language, sorted_model, name)
  else
    error("Currently only \"julia\" and \"cpp\" are supported")
  end
end

############################ WRITE INDEPENDENT OBSERVER ################################

# This function writes the source for calculating the time derivatives and observed variables
# and it dispatches the correct function depending on the language argument
function create_observed(language, sorted_model, name)
  if (language == "julia")
    return create_observed_julia(sorted_model, name)
  else
    error("Currently only \"julia\" and \"cpp\" are supported")
  end
end

############################### WRITE CODE FILES ###################################

# Write a JSON file with all the inputs of the model.
# This should be readable in every language
function write_inputs!(named_states,coef_states, named_parameters, coef_parameters,
                       forcings, coef_forcings, observed,coef_observed,
                       file)
  f = open("$(file)_inputs.json","w")
  inputs = {"states" => named_states,
            "coef_states" => coef_states,
            "parameters" => named_parameters,
            "coef_parameters" => coef_parameters,
            "forcings" => forcings,
            "coef_forcings" => coef_forcings,
            "observed" => observed,
            "coef_observed" => coef_observed}
  JSON.print(f, inputs)
  close(f)
end

# Write a source file with all the functions associated to the model in the target language
function write_code!(language, dynamic_type, model_function, observed_function, name, file)

  if (language == "julia")
    return write_code_julia!(dynamic_type, model_function, observed_function, name, file)
  elseif (language == "cpp")
    return write_code_rcpp!(dynamic_type, model_function, name, file)
  end

end
