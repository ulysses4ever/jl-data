############################   MAIN FUNCTIONS ###############################

# Main function that takes care of translating the model into source code
# of target language
function generate_code!(ode_model::dt.OdeModel; language = "julia",
                        unit_analysis = true, name = "autogenerated_model",
                        file = "autogenerated_model", jacobian = false,
                        sensitivities = false)


  # Create dictionaries containing the default values of the inputs (at the reference scale)
  # and the conversion coefficients for the units. This prepares the inputs for the
  # code generation functions
  coef_observed = OrderedDict{ASCIIString, Float64}()
  for i in ode_model.NamesObserved
    coef_observed[i] = ode_model.Equations[i].Units.f
  end
  named_states = OrderedDict{ASCIIString, Float64}()
  coef_states = OrderedDict{ASCIIString, Float64}()
  for (key,val) in ode_model.States
    named_states[key] = val.Value * val.Units.f
    coef_states[key] = val.Units.f
  end
  named_parameters = OrderedDict{ASCIIString, Float64}()
  coef_parameters = OrderedDict{ASCIIString, Float64}()
  for (key,val) in ode_model.Parameters
    named_parameters[key] = val.Value * val.Units.f
    coef_parameters[key] = val.Units.f
  end
  forcings = OrderedDict{ASCIIString,Any}()
  coef_forcings = OrderedDict{ASCIIString,Float64}()
  c = 0
  for (key,value) in ode_model.Forcings
      c += 1
      forcings[key] = (float(value.Time), float(value.Value)*value.Units.f)
      coef_forcings[key] = value.Units.f
  end

  # Write a file with the default inputs for the model in JSON format
  write_inputs!(named_states,coef_states, named_parameters, coef_parameters,
               forcings, coef_forcings, ode_model.NamesObserved,coef_observed,
               file)

  # Sort the equations of the model
  sorted_model = OdeSorted(ode_model)

  # Check the physical dimensions of the equations in the model (if demanded)
  unit_analysis &&  check_units(sorted_model)

  # Generate the rhs function (includes observed variables)
  # If DynamicType = DAE generate semiexplicit representation of dae model
  if (sorted_model.DynamicType == "ODE")
    model_function = create_derivatives(language, sorted_model, name)
  elseif (sorted_model.DynamicType == "DAE")
    model_function = create_dae(language, sorted_model, name)
  else
    error("DynamicType should \"ode\" or \"dae\"")
  end

  # Compute jacobian and/or sensitivity functions
  if (jacobian || sensitivities)
    if(sorted_model.DynamicType == "dae") error("Jacobians or sensitivity functions for DAE models has not been implemented yet.") end
    # If we want to obtain an analytical jacobian or the extended system with sensitivities
    # we need to generate a version of the model without intermediate variables
    compressed_model =
          compress_model(deepcopy(sorted_model), level = 2)

    # Generate the function to calculate the Jacobian
    if (jacobian)
      jacobian_function = create_jacobian(language, compressed_model, sorted_model.NamesDerivatives, name)
    end

    if (sensitivities)
      # Generate the function to calculate the analytical sensitivity functions
      extended_function, extended_model = create_extended(language, compressed_model, sorted_model.NamesDerivatives, name)

      # Generate the function to calculate the analytical sensitivity functions
      if (jacobian)
        extended_jacobian_function = create_extended_jacobian(language, extended_model, sorted_model.NamesDerivatives, name)
      else
        extended_jacobian_function = "";
      end
    else
      extended_function = "";
      extended_jacobian_function = "";
    end

  else
    jacobian_function = ""
    extended_function = "";
    extended_jacobian_function = "";
  end

  # Write down the code!
  write_code!(language, ode_model.DynamicType, model_function, jacobian_function, extended_function, extended_jacobian_function, name, file)

  nothing

end


############################ WRITE TIME DERIVATIVES ################################

# This function writes the source for calculating the time derivatives and observed variables
# and it dispatches the correct function depending on the language argument
function create_derivatives(language, sorted_model, name)

  if (language == "julia")
    return create_derivatives_julia(language, sorted_model, name)
  elseif (language == "r")
    return create_derivatives_r(language, sorted_model, name)
  elseif (language == "c")
    return create_derivatives_c(language, sorted_model, name)
  elseif (language == "fortran")
    return create_derivatives_fortran(language, sorted_model, name)
  elseif (language == "cpp")
    return create_derivatives_rcpp(language, sorted_model, name)
  elseif (language == "python")
    return create_derivatives_python(language, sorted_model, name)
  elseif (language == "matlab")
    return create_derivatives_matlab(language, sorted_model, name)
  elseif (language == "java")
    return create_derivatives_java(language, sorted_model, name)
  end

end

################################# WRITE JACOBIAN ###################################

# This function writes the source for calculating the time derivatives and observed variables
# and it dispatches the correct function depending on the language argument
function create_jacobian(language, compressed_model, names_derivatives, name)
  jacobian_matrix = generate_jacobian_matrix(compressed_model)
  if (language == "julia")
    return create_jacobian_julia(language, compressed_model, jacobian_matrix, names_derivatives, name)
  elseif (language == "r")
    return create_jacobian_r(language, compressed_model, jacobian_matrix, names_derivatives, name)
  elseif (language == "c")
    return create_jacobian_c(language, compressed_model, jacobian_matrix, names_derivatives, name)
  elseif (language == "fortran")
    return create_jacobian_fortran(language, compressed_model, jacobian_matrix, names_derivatives, name)
  elseif (language == "cpp")
    return create_jacobian_rcpp(language, compressed_model, jacobian_matrix, names_derivatives, name)
  elseif (language == "python")
    return create_jacobian_python(language, compressed_model, jacobian_matrix, names_derivatives, name)
  elseif (language == "matlab")
    return create_jacobian_matlab(language, compressed_model, jacobian_matrix, names_derivatives, name)
  elseif (language == "java")
    return create_jacobian_java(language, compressed_model, jacobian_matrix, names_derivatives, name)
  end

end

############################ WRITE EXTENDED SYSTEM ################################

# This function writes the source for calculating the time derivatives and observed variables
# and it dispatches the correct function depending on the language argument
function create_extended(language, compressed_model, names_derivatives, name)

  if (language == "julia")
    return create_extended_julia(language, compressed_model, names_derivatives, name)
  elseif (language == "r")
    return create_extended_r(language, compressed_model, names_derivatives, name)
  elseif (language == "c")
    return create_extended_c(language, compressed_model, names_derivatives, name)
  elseif (language == "fortran")
    return create_extended_fortran(language, compressed_model, names_derivatives, name)
  elseif (language == "cpp")
    return create_extended_rcpp(language, compressed_model, names_derivatives, name)
  elseif (language == "python")
    return create_extended_python(language, compressed_model, names_derivatives, name)
  elseif (language == "matlab")
    return create_extended_matlab(language, compressed_model, names_derivatives, name)
  elseif (language == "java")
    return create_extended_java(language, compressed_model, names_derivatives, name)
  end

end

####################### WRITE EXTENDED SYSTEM JACOBIAN #############################

# This function writes the source for calculating the time derivatives and observed variables
# and it dispatches the correct function depending on the language argument
function create_extended_jacobian(language, extended_model, names_derivatives, name)

  if (language == "julia")
    return create_extended_jacobian_julia(language, extended_model, names_derivatives, name)
  elseif (language == "r")
    return create_extended_jacobian_r(language, extended_model, names_derivatives, name)
  elseif (language == "c")
    return create_extended_jacobian_c(language, extended_model, names_derivatives, name)
  elseif (language == "fortran")
    return create_extended_jacobian_fortran(language, extended_model, names_derivatives, name)
  elseif (language == "cpp")
    return create_extended_jacobian_rcpp(language, extended_model, names_derivatives, name)
  elseif (language == "python")
    return create_extended_jacobian_python(language, extended_model, names_derivatives, name)
  elseif (language == "matlab")
    return create_extended_jacobian_matlab(language, extended_model, names_derivatives, name)
  elseif (language == "java")
    return create_extended_jacobian_java(language, extended_model, names_derivatives, name)
  end

end


############################ WRITE SEMIEXPLICT DAE ################################

# This function writes the source for calculating the time derivatives and observed variables
# and it dispatches the correct function depending on the language argument
function create_dae()

  if (language == "julia")
    return create_dae_julia(language, sorted_model, name)
  elseif (language == "r")
    return create_dae_r(language, sorted_model, name)
  elseif (language == "c")
    return create_dae_c(language, sorted_model, name)
  elseif (language == "fortran")
    return create_dae_fortran(language, sorted_model, name)
  elseif (language == "cpp")
    return create_dae_rcpp(language, sorted_model, name)
  elseif (language == "python")
    return create_dae_python(language, sorted_model, name)
  elseif (language == "matlab")
    return create_dae_matlab(language, sorted_model, name)
  elseif (language == "java")
    return create_dae_java(language, sorted_model, name)
  end

end

############################### WRITE CODE FILES ###################################

# Write a JSON file with all the inputs of the model.
# This should be readable in every language
function write_inputs!(named_states,coef_states, named_parameters, coef_parameters,
                       forcings, coef_forcings, observed,coef_observed,
                       file)
  f = open("$(file)_inputs.json","w")
  inputs = {"states" => named_states,
            "coef_states" => coef_states,
            "parameters" => named_parameters,
            "coef_parameters" => coef_parameters,
            "forcings" => forcings,
            "coef_forcings" => coef_forcings,
            "observed" => observed,
            "coef_observed" => coef_observed}
  JSON.print(f, inputs)
  close(f)
end

# Write a source file with all the functions associated to the model in the target language
function write_code!(language, dynamic_type, model_function, jacobian_function, extended_function, extended_jacobian_function, name, file)

  if (language == "julia")
    return write_code_julia!(dynamic_type, model_function, jacobian_function, extended_function, extended_jacobian_function, name, file)
  elseif (language == "r")
    return write_code_r!(dynamic_type, model_function, jacobian_function, extended_function, extended_jacobian_function, name, file)
  elseif (language == "c")
    return write_code_c!(dynamic_type, model_function, jacobian_function, extended_function, extended_jacobian_function, name, file)
  elseif (language == "fortran")
    return write_code_fortran!(dynamic_type, model_function, jacobian_function, extended_function, extended_jacobian_function, name, file)
  elseif (language == "cpp")
    return write_code_rcpp!(dynamic_type, model_function, jacobian_function, extended_function, extended_jacobian_function, name, file)
  elseif (language == "python")
    return write_code_python!(dynamic_type, model_function, jacobian_function, extended_function, extended_jacobian_function, name, file)
  elseif (language == "matlab")
    return write_code_matlab!(dynamic_type, model_function, jacobian_function, extended_function, extended_jacobian_function, name, file)
  elseif (language == "java")
    return write_code_java!(dynamic_type, model_function, jacobian_function, extended_function, extended_jacobian_function, name, file)
  end

end
