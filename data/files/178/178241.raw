####################################################################################
####################################################################################
#######################   BASIC JULIA CODE GENERATION ##############################
####################################################################################
####################################################################################

# Create a return line when the output is a tuple of 2 arrays
function create_return_line_julia(states, observed) 
    return_line = "(["
    for i in states
      if i != states[end]
        return_line = return_line  * i * "," 
      else
        return_line = return_line  * i
      end
    end
    return_line = return_line * "], ["
    for i in observed
      if i != observed[end]
        return_line = return_line * i * ", " 
      else 
        return_line = return_line  * i
      end
    end    
    return_line = return_line * "])"
end

# Create the function in Julia on the Equations section of the model Dict
function create_function_julia!(model::OdeSorted, observed, name)
  code = ""
  for level in 1:length(model.SortedEquations)
    for (lhs, rhs) in model.SortedEquations[level] 
        if level == 1
            code *= string(rhs.Expr) * "\n"
        else
                code *= lhs * " = " * string(rhs.Expr) * "\n"   
        end
    end
  end
  # Determine what the time derivatives are
  time_derivatives = String[]
  for i in collect(keys(model.States))
    push!(time_derivatives, "d_"*i*"_dt")
  end
  # Return line
  return_line = create_return_line_julia(time_derivatives,observed)
  # Return the output   
  code = replace(code, "1.0 *", "")   
  return  paste("\n","@inbounds function $name(time::Float64, states::Array{Float64,1}, params::Array{Float64,1}, forcs::Array{Float64,1})\n", code, return_line,"end")
end

function generate_code!(ode_model::OdeSource,name = "autogenerated_model", file = "autogenerated_model")

  # Generate the observed variables (everything that is exported but it is not a time derivative)
  observed = String[]
  for (key,val) in ode_model.Equations
    val.Exported && push!(observed, key)
  end
  names_derivatives = collect(keys(ode_model.States))
  for i in 1:length(names_derivatives)
    names_derivatives[i] = "d_"*names_derivatives[i]*"_dt"
  end
  deleteat!(observed, findin(observed, names_derivatives))

  # Sort the equations
  sorted_model = sort_equations(ode_model);

  # Generate the rhs function
  model_function = create_function_julia!(sorted_model,observed,name)

  # Create the default arguments
  named_states = OrderedDict{String, Any}()
  for (key,val) in sorted_model.States
    named_states[key] = val.Value * val.Units.f
  end
  named_parameters = OrderedDict{String, Any}()
  for (key,val) in sorted_model.Parameters
    named_parameters[key] = val.Value * val.Units.f
  end  
  forcings = OrderedDict{String,Any}()
  c = 0
  for (key,value) in sorted_model.Forcings
      c += 1
      forcings[key] = (float(value.Time), float(value.Value)*value.Units.f)
  end
  write_model_Julia!(named_states,named_parameters, forcings, observed,
                  model_function, name, file)
  nothing
end

function write_model_Julia!(States::OrderedDict{String, Any},
                            Parameters::OrderedDict{String, Any},
                            Forcings::OrderedDict{String, Any},
                            Observed::Array{String, 1},
                            Model::String,
                            name::String,
                            file::String)
    f = open("$(file).jl","w")
    println(f, "import ODEDSL")
    println(f, "using DataStructures")
    println(f, "function generate_$name()")
    println(f, "States = OrderedDict{String, Any}()")
    for (key,val) in States
      println(f, "States[\"$key\"] = $val")
    end
    println(f, "Parameters = OrderedDict{String, Any}()")
    for (key,val) in Parameters
      println(f, "Parameters[\"$key\"] = $val")
    end    
        println(f, "Forcings = OrderedDict{String, Any}()")
    for (key,val) in Forcings
      println(f, "Forcings[\"$key\"] = $val")
    end    
    println(f, "Observed = $Observed")
    println(f, "$Model")
    println(f, "ODEDSL.DataTypes.OdeModel(States, Parameters, Forcings, Observed, $name)")
    println(f, "end")
    close(f)
    nothing
end
