# Elio liquido dentro un confinamento armonico, con VMC. Il resto del modulo sono funioni generali che poi si applicano a quella cosa
module mc
import Roots
using Debug
# un iteratore è un qualsiasi tipo che abbia definiti i metodi start, next e done

# Un iteratore che campiona usando metropolis. Lo si inizializza con la distribuzione da campionare e lui produce uno alla volta i campioni
# si potrebbe aggiungere un campo per la lunghezza di correlazione così dico a next di tirare fuori solo punti scorrelati
type MarkovChain{T}
    value::T
    delta::Float64
    p::Function
    accepted::Int # ci mettiamo anche un campo che conta quelli proposti?
    steps::Int
    prop::T
end

function Base.display(chain::MarkovChain)
    println("Datatype:\t$(typeof(chain.value))")
    println("Delta:   \t$(chain.delta)")
    println("Distrib: \t$(chain.p)")
    println("Accepted:\t$(chain.accepted)")
    println("Length:  \t$(chain.steps)")
    println("Ratio:   \t$(chain.accepted/chain.steps)")
end

# Un costruttore comodo con dei valori di default sensati
MarkovChain(;init=0.0, delta=1.0, p=gauss, steps=100000) = MarkovChain{typeof(init)}(init, delta, p, 0, steps, deepcopy(init))

# state inizia da 1 ed è un intero, conta quanta roba ho prodotto
Base.start(chain::MarkovChain) = 1

# next deve restituire il valore dell'iteratore ed il prossimo stato (che è un intero)
function Base.next(chain::MarkovChain{Float64}, state::Int)
    proposal = chain.value + chain.delta*(rand() - 0.5)
    w        = chain.p(proposal)/chain.p(chain.value)
    if w >= 1 || w > rand() # se è più probabile starci lo accetto, altrimenti uniforme
        chain.accepted += 1
        chain.value = proposal
    else # se ho rifutato rimango dove sono
        chain.value = chain.value
    end
    return chain.value, state+1
end

# metodo per gestire configurazioni a molte particelle
function Base.next{T<:Array}(chain::MarkovChain{T}, state::Int)
    # la configurazione va generata tutta insieme, non una particella alla volta
    for i in 1:length(chain.value)
        rand!(chain.prop[i])
        for j in 1:length(chain.prop[i])
            chain.prop[i][j] = chain.value[i][j] + chain.delta*(chain.prop[i][j] - 0.5) 
        end
    end
    w = chain.p(chain.prop)/chain.p(chain.value)
    if w >= 1 || w > rand() # se è più probabile starci lo accetto, altrimenti uniforme
        chain.accepted += 1
        for i in 1:length(chain.value)
            for j in 1:length(chain.value[i])
                chain.value[i][j] = chain.prop[i][j] 
            end
        end
        #= chain.value = deepcopy(chain.prop) # è lento FIXME =#
    else # se ho rifutato rimango dove sono
        chain.value = chain.value
    end
    return chain.value, state+1
end

# definendo questo metodo posso fare le comprehensions
Base.length(chain::MarkovChain) = chain.steps

# in questo modo i cicli sono 'for val in catena' e sanno quando fermarsi  
Base.done(chain::MarkovChain, state) = state > chain.steps

function gauss(x)
    # variabile gaussiana standard, è il default per MarkovChain.p
    return exp(-dot(x,x)/2)
end

function gauss{T<:Array}(x::T)
    return exp(-sum(map(y->dot(y,y), x)))
end

function regola_acc_rate!(target_rate::Float64, catena::MarkovChain)
    # aggiusta delta in place finché accepted/steps non fa target_rate
    old_steps = catena.steps
    function acceptance_rate(delta::Float64)
        catena.accepted = 0
        catena.steps = 1000
        catena.delta = delta
        for val in catena # è vuoto perchè deve solo produrre i valori e non farci niente
        end
        return catena.accepted/catena.steps - target_rate
    end
    catena.delta    = Roots.fzero(acceptance_rate, 1e-4, 20.0) # lentissimo FIXME
    catena.accepted = 0
    catena.steps    = old_steps
    return catena.delta
end

function monte_carlo(stimatori, catena::MarkovChain)
    # gli passo un dizionario di funzioni da integrare con la catena e lui restituisce
    # un dizionario di risultati numerici con le stesse chiavi
    integrali = [nome => 0.0 for nome in keys(stimatori)]
    count = 0
    for val in catena
        count += 1
        print("Integrazione: $count/$(catena.steps)\r")
        for (nome,funzione) in stimatori
            integrali[nome] += funzione(val)
        end
    end
    for (nome,somma) in integrali
        integrali[nome] = somma/catena.steps
    end
    return integrali 
end

function gradiente(f, p, a, da, catena)
    # fa il gradiente con il ripesamento del funzionale ∫f⋅p valutato in a±da
    #= return (E(a+da) - E(a-da))/2da =#
    fd(x)    = f(x,a+da)*p(x,a+da)/p(x,a)
    wd(x)    = p(x,a+da)/p(x,a)
    fs(x)    = f(x, a+da)*p(x,a-da)/p(x,a)
    ws(x)    = p(x,a-da)/p(x,a)
    stimatori = ["Peso a-da"=>ws, "Peso a+da"=>wd, "Integr. a+da"=>fd, "Integr. a-da"=>fs]
    res =  monte_carlo(stimatori, catena)
    return (res["Integr. a+da"]/res["Peso a+da"] - res["Integr. a-da"]/res["Peso a-da"])/2da  
end


function sq(x)
    # gli dai un array di 3vettori e lui fa ∑rᵢ²
    sum::Float64 = 0.0
    for i in 1:length(x)
        for j in 1:length(x[i])
            sum += x[i][j]*x[i][j]
        end
    end
    return sum
end


# Oscillatore armonico 3D, il risultato deve essere (1.5,1.5,1.0,3.0)
# le unità sono ħ ω / 2, sqrt(ħ / m ω )   
#= a = 1.0 =#
#= p(x) = exp(-sq(x)/a) =#
#=  =#
#= en_kin(x) = (-sq(x)+3a*particles)/a^2   # en. cinetica locale =#
#= en_pot(x) = sq(x)                       # en. potenziale =#
#= en_loc(x) = en_kin(x)+en_pot(x)         # en. locale, in queste unità deve fare 3*particles =#
#= stimatori = ["En. cinetica"=>en_kin, "En. potenziale"=>en_pot, "En. locale"=>en_loc] =#
#=  =#
#= particles = 10 =#
#= # La configurazione è una tupla di array lunghi 3 =#
#= catena = MarkovChain(init = [zeros(3) for i in 1:particles], steps=1000000, p=p) =#
#= regola_acc_rate!(0.5, catena) =#
#=  =#
#= risultati = monte_carlo(stimatori, catena) =#

##################################################
# particelle interagenti LJ in una buca armonica #
# le unità sono ɛ = ħ Ω / 2, σ = sqrt(ħ / m Ω )  # 
##################################################
u(r)   = (b/r)^5
du(r)  = -5*b^5/r^6
d2u(r) = 30*b^5/r^7

# tutto in SI
hbar    = 1.0546e-34              # J s
mass    = 6.6465e-27              # kg
sigma   = 2.556e-10               # m
epsilon = 10.4*1.38e-23           # J
omega   = 1e+9                    # 1/s se è piccola la buca è larga e non interagiscono
aho     = sqrt(hbar/(mass*omega)) # m
eho     = hbar*omega/2            # J
# parametri del lennard jones in unità dell'oscillatore armonico
ep = epsilon/eho
si = sigma/aho

function lj(x,y) # le posizioni devono essere in unità ho
    return 4*ep*((si/norm(x-y))^12-(si/norm(x-y))^6)
end
lj(x) = lj(x,0) 

# Energia locale con funzione trial gaussiana e jastrow
^(x::Array, n::Integer) = dot(x,x) # i also like to live dangerously
function en_kin(x)
    en::Float64 = 0
    for l in 1:length(x)
        en += (x[l]^2 - 3*a)/a^2 
        for i in 1:l-1 
            dist = norm(x[i]-x[l])
            en += -d2u(dist)-2*du(dist)/dist 
        end
        if l>1
            en += (sum([du(norm(x[i]-x[l]))*(x[i]-x[l])/norm(x[i]-x[l]) for i in 1:l-1]))^2
            en += -2/a * dot(x[l],sum([du(norm(x[i]-x[l]))*(x[i]-x[l])/norm(x[i]-x[l]) for i in 1:l-1]))
        end
    end
    return -en
end

function en_pot(x)
    en = sq(x)
    for i in 1:length(x)
        for j in 1:i-1
            en+=lj(x[i],x[j])
        end
    end
    return en
end

psi(x) = exp(-sq(x)/a)

function phi(x)
    jas = 1.0
    for i in 1:length(x)
        for j in 1:i-i
            jas *= exp(-(b/norm(x[i]-x[j]))^5)
        end
    end
    return jas
end

a = 1.0
b = 1e-2*si # deve essere più o meno la larghezza del core delle particelle
p(x) = psi(x)*phi(x)

stimatori = ["En. cinetica"=>en_kin, "En.Potenziale"=>en_pot]

particles = 30
# La configurazione è una tupla di array lunghi 3
x = [zeros(3) for i in 1:particles]
catena = MarkovChain(init = [zeros(3) for i in 1:particles], steps=10000, p=p)
regola_acc_rate!(0.5, catena)

risultati = monte_carlo(stimatori, catena)
display(risultati)
print(sum(values(risultati)))

#= function e(a) =#
#=     # calcola l'energia di ho 3d in unita hw/2 col parametro variazionale a =#
#=     p(x)      = exp(-sq(x)/a) =#
#=     en_loc(x) = (-sq(x)+3a*particles)/a^2 + sq(x) =#
#=     stimatori = ["en. locale"=>en_loc] =#
#=     catena    = markovchain(init = [zeros(3) for i in 1:particles], steps=1000000, p=p) =#
#=     regola_acc_rate!(0.5, catena) =#
#=     println("a = $(round(a,3))\tdelta = $(round(catena.delta, 2))") =#
#=     return  monte_carlo(stimatori, catena)["en. locale"] =#
#= end =#
# calcolo le energie per alcuni valori del parametro, per farmi un'idea di dove sta il minimo
#= as      = linspace(0.7, 1.3, 64) =#
#= energie = map(e, as) =#
#= using pyplot =#
#= plot(as, energie, linestyle="-", marker="") =#

function minimizza_energia_braveness(a_iniz, braveness, da, tolerance)
    # per l'oscillatore armonico 3d
    a = a_iniz
    while true
        en_loc(x,a) = (-sq(x)+3a*particles)/a^2 + sq(x)
        pstimatori(x,a)      = exp(-sq(x)/a)
        distr(x)    = p(x,a)
        catena = markovchain(init=[zeros(3) for i in 1:particles], steps=1000000, p=distr)
        regola_acc_rate!(0.5, catena)
        grad        = gradiente(en_loc, p, a, da, catena)
        print("\r a = $(round(a, 5)) \t grad = $(round(grad, 5))")
        if norm(grad)<tolerance
            break
        else
            a = a - grad*braveness
            println(" --> \ta_new = $(round(a, 5))")
        end
    end
    println("")
    return a
end
#= minimizza_energia_braveness(0.9, 0.02, 1e-6, 1e-3) =#

end # fine modulo








