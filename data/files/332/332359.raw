N = 14
NUM_FUNCTIONS = 14
#K_VALS = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
K_VALS = [0, 1, 2, 3]
Q = 2
A = 2

max_map_value = NUM_FUNCTIONS * (Q-1)
TARGET_PHENOTYPES = [Int(max_map_value / 2)]
NUM_MAPS = 100

function convert_to_int(vals::Array{Int, 1})
    return_int = 0
    for i = 1:length(vals)
        return_int += vals[i] * (A^(i-1))
    end
    return return_int
end

function evaluate(W::Array{Int32, 2}, function_indeces, neighbours::Array{Int, 2}, w::Array{Int, 1}, K)
    return_int = 0
    for i = 1:length(w)
        if function_indeces[i] != 0
            index = w[i] + 1
            for j = 1:K
                index += w[neighbours[i, j]] * (A^j)
            end
            #println(w)
            #println(index)
            #return_int += W[function_indeces[i], index]
            return_int += W[i, index]
        end
    end
    return return_int
end

function robustness(N, K, Q, A, neighbours, W, function_indeces, w)
    returned_robustness = 0
    parent_genotype = evaluate(W, function_indeces, neighbours, w, K)
    for i = 1:N
        for j = 0:(A - 1)
            if w[i] != j
                w_copy = zeros(Int, N)
                for h = 1:length(w)
                    w_copy[h] = w[h]
                end
                w_copy[i] = j
                #w_copy[i] = j
                if evaluate(W, function_indeces, neighbours, w_copy, K) == parent_genotype
                    returned_robustness += 1
                end
                w_copy[i] = w[i]
            end
        end
    end
    return returned_robustness
end

x = []
y = []
degrees = []
vertices = Dict{Array{Int, 1}, Int}()
f = open(string("nk_output2"), "w")

function sample(N, K, Q, A, neighbours, W, function_indeces, specified_genotype, w, depth)
    #println("vert ", length(vertices))
    #println(evaluate(W, function_indeces, neighbours, w, K))
    parent_robustness = vertices[w]

    if length(vertices) > 8000
         return false
        println("overflow")
    end

    samplings = 0
    ouches = 0
    for j = 1:N
        for k = 0:(A - 1)
            if w[j] != k
                #for l = (j + 1):N
                #for m = 0:(A - 1)
                #if w[l] != m
                w_copy = zeros(Int, N)
                for i = 1:length(w)
                    w_copy[i] = w[i]
                end
                w_copy[j] = k
                
                #w_copy[l] = m
                if evaluate(W, function_indeces, neighbours, w_copy, K) == specified_genotype
                    #println("child ", robustness(N, K, Q, A, neighbours, W, function_indeces, w_copy))
                    if w_copy in keys(vertices)
                        push!(x, parent_robustness)
                        push!(y, vertices[w_copy])
                        ouches += 1
                    else
                        neighbour_robustness = robustness(N, K, Q, A, neighbours, W, function_indeces, w_copy)
                        push!(degrees, neighbour_robustness)
                        vertices[w_copy] = neighbour_robustness
                        push!(x, parent_robustness)
                        push!(y, neighbour_robustness)
                        samplings += 1
                        foo = zeros(Int, N)
                        for i = 1:length(w)
                            foo[i] = w[i]
                        end
                        foo[j] = k
                        sample(N, K, Q, A, neighbours, W, function_indeces, specified_genotype, foo, depth + 1)
                        samplings += 1
                    end
                    if length(vertices) > 8000
                        println("overflow")
                        return false
                    end
                end
                #end
                #end
                #end
            end
        end
    end
    done = false
    if depth == 0
        println(length(vertices))
        if length(vertices) > 100
            done = true
            if K == 0
                r = 1
            else
                r = cor(x, y)
            end
            mean_degrees = mean(degrees)
            mean_squares = mean(degrees.^2)
            mean_cubes = mean(degrees.^3)
            mean_quartics = mean(degrees.^3)
            #println("r ", r)
            write(f, string(r, "\n"))
            #println("mean degrees ", mean_degrees)
            write(f, string(mean_degrees, "\n"))
            #println("variance degrees ", mean_squares - (mean_degrees)^2)
            write(f, string(mean_squares - (mean_degrees)^2, "\n"))
            #println("variance edges ", (mean_cubes)/(mean_degrees) - ((mean_squares^2)/(mean_degrees^2)))
            write(f, string((mean_cubes)/(mean_degrees) - ((mean_squares^2)/(mean_degrees^2)), "\n"))
        else
            println("not enough")
        end
    end
    return done
end



correlations = zeros(Float64, length(K_VALS), length(TARGET_PHENOTYPES), NUM_MAPS)

for a = 1:length(K_VALS)
    K = K_VALS[a]
    for m = 1:NUM_MAPS
        println("K ", K)
        println("Map ", m)
        neighbours = zeros(Int, N, K)
        for i = 1:N
            for j = 1:K
                found = false
                new_neighbour = 0
                while !found
                    found = true
                    new_neighbour = rand(Int(1):Int(N))
                    for k = 1:K
                        if (new_neighbour == neighbours[i, k]) | (new_neighbour == i)
                            found = false
                        end 
                    end
                end
                neighbours[i, j] = new_neighbour
            end
        end
        #println(neighbours[1, :])
        done = false
        while !done
            vertices = Dict{Array{Int, 1}, Int}()
            function_indeces = zeros(Int, N)
            for i = 1:NUM_FUNCTIONS
                index = rand(1:N)
                while function_indeces[index] != 0
                    index = rand(1:N)
                end
                function_indeces[index] = i
            end
            W = rand(Int32(0):Int32(Q - 1), NUM_FUNCTIONS, A^(K + 1))
            for l = 1:length(TARGET_PHENOTYPES)
                #println(K, " ", l, " foo")
                #println(TARGET_PHENOTYPES[l])
                #println(sample(N, K, Q, A, neighbours, W, TARGET_PHENOTYPES[l]))
                w = rand(0:(A - 1), N)
                #println("hoo")
                hoop = 0
                while evaluate(W, function_indeces, neighbours, w, K) != TARGET_PHENOTYPES[l]
                    #println(evaluate(W, function_indeces, neighbours, w, K))
                    #println(specified_genotype)
                    w = rand(0:(A - 1), N)
                    hoop += 1
                    if hoop > 10000
                        break
                    end
                end
                #println("chou")
                initial_robustness = robustness(N, K, Q, A, neighbours, W, function_indeces, w)
                push!(degrees, initial_robustness)
                vertices[w] = initial_robustness
                #correlations[a, l, m] = sample(N, K, Q, A, neighbours, W, TARGET_PHENOTYPES[l], w)
                done = sample(N, K, Q, A, neighbours, W, function_indeces, TARGET_PHENOTYPES[l], w, 0)
            end
        end
    end
end

# for p = 1:length(TARGET_PHENOTYPES)
#     for k = 1:length(K_VALS)
#         for m = 1:NUM_MAPS
#             write(f, string(correlations[k, p, m]))
#             write(f, " ")
#         end
#         write(f, "\n")
#     end
# end
