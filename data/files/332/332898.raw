include("config.jl")

module Genotype
using Config


type Type_Genotype
    num_nodes::Int32
    used_connections::Array{Int32, 1}
    connections::Array{Int32, 1}
    activations::Array{Int32, 1}
    weights::Array{Int32, 1}
    thresholds::Array{Int32, 1}
    fitness::Float32
    marked_for_removal::Bool
    parents_connections::Array{Int32, 1}
    parents_activations::Array{Int32, 1}
    parents_weights::Array{Int32, 1}
    parents_thresholds::Array{Int32, 1}
    parents_fitness::Float32

    fitness_target_1::Float32
    fitness_target_2::Float32
end

function write_to_file(genotype::Type_Genotype, config_vals::Config.Type_Config_Values)

    non_arrays_file = open("saved_genotype/non_arrays", "w")
    write(non_arrays_file, dec(genotype.num_nodes), "\n")
    write(non_arrays_file, string(genotype.fitness), "\n")
    close(non_arrays_file)
    
    writecsv("saved_genotype/used_connections", genotype.used_connections)
    writecsv("saved_genotype/connections", genotype.connections)
    writecsv("saved_genotype/activations", genotype.activations)
    writecsv("saved_genotype/weights", genotype.weights)
    writecsv("saved_genotype/thresholds", genotype.thresholds)

end

function read_from_file(config_vals::Config.Type_Config_Values)

    non_arrays_file = open("saved_genotype/non_arrays")
    num_nodes::Int32 = parse(Int32, readline(non_arrays_file))
    fitness::Float32 = parse(Float32, readline(non_arrays_file))
    close(non_arrays_file)
    
    used_connections::Array{Int32, 1} = vec(readcsv("saved_genotype/used_connections"))
    connections::Array{Int32, 1} = vec(readcsv("saved_genotype/connections"))
    activations::Array{Int32, 1} = vec(readcsv("saved_genotype/activations"))
    weights::Array{Int32, 1} = vec(readcsv("saved_genotype/weights"))
    thresholds::Array{Int32, 1} = vec(readcsv("saved_genotype/thresholds"))

    parents_connections::Array{Int32, 1} = zeros(Int32, config_vals.max_num_nodes * config_vals.max_num_connections)
    parents_weights::Array{Int32, 1} = zeros(Int32, config_vals.max_num_nodes * config_vals.max_num_connections)
    parents_activations::Array{Int32, 1} = zeros(Int32, config_vals.max_num_nodes * (config_vals.GRN_timesteps + 1))
    parents_thresholds::Array{Int32, 1} = zeros(Int32, config_vals.max_num_nodes)

    return Type_Genotype(num_nodes, used_connections, connections, activations, weights, thresholds,
                         -1.0, false, parents_connections, parents_activations, 
                         parents_weights, parents_thresholds, convert(Float32, 0), convert(Float32, 0), convert(Float32, 0))    

end

function copy_into(target::Type_Genotype, source::Type_Genotype)

    target.num_nodes = source.num_nodes
    for i = 1:length(target.used_connections)
        target.used_connections[i] = source.used_connections[i]
    end
    for i = 1:length(target.connections)
        target.connections[i] = source.connections[i]
    end
    for i = 1:length(target.activations)
        target.activations[i] = source.activations[i]
    end
    for i = 1:length(target.weights)
        target.weights[i] = source.weights[i]
    end
    for i = 1:length(target.thresholds)
        target.thresholds[i] = source.thresholds[i]
    end
    target.fitness = source.fitness
    target.fitness_target_1 = source.fitness_target_1
    target.fitness_target_2 = source.fitness_target_2
    target.parents_fitness = source.parents_fitness
    target.marked_for_removal = source.marked_for_removal

    for i = 1:length(target.parents_connections)
        target.parents_connections[i] = source.parents_connections[i]
    end
    for i = 1:length(target.parents_activations)
        target.parents_activations[i] = source.parents_activations[i]
    end
    for i = 1:length(target.parents_weights)
        target.parents_weights[i] = source.parents_weights[i]
    end
    for i = 1:length(target.parents_thresholds)
        target.parents_thresholds[i] = source.parents_thresholds[i]
    end

end

function crossover(config_vals::Config.Type_Config_Values, target::Type_Genotype, parent_1::Type_Genotype, parent_2::Type_Genotype)
#=target.num_nodes = parent_1.num_nodes
    for i = 1:length(target.used_connections)
        if rand(0:1) == 0
            target.used_connections[i] = parent_1.used_connections[i]
        else
            target.used_connections[i] = parent_2.used_connections[i]
        end
    end
    for i = 1:length(target.connections)
        if rand(0:1) == 0
            target.connections[i] = parent_1.connections[i]
        else
            target.connections[i] = parent_2.connections[i]
        end
    end
    for i = 1:length(target.activations)
        if rand(0:1) == 0
            target.activations[i] = parent_1.activations[i]
        else
            target.activations[i] = parent_2.activations[i]
        end
    end
    for i = 1:length(target.weights)
        if rand(0:1) == 0
            target.weights[i] = parent_1.weights[i]
        else
            target.weights[i] = parent_2.weights[i]
        end
    end
    for i = 1:length(target.thresholds)
        if rand(0:1) == 0
            target.thresholds[i] = parent_1.thresholds[i]
        else
            target.thresholds[i] = parent_2.thresholds[i]
        end
    end=#
    #=target.num_nodes = parent_1.num_nodes
    for i = 1:length(target.used_connections)
        if rand(0:1) == 0
            target.used_connections[i] = parent_1.used_connections[i]
        else
            target.used_connections[i] = parent_2.used_connections[i]
        end
    end
    for i = 1:target.num_nodes
        for j = 1:target.used_connections[i]
            if rand(0:1) == 0 
                if parent_1.connections[(i - 1) * config_vals.max_num_connections + j] != 0
                    target.connections[(i - 1) * config_vals.max_num_connections + j] = parent_1.connections[(i - 1) * config_vals.max_num_connections + j]
                    target.weights[(i - 1) * config_vals.max_num_connections + j] = parent_1.weights[(i - 1) * config_vals.max_num_connections + j]
                else
                    target.connections[(i - 1) * config_vals.max_num_connections + j] = parent_2.connections[(i - 1) * config_vals.max_num_connections + j]
                    target.weights[(i - 1) * config_vals.max_num_connections + j] = parent_2.weights[(i - 1) * config_vals.max_num_connections + j]
                end
            else
                if parent_2.connections[(i - 1) * config_vals.max_num_connections + j] != 0
                    target.connections[(i - 1) * config_vals.max_num_connections + j] = parent_2.connections[(i - 1) * config_vals.max_num_connections + j]
                    target.weights[(i - 1) * config_vals.max_num_connections + j] = parent_2.weights[(i - 1) * config_vals.max_num_connections + j]
                else
                    target.connections[(i - 1) * config_vals.max_num_connections + j] = parent_1.connections[(i - 1) * config_vals.max_num_connections + j]
                    target.weights[(i - 1) * config_vals.max_num_connections + j] = parent_1.weights[(i - 1) * config_vals.max_num_connections + j]
                end
            end
        end
        for k = (target.used_connections[i] + 1):config_vals.max_num_connections
            target.connections[(i - 1) * config_vals.max_num_connections + k] = 0
            target.weights[(i - 1) * config_vals.max_num_connections + k] = 0
        end
    end
    for i = 1:length(target.activations)
        if rand(0:1) == 0
            target.activations[i] = parent_1.activations[i]
        else
            target.activations[i] = parent_2.activations[i]
        end
    end
    for i = 1:length(target.thresholds)
        if rand(0:1) == 0
            target.thresholds[i] = parent_1.thresholds[i]
        else
            target.thresholds[i] = parent_2.thresholds[i]
        end
    end=#
    target.num_nodes = parent_1.num_nodes
    for i = 1:target.num_nodes
        if rand(0:1) == 0
            target.weights[(((i - 1) * config_vals.max_num_connections) + 1):(i * config_vals.max_num_connections)] = 
                parent_1.weights[(((i - 1) * config_vals.max_num_connections) + 1):(i * config_vals.max_num_connections)]
            target.connections[(((i - 1) * config_vals.max_num_connections) + 1):(i * config_vals.max_num_connections)] = 
                parent_1.connections[(((i - 1) * config_vals.max_num_connections) + 1):(i * config_vals.max_num_connections)]
            target.activations[i] = parent_1.activations[i]
            target.used_connections[i] = parent_1.used_connections[i]
            target.thresholds[i] = parent_1.thresholds[i]
        else
            target.weights[(((i - 1) * config_vals.max_num_connections) + 1):(i * config_vals.max_num_connections)] = 
                parent_2.weights[(((i - 1) * config_vals.max_num_connections) + 1):(i * config_vals.max_num_connections)]
            target.connections[(((i - 1) * config_vals.max_num_connections) + 1):(i * config_vals.max_num_connections)] = 
                parent_2.connections[(((i - 1) * config_vals.max_num_connections) + 1):(i * config_vals.max_num_connections)]
            target.activations[i] = parent_2.activations[i]
            target.used_connections[i] = parent_2.used_connections[i]
            target.thresholds[i] = parent_2.thresholds[i]
        end
    end

    target.fitness = -1
    target.fitness_target_1 = -1
    target.fitness_target_2 = -1
    target.parents_fitness = -1
    target.marked_for_removal = false

    for i = 1:length(target.parents_connections)
        target.parents_connections[i] = parent_1.parents_connections[i]
    end
    for i = 1:length(target.parents_activations)
        target.parents_activations[i] = parent_1.parents_activations[i]
    end
    for i = 1:length(target.parents_weights)
        target.parents_weights[i] = parent_1.parents_weights[i]
    end
    for i = 1:length(target.parents_thresholds)
        target.parents_thresholds[i] = parent_1.parents_thresholds[i]
    end

end


function make_random_genotype(config_vals::Config.Type_Config_Values)
    num_nodes = config_vals.initial_num_nodes
    used_connections::Array{Int32, 1} = zeros(Int32, config_vals.max_num_nodes)
    connections::Array{Int32, 1} = zeros(Int32, config_vals.max_num_nodes * config_vals.max_num_connections)
    parents_connections::Array{Int32, 1} = zeros(Int32, config_vals.max_num_nodes * config_vals.max_num_connections)
    weights::Array{Int32, 1} = zeros(Int32, config_vals.max_num_nodes * config_vals.max_num_connections)
    parents_weights::Array{Int32, 1} = zeros(Int32, config_vals.max_num_nodes * config_vals.max_num_connections)
    for i = 1:num_nodes
        connections_to_use = rand(config_vals.initial_min_num_connections:config_vals.initial_max_num_connections)
        used_connections[i] = connections_to_use
        start_index = (i - 1) * config_vals.max_num_connections
        for j = 1:connections_to_use
            weight_value = 0
            while weight_value == 0
                weight_value = rand(config_vals.min_weight:config_vals.max_weight)
            end
            weights[start_index + j] = weight_value
            connection_value = 0
            found_connection_value = false
            while !found_connection_value
                connection_value = rand(1:num_nodes)
                found_connection_value = true
                for k = 1:(j - 1)
                    if connection_value == connections[start_index + k]
                        found_connection_value = false
                    end
                end
            end
            connections[start_index + j] = connection_value
        end
    end
    activations::Array{Int32, 1} = zeros(Int32, config_vals.max_num_nodes * (config_vals.GRN_timesteps + 1))
    activations[1] = -1
    parents_activations::Array{Int32, 1} = zeros(Int32, config_vals.max_num_nodes * (config_vals.GRN_timesteps + 1))
    rand!(sub(activations, 1:num_nodes), 0:1)
    thresholds::Array{Int32, 1} = zeros(Int32, config_vals.max_num_nodes)
    parents_thresholds::Array{Int32, 1} = zeros(Int32, config_vals.max_num_nodes)
    rand!(sub(thresholds, 1:num_nodes), config_vals.min_threshold:config_vals.max_threshold)
    return Type_Genotype(num_nodes, used_connections, connections, activations, weights, thresholds,
                         -1.0, false, parents_connections, parents_activations, 
                         parents_weights, parents_thresholds, convert(Float32, 0), convert(Float32, 0), convert(Float32, 0))
end


function randomize_genotype(genotype::Type_Genotype, config_vals::Config.Type_Config_Values)
    fill!(genotype.used_connections, convert(Int32, 0))
    fill!(genotype.connections, convert(Int32, 0))
    fill!(genotype.weights, convert(Int32, 0))
    num_nodes = config_vals.initial_num_nodes
    for i = 1:num_nodes
        connections_to_use = rand(config_vals.initial_min_num_connections:config_vals.initial_max_num_connections)
        genotype.used_connections[i] = connections_to_use
        start_index = (i - 1) * config_vals.max_num_connections
        for j = 1:connections_to_use
            weight_value = 0
            while weight_value == 0
                weight_value = rand(config_vals.min_weight:config_vals.max_weight)
            end
            genotype.weights[start_index + j] = weight_value
            connection_value = 0
            found_connection_value = false
            while !found_connection_value
                connection_value = rand(1:num_nodes)
                found_connection_value = true
                for k = 1:(j - 1)
                    if connection_value == genotype.connections[start_index + k]
                        found_connection_value = false
                    end
                end
            end
            genotype.connections[start_index + j] = connection_value
        end
    end
    rand!(sub(genotype.activations, 1:num_nodes), 0:1)
    rand!(sub(genotype.thresholds, 1:num_nodes), config_vals.min_threshold:config_vals.max_threshold)
    genotype.fitness = -1.0
    return 0
end


import Base
Base.(:(==))(x::Type_Genotype, y::Type_Genotype) = (
                                                    function (x::Type_Genotype, y::Type_Genotype)
                                                    for i = 1:length(x.connections)
                                                    if x.connections[i] != y.connections[i]
                                                    return false
                                                    end
                                                    end
                                                        for i = 1:length(x.weights)
                                                            if x.weights[i] != y.weights[i]
                                                                return false
                                                            end
                                                        end
                                                        for i = 1:length(x.thresholds)
                                                            if x.thresholds[i] != y.thresholds[i]
                                                                return false
                                                            end
                                                        end
                                                        for i = 1:length(x.activations)
                                                            if x.activations[i] != y.activations[i]
                                                                return false
                                                            end
                                                        end
                                                        return true
                                                    end) (x::Type_Genotype, y::Type_Genotype)

Base.hash(genotype::Type_Genotype) = (
                                      function (genotype::Type_Genotype)
                                      hash_code::Int64 = 1
                                      for i = 1:length(genotype.connections)
                                          hash_code += genotype.connections[i] * 2^i
                                      end
                                      for i = 1:length(genotype.activations)
                                          hash_code += genotype.activations[i] * 2^i
                                      end
                                      for i = 1:length(genotype.weights)
                                          hash_code += genotype.weights[i] * 2^i
                                      end
                                      for i = 1:length(genotype.thresholds)
                                          hash_code += genotype.thresholds[i] * 2^i
                                      end
                                      return hash_code
                                      end) (genotype::Type_Genotype)
                                                    

function run_GRN(genotype::Type_Genotype, config_vals::Config.Type_Config_Values, verbose::Int32)
    Libdl.dlopen("/home/david/TehzCodes/GRNEvolution/libboolnet")
    ccall((:run_network, "/home/david/TehzCodes/GRNEvolution/libboolnet"), Void,
          (Int32, Int32, Int32, Int32, Ptr{Int32}, Ptr{Int32}, Ptr{Int32}, Ptr{Int32}, Int32),
          config_vals.GRN_timesteps, genotype.num_nodes,
          config_vals.max_num_nodes, config_vals.max_num_connections,
          genotype.activations,
          genotype.connections, genotype.weights, genotype.thresholds, verbose)
    return 0
end


function evaluate(genotype::Type_Genotype, config_vals::Config.Type_Config_Values, target_expression::Array{Float32, 1},
                  target_expression_1::Array{Float32, 1},target_expression_2::Array{Float32, 1},
                  walls::Array{Float32}, layer_1_weights::Array{Float32}, layer_2_weights::Array{Float32}, 
                  inputs::Array{Float32}, hidden_activations::Array{Float32}, outputs::Array{Float32}, fitness_ref::Array{Float32},
                  target_number::Int32, fitness_vals::Dict{Int64, Float64}, mutation_tracker::Array{Int32, 1}, evaluation_tracker::Array{Int64, 1})
    if genotype.fitness == -1.0
        evaluation_tracker[1] += 1
        genotype.fitness = 0.0
        
        run_GRN(genotype, config_vals, convert(Int32, 0))
        if (genotype.parents_activations[1] != -1) & (!genotype.marked_for_removal)
            hamming_distance = 0
            for i = (config_vals.GRN_timesteps * config_vals.max_num_nodes + 1):((config_vals.GRN_timesteps + 1) * config_vals.max_num_nodes)
                if genotype.activations[i] != genotype.parents_activations[i] 
                    hamming_distance += 1
                end
            end
            mutation_tracker[hamming_distance + 1] += 1
        end
        
        if config_vals.use_sim
            index = activations_to_int(genotype, config_vals)
            fitness = get(fitness_vals, index, -1)
            if fitness == -1
                for i = 1:1
                    objective_type = 0
                    if config_vals.wall_avoidance_objective
                        objective_type = 1
                    end
                    num_walls = 4
                    if config_vals.wall_avoidance_objective
                        if target_number == 1
                            num_walls = 8
                        else
                            num_walls = 5
                        end
                    end
                    Libdl.dlopen("/home/david/TehzCodes/GRNEvolution/librobosim")
                    ccall((:simulate, "/home/david/TehzCodes/GRNEvolution/librobosim"), Void,
                          (Int32, Ptr{Float32}, Int32, Ptr{Float32}, Int32, Ptr{Int32}, Int32, Int32, Int32, 
                           Int32, Ptr{Float32}, Ptr{Float32}, Ptr{Float32}, Ptr{Float32}, Ptr{Float32}, Ptr{Float32}, 
                           Int32, Int32, Int32),
                          config_vals.simulation_iterations, walls, convert(Int32, num_walls), target_expression, 
                          convert(Int32, length(target_expression)/2),
                          genotype.activations[(config_vals.GRN_timesteps * 
                                                config_vals.max_num_nodes + 1):((config_vals.GRN_timesteps + 1) 
                                                                                * config_vals.max_num_nodes)],
                          config_vals.bits_per_weight, config_vals.num_input_nn_nodes, config_vals.num_hidden_nn_nodes, 
                          config_vals.num_output_nn_nodes, layer_1_weights, layer_2_weights, inputs, hidden_activations, 
                          outputs, fitness_ref, target_number, convert(Int32, objective_type), convert(Int32, 0))
                end
                fitness_vals[index] = fitness_ref[1]
                genotype.fitness = fitness_ref[1]
                #println(genotype.fitness)
            else
                genotype.fitness = fitness
            end

        # Bit-string case
        else
            genotype.fitness_target_1 = 0
            genotype.fitness_target_2 = 0
            start_1 = genotype.num_nodes * (config_vals.GRN_timesteps - 1) + 1
            end_1 = start_1 + genotype.num_nodes - 1
            start_2 = genotype.num_nodes * config_vals.GRN_timesteps + 1
            end_2 = start_2 + genotype.num_nodes - 1
            if isequal(sub(genotype.activations, start_1:end_1), sub(genotype.activations, start_2:end_2))
                for i = 1:length(target_expression)
                    if (target_expression[i]) == 2 || (genotype.activations[(config_vals.GRN_timesteps * config_vals.max_num_nodes)  + i] == target_expression[i])
                        genotype.fitness += 1.0
                    end
                end
            end
            if isequal(sub(genotype.activations, start_1:end_1), sub(genotype.activations, start_2:end_2))
                for i = 1:length(target_expression_1)
                    if (target_expression_1[i]) == 2 || (genotype.activations[(config_vals.GRN_timesteps * config_vals.max_num_nodes)  + i] == target_expression_1[i])
                        genotype.fitness_target_1 += 1.0
                    end
                end
            end
            if isequal(sub(genotype.activations, start_1:end_1), sub(genotype.activations, start_2:end_2))
                for i = 1:length(target_expression_2)
                    if (target_expression_2[i]) == 2 || (genotype.activations[(config_vals.GRN_timesteps * config_vals.max_num_nodes)  + i] == target_expression_2[i])
                        genotype.fitness_target_2 += 1.0
                    end
                end
            end
        end
    end

    return 0

end

function evaluate(genotype::Type_Genotype, config_vals::Config.Type_Config_Values, target_expression::Array{Float32, 1})
    if genotype.fitness == -1.0
        start_1 = genotype.num_nodes * (config_vals.GRN_timesteps - 1) + 1
        end_1 = start_1 + genotype.num_nodes - 1
        start_2 = genotype.num_nodes * config_vals.GRN_timesteps + 1
        end_2 = start_2 + genotype.num_nodes - 1
        if isequal(sub(genotype.activations, start_1:end_1), sub(genotype.activations, start_2:end_2))
            for i = 1:length(target_expression)
                if (target_expression[i]) == 2 || (genotype.activations[(config_vals.GRN_timesteps * config_vals.max_num_nodes)  + i] == target_expression[i])
                    genotype.fitness += 1.0
                end
            end
        end

    end

    return 0

end


# Treats the activations as a binary number and produces the corresponding base 10 integer.
function activations_to_int(genotype::Type_Genotype, config_vals::Config.Type_Config_Values)
    integer::Int64 = 0
    for i = 1:config_vals.initial_num_nodes
        integer += genotype.activations[(config_vals.GRN_timesteps * config_vals.max_num_nodes)  + i] * 2^(i - 1)
    end
    integer += 1
    return integer
end


#=
    In this mutation scheme either a mutation or deletion is done. If neither is done then 
    each mutation type occurs with a certain probability.
=#
function mutate(genotype::Type_Genotype, config_vals::Config.Type_Config_Values)

    genotype.parents_fitness = genotype.fitness

    genotype.fitness = -1.0

    for i = 1:length(genotype.parents_connections)
        genotype.parents_connections[i] = genotype.connections[i]
    end
    for i = 1:length(genotype.parents_activations)
        genotype.parents_activations[i] = genotype.activations[i]
    end
    for i = 1:length(genotype.parents_weights)
        genotype.parents_weights[i] = genotype.weights[i]
    end
    for i = 1:length(genotype.parents_thresholds)
        genotype.parents_thresholds[i] = genotype.thresholds[i]
    end

    if rand(1:100) < 100 * config_vals.mutate_dup_del_prob
        if rand(0:1) == 0
            for i = 1:rand(config_vals.min_num_dups_or_dels:config_vals.max_num_dups_or_dels)
                delete_node(genotype, config_vals, convert(Int32, rand(1:genotype.num_nodes)))
            end
        else
            for i = 1:rand(config_vals.min_num_dups_or_dels:config_vals.max_num_dups_or_dels)
                duplicate_node(genotype, config_vals, convert(Int32, rand(1:genotype.num_nodes)))
            end
        end
    else
        if rand(1:100) <= 100 * config_vals.mutate_conn_prob 
            for i = 1:rand(config_vals.min_num_conn_muts:config_vals.max_num_conn_muts)
                node = rand(1:genotype.num_nodes)
                mutate_connection(genotype, config_vals, convert(Int32, node), convert(Int32, rand(1:genotype.used_connections[node])))
            end
        end
        if rand(1:100) <= 100 * config_vals.mutate_activation_prob
            for i = 1:rand(config_vals.min_num_activation_muts:config_vals.max_num_activation_muts)
                mutate_activation(genotype, config_vals, convert(Int32, rand(1:genotype.num_nodes)))
            end
        end
        if rand(1:100) <= 100 * config_vals.delete_conn_prob
            for i = 1:rand(config_vals.min_num_conn_dels:config_vals.max_num_conn_dels)
                node = rand(1:genotype.num_nodes)
                delete_incomming_connection(genotype, config_vals, convert(Int32, node), convert(Int32, rand(1:genotype.used_connections[node])))
            end
        end
        if rand(1:100) <= 100 * config_vals.add_conn_prob
            node::Int32 = rand(1:genotype.num_nodes)
            for i = 1:rand(config_vals.min_num_conn_adds:config_vals.max_num_conn_adds)
                add_incoming_connection(genotype, config_vals, node, convert(Int32, 0))
            end
        end
        if rand(1:100) <= 100 * config_vals.mutate_threshold_prob
            for i = 1:rand(config_vals.min_num_thresh_muts:config_vals.max_num_thresh_muts)
                mutate_threshold(genotype, config_vals, convert(Int32, rand(1:genotype.num_nodes)))
            end
        end
        if rand(1:100) <= 100 * config_vals.mutate_weight_prob
            for i = 1:rand(config_vals.min_num_weight_muts:config_vals.max_num_weight_muts)
                node = rand(1:genotype.num_nodes)
                mutate_weight(genotype, config_vals, convert(Int32, node), convert(Int32, rand(1:genotype.used_connections[node])))
            end
        end
    end
    return 0
end


#=
    In this mutation scheme mutations can occur on every node or edge with a certain
    probability. No duplications or deletions are done. 
=#
function mutate_at_global_rate(genotype::Type_Genotype, config_vals::Config.Type_Config_Values)

    genotype.parents_fitness = genotype.fitness

    genotype.fitness = -1.0

    for i = 1:length(genotype.parents_activations)
        genotype.parents_activations[i] = genotype.activations[i]
    end

    for i = 1:config_vals.max_num_nodes
        for j = 1:genotype.used_connections[i]
            if rand(1:100) <= 100 * config_vals.global_weight_mutation_rate 
                mutate_weight(genotype, config_vals, convert(Int32, i), convert(Int32, j))
            end
        end
    end
    for i = 1:config_vals.max_num_nodes
        if rand(1:100) <= 100 * config_vals.global_mutation_rate 
            mutate_activation(genotype, config_vals, convert(Int32, i))
        end
    end
    for i = 1:config_vals.max_num_nodes
        if rand(1:100) <= 100 * config_vals.global_mutation_rate 
            delete_incomming_connection(genotype, config_vals, convert(Int32, i), convert(Int32, rand(1:genotype.used_connections[i])))
        end
    end
    for i = 1:config_vals.max_num_nodes
        if rand(1:100) <= 100 * config_vals.global_mutation_rate 
            add_incoming_connection(genotype, config_vals, convert(Int32, i), convert(Int32, 0))
        end
    end
    for i = 1:config_vals.max_num_nodes
        if rand(1:100) <= 100 * config_vals.global_mutation_rate 
            #mutate_threshold(genotype, config_vals, convert(Int32, i))
        end
    end
    
    return 0
end

# A single mutation is done.
function point_mutate(genotype::Type_Genotype, config_vals::Config.Type_Config_Values)
    genotype.fitness = -1.0

    # choice = rand(1:5)
    # if choice == 1
    #     node = rand(1:genotype.num_nodes)
    #     mutate_connection(genotype, config_vals, convert(Int32, node), convert(Int32, rand(1:genotype.used_connections[node])))
    # elseif choice == 2
    #     mutate_activation(genotype, config_vals, convert(Int32, rand(1:genotype.num_nodes)))
    # elseif choice == 3
    #     node = rand(1:genotype.num_nodes)
    #     delete_incomming_connection(genotype, config_vals, convert(Int32, node), convert(Int32, rand(1:genotype.used_connections[node])))
    # elseif choice == 4
    #     node::Int32 = rand(1:genotype.num_nodes)
    #     add_incoming_connection(genotype, config_vals, node, convert(Int32, 0))
    # else
    #     node = rand(1:genotype.num_nodes)
    #     mutate_weight(genotype, config_vals, convert(Int32, node), convert(Int32, rand(1:genotype.used_connections[node])))
    # end
    choice = rand(1:4)
    if choice == 1
        node = rand(1:genotype.num_nodes)
        mutate_connection(genotype, config_vals, convert(Int32, node), convert(Int32, rand(1:genotype.used_connections[node])))
    elseif choice == 2
        mutate_activation(genotype, config_vals, convert(Int32, rand(1:genotype.num_nodes)))
    elseif choice == 3
        node = rand(1:genotype.num_nodes)
        delete_incomming_connection(genotype, config_vals, convert(Int32, node), convert(Int32, rand(1:genotype.used_connections[node])))
    else
        node::Int32 = rand(1:genotype.num_nodes)
        add_incoming_connection(genotype, config_vals, node, convert(Int32, 0))
    end
    return 0
end


function move_node(genotype::Type_Genotype, config_vals::Config.Type_Config_Values, from_index::Int32, to_index::Int32)
    from_range_start = ((from_index - 1) * config_vals.max_num_connections) + 1
    from_range_end = ((from_index - 1) * config_vals.max_num_connections) + genotype.used_connections[from_index]
    for i = from_range_start:from_range_end
        genotype.connections[i + ((to_index - from_index) * config_vals.max_num_connections)] = genotype.connections[i]
        genotype.connections[i] = 0
        genotype.weights[i + ((to_index - from_index) * config_vals.max_num_connections)] = genotype.weights[i]
        genotype.weights[i] = 0
    end
    genotype.used_connections[to_index] = genotype.used_connections[from_index]
    genotype.used_connections[from_index] = 0
    genotype.activations[to_index] = genotype.activations[from_index]
    genotype.activations[from_index] = 0
    genotype.thresholds[to_index] = genotype.thresholds[from_index]
    genotype.thresholds[from_index] = 0

    for i = 1:genotype.num_nodes
        for j = 1:genotype.used_connections[i]
            if genotype.connections[(i - 1) * config_vals.max_num_connections + j] == from_index
                genotype.connections[(i - 1) * config_vals.max_num_connections + j] = to_index
            end
        end
    end

    return 0
end


function delete_node(genotype::Type_Genotype, config_vals::Config.Type_Config_Values, index::Int32)
    if genotype.num_nodes > config_vals.min_num_nodes
        for i = 1:genotype.num_nodes
            for j = 1:genotype.used_connections[i]
                if genotype.connections[(i - 1) * config_vals.max_num_connections + j] == index
                    delete_incomming_connection(genotype, config_vals, convert(Int32, i), convert(Int32, j))
                end
            end
        end
        genotype.num_nodes -= 1
        range_start = ((index - 1) * config_vals.max_num_connections) + 1
        range_end = ((index - 1) * config_vals.max_num_connections) + genotype.used_connections[index]
        for i = range_start:range_end
            genotype.connections[i] = 0
            genotype.weights[i] = 0
        end
        genotype.used_connections[index] = 0
        genotype.activations[index] = 0
        genotype.thresholds[index] = 0
        move_node(genotype, config_vals, genotype.num_nodes + convert(Int32, 1), index)
    end
    return 0
end


function duplicate_node(genotype::Type_Genotype, config_vals::Config.Type_Config_Values, index::Int32)
    if genotype.num_nodes < config_vals.max_num_nodes
        genotype.num_nodes += 1
        for i = 1:genotype.num_nodes
            for j = 1:genotype.used_connections[i]
                if genotype.connections[(i - 1) * config_vals.max_num_connections + j] == index
                    add_incoming_connection(genotype, config_vals, convert(Int32, i), genotype.num_nodes)
                end
            end
        end
        genotype.used_connections[genotype.num_nodes] = genotype.used_connections[index]
        genotype.activations[genotype.num_nodes] = genotype.activations[index]
        genotype.thresholds[genotype.num_nodes] = genotype.thresholds[index]
        from_start = (index - 1) * config_vals.max_num_connections
        to_start = (genotype.num_nodes - 1) * config_vals.max_num_connections
        for i = 1:genotype.used_connections[index]
            genotype.connections[to_start + i] = genotype.connections[from_start + i]
            genotype.weights[to_start + i] = genotype.weights[from_start + i]
        end
    end
    return 0
end


function add_incoming_connection(genotype::Type_Genotype, config_vals::Config.Type_Config_Values, node::Int32, connection_value::Int32, 
    weight_value::Int32 = 0)
    if genotype.used_connections[node] < config_vals.max_num_connections
        node_index = (node - 1) * config_vals.max_num_connections
        insert_index = (node - 1) * config_vals.max_num_connections + 1 + genotype.used_connections[node]
        while weight_value == 0
            weight_value = rand(config_vals.min_weight:config_vals.max_weight)
        end
        genotype.weights[insert_index] = weight_value
        if connection_value == 0
            found_connection_value = false
            while !found_connection_value
                connection_value = rand(1:genotype.num_nodes)
                found_connection_value = true
                for k = 1:genotype.used_connections[node]
                    if connection_value == genotype.connections[node_index + k]
                        found_connection_value = false
                    end
                end
            end
        end
        genotype.connections[insert_index] = connection_value
        genotype.used_connections[node] += 1
    end

    return 0
end


function add_outgoing_connection(genotype::Type_Genotype, config_vals::Config.Type_Config_Values, node::Int32, connection_value::Int32)
    connection_value = node
    while node == connection_value
        node = rand(1:genotype.num_nodes)
    end
    if genotype.used_connections[node] < config_vals.max_num_connections
        node_index = (node - 1) * config_vals.max_num_connections
        insert_index = (node - 1) * config_vals.max_num_connections + 1 + genotype.used_connections[node]
        weight_value = 0
        while weight_value == 0
            weight_value = rand(config_vals.min_weight:config_vals.max_weight)
        end
        genotype.weights[insert_index] = weight_value
        if connection_value == 0
            found_connection_value = false
            while !found_connection_value
                connection_value = rand(1:genotype.num_nodes)
                found_connection_value = true
                for k = 1:genotype.used_connections[node]
                    if connection_value == genotype.connections[node_index + k]
                        found_connection_value = false
                    end
                end
            end
        end
        genotype.connections[insert_index] = connection_value
        genotype.used_connections[node] += 1
    end

    return 0
end


function delete_incomming_connection(genotype::Type_Genotype, config_vals::Config.Type_Config_Values, node::Int32, conn_num::Int32)
    if genotype.used_connections[node] > config_vals.min_num_connections
        delete_index = (node - 1) * config_vals.max_num_connections + conn_num
        nodes_last_index = (node - 1) * config_vals.max_num_connections + genotype.used_connections[node]
        if conn_num < genotype.used_connections[node]
            genotype.connections[delete_index] = genotype.connections[nodes_last_index]
            genotype.weights[delete_index] = genotype.weights[nodes_last_index]
        end
        genotype.connections[nodes_last_index] = 0
        genotype.weights[nodes_last_index] = 0
        genotype.used_connections[node] -= 1
    end
    return 0
end


function mutate_connection(genotype::Type_Genotype, config_vals::Config.Type_Config_Values, node::Int32, conn_num::Int32)
    nodes_first_index = (node - 1) * config_vals.max_num_connections
    connection_value = 0
    found_connection_value = false
    while !found_connection_value
        connection_value = rand(1:genotype.num_nodes)
        found_connection_value = true
        for j = 1:genotype.used_connections[node]
            if connection_value == genotype.connections[nodes_first_index + j]
                found_connection_value = false
            end
        end
    end
    genotype.connections[nodes_first_index + conn_num] = connection_value
    return 0
end


function mutate_weight(genotype::Type_Genotype, config_vals::Config.Type_Config_Values, node::Int32, weight_num::Int32)
    index = (node - 1) * config_vals.max_num_connections + weight_num
    new_weight = 0
    while true
        new_weight = rand(config_vals.min_weight:config_vals.max_weight)
        if (new_weight != genotype.weights[index]) && (new_weight != 0) 
            break
        end
    end
    genotype.weights[index] = new_weight
    return 0
end


function mutate_activation(genotype::Type_Genotype, config_vals::Config.Type_Config_Values, node::Int32)
    genotype.activations[node] = 1 - genotype.activations[node]
    return 0
end


function mutate_threshold(genotype::Type_Genotype, config_vals::Config.Type_Config_Values, node::Int32)
    new_value = 0
    while true
        new_value = rand(config_vals.min_threshold:config_vals.max_threshold)
        if new_value != genotype.thresholds[node]
            break
        end
    end
    genotype.thresholds[node] = new_value
    return 0
end

end
