include("config.jl")

import Config

function evolve()
    config_vals::Config.Type_Config_Values = Config.Type_Config_Values()

    num_input_nn_nodes = convert(Int32, 2)
    num_hidden_nn_nodes = convert(Int32, 2)
    num_output_nn_nodes = convert(Int32, 2)

    layer_1_weights = zeros(Float32, num_input_nn_nodes * num_hidden_nn_nodes)
    layer_2_weights = zeros(Float32, num_output_nn_nodes * num_hidden_nn_nodes)
    inputs = zeros(Float32, num_input_nn_nodes)
    hidden_activations = zeros(Float32, num_hidden_nn_nodes)
    outputs = zeros(Float32, num_output_nn_nodes)
    walls = [convert(Float32, 0), convert(Float32, 1), convert(Float32, 0), 
             convert(Float32, 1), convert(Float32, 0), convert(Float32, 0),
             convert(Float32, 0), convert(Float32, 1), convert(Float32, 200),
             convert(Float32, 1), convert(Float32, 0), convert(Float32, 400),]
    fitness_ref = [convert(Float32, 1)]


    num_goals = convert(Int32, 8)
    goals = convert(Array{Float32, 1},[250, 10,  
                                       300, 10,
                                       350, 10,
                                       390, 10,
                                       390, 50,
                                       390, 100,
                                       390, 150, 
                                       390, 190,])                 

    fitness_vals_1::Dict{Int64, Float64} = Dict{Int64, Float64}()

    to_copy_over::Array{Int32, 1} = zeros(Int32, config_vals.births_and_deaths_per_generation)

    population = []
    for i = 1:config_vals.population_size
        push!(population, rand(convert(Int32, 0):convert(Int32, 1), config_vals.max_num_nodes))
    end
    
    fitnesses = zeros(Float32, config_vals.population_size)

    #for i = 1:config_vals.num_generations
    for i = 1:100
        for j = 1:config_vals.population_size
            index = activations_to_int(population[j])
            fitness = get(fitness_vals, index, -1)
            if fitness == -1
                Libdl.dlopen("/home/david/TehzCodes/GRNEvolution/librobosim")
                ccall((:simulate, "/home/david/TehzCodes/GRNEvolution/librobosim"), Void,
                      (Int32, Ptr{Float32}, Ptr{Float32}, Int32, Ptr{Int32}, Int32, Int32, Int32, 
                       Int32, Ptr{Float32}, Ptr{Float32}, Ptr{Float32}, Ptr{Float32}, Ptr{Float32}, Ptr{Float32}, Int32, Int32),
                      convert(Int32, 250), walls, goals, num_goals, population[j], convert(Int32, 5), num_input_nn_nodes, num_hidden_nn_nodes, 
                num_output_nn_nodes, layer_1_weights, layer_2_weights, inputs, hidden_activations, 
                outputs, fitness_ref, convert(Int32, 1), convert(Int32, 0))
                fitness = fitness_ref[1]
                fitness_vals_1[index] = fitness
            end
            fitnesses[j] = fitness
        end
        breed_and_exterminate(config_vals, population, fitnesses, to_copy_over)
        sum = 0
        for i = 1:config_vals.population_size
            sum += fitnesses[i]
        end
        println(maximum(fitnesses), " ", sum/config_vals.population_size)
    end
end

function breed_and_exterminate(config_vals::Config.Type_Config_Values, population, 
                               fitnesses::Array{Float32, 1}, to_copy_over::Array{Int32, 1})
    for i = 1:config_vals.births_and_deaths_per_generation
        index_to_delete = 0
        lowest_fitness::Float32 = 2000
        for j = 1:config_vals.extermination_tournament_size
            new_index = rand(1:config_vals.population_size)
            if fitnesses[new_index] < lowest_fitness
                index_to_delete = new_index
                lowest_fitness = fitnesses[new_index]
            end
        end
        to_copy_over[i] = index_to_delete
    end
    for i = 1:config_vals.births_and_deaths_per_generation
        index_to_breed = 0
        highest_fitness::Float32 = -1
        for j = 1:config_vals.breeding_tournament_size
            new_index = rand(1:config_vals.population_size)
            if fitnesses[new_index] > highest_fitness
                index_to_breed = new_index
                highest_fitness = fitnesses[new_index]
            end
        end
        population[to_copy_over[i]] = copy(population[index_to_breed])
        mutate(config_vals, population[to_copy_over[i]])
    end
end

function mutate(config_vals::Config.Type_Config_Values, bit_string::Array{Int32, 1})
    num_mutations = 3
    for i = 1:num_mutations
        mutation_index = rand(1:config_vals.max_num_nodes)
        if bit_string[mutation_index] == 1
            bit_string[mutation_index] = 0
        else
            bit_string[mutation_index] = 1
        end
    end
end

function activations_to_int(bit_string::Array{Int32, 1})
    integer::Int64 = 0
    for i = 1:length(bit_string)
        integer += bit_string[i] * 2^(i - 1)
    end
    integer += 1
    return integer
end

@time evolve()
