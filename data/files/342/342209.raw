module RAD

using Calculus, Debug
import Base.Meta.isexpr

##### run-time types
immutable WRT{T}
    val::T
end

abstract AbstractSeed{T}

immutable SeedWithVal{T} <: AbstractSeed{T}
    val::T
    dval::T
end

immutable Seed{T} <: AbstractSeed{T}
    dval::T
end

include("compiletimetypes.jl")
include("flatten.jl")           #replace deeply nested Exprs with blocks of shorter Exprs
include("encode.jl")            #mark up AST and return dict of active symbols
include("grad.jl")              #all reverse sweep except d_assign_call(*) functions
include("gradient_rules.jl")    #d_assign_call(*)
include("decode.jl")            #generate "function evaluation" code, saving values of overwritten vars appropriately
include("cleanup.jl")           #anything we want to do to the generated gradient code goes here

export WRT, Seed, SeedWithVal, @autodiff, autodiffExpr, fungrad, SymDict
       #flatten, encode!, decode!, grad,
       #sym, dsym, SymDict,
       #ASymbol, ARef, ATrans


### main function and macro calls
function fungrad(wrtList::Array, f::Expr)
    #fungrad: return Expr for method of f which returns
    #function value and derivatives w/r/t symbols in WRTlist
    s = SymDict()
    for arg in wrtList; activate!(s,arg); end
    f_flat = flatten(f)
    f_encoded=encode!(f_flat,s)
    fg = gradient(f_encoded,s)[1]
    fg_clean = cleanup(fg)
    fg_clean
end


function autodiff(wrts::Expr, f::Expr)
    @assert wrts.head == :tuple
    @assert all(x->isa(x,Symbol),wrts.args)
    b_out = Expr(:block)
    push!(b_out.args,f)
    for nn=1:length(wrts.args)
        for wrtList in combinations(wrts.args,nn)
            push!(b_out.args,fungrad(wrtList,f))
        end
    end
    b_out
end

macro autodiff(wrts::Expr,f::Expr)
    esc(autodiff(wrts,f))
end

end # module
