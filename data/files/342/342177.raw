############# backward sweep and final codegen for derivative code ############
uninitialized(a::Active, state::Dict) = sym(a) in state["uninitialized"]
function initIfNeeded!(a::Active, state::Dict)
    extra_args = {}
    if isa(a,ARef) && uninitialized(a,state)
        pop!(state["uninitialized"],sym(a))
        push!(extra_args,:($(a.dsym) = zero($(a.sym))) )
        return :(+=), extra_args
    elseif uninitialized(a,state)
        pop!(state["uninitialized"],sym(a))
        return :(=), extra_args
    else
        return :(+=), extra_args
    end
end
initIfNeeded!(a::Any,state::Dict) = (:(+=), {})

##### d_$Mytype(arglist, ex, state): take an encoded expression of type Mytype
# and push a statement computing its derivatives to $arglist.
function d_assign(ex::Expr,state::Dict)
    #for a line y = h(x1,x2), where e.g. x1 and x2 are active,
    # push Expr's to new_args that compute dx1 += h_1(x1,x_2).*dy, dx2 += h_2(x1,x2).*dy
    #it's up to the individual function whether to calculate the derivatives jointly, e.g.
    #   Expr(:(=), :(($t1,$t2)), h(ASeed(y,dy),ASymbol(x1,dx1), ASymbol(x2,dx2))
    #   :($dx1 += $t1)
    #   :($dx2 += $t2)
    #we expect "state" to be a dict with fields
        #"uninitialized" : list of syms where dsym is not yet declared in generated code
    @assert ex.head in [:(=), :(+=)]
    if isa(ex.args[1],Active)
        rhs = ex.args[2]
        if isa(rhs,Active)
            d_assign_sym(ex,state)
        elseif rhs.head == :call
            ops = {}; inits = {};
            for arg in rhs.args[2:end]
                (op, g) = initIfNeeded!(arg,state)
                push!(ops,op)
                push!(inits,g...)
            end
            return [inits, d_assign_call(ops,ex,state,CallExpr(rhs))]
        elseif ex.args[2].head == :ref
            return d_assign_ref(ex,state)
        else
            error("can't d_assign expression with RHS expr $(rhs) having head $(rhs.head)")
        end
    else
        return {}
    end
end

function d_assign_sym(ex,state)
    @assert isa(ex.args[2],Active)
    @assert isa(ex.args[1],Active)
    (op,extra) = initIfNeeded!(ex.args[2], state )
    [extra..., Expr(op,dsym(ex.args[2]),dsym(ex.args[1]))]
end

function d_assign_ref(ex,state)
    error("d_assign_ref not yet implemented")
end

function d_block(ex::Expr,state)
    #we expect "state" to be a dict with fields
    # (1) "uninitialized" : list of syms where dsym isn't yet defined in generated code
    @assert ex.head == :block
    inner_args = {}
    for s in reverse(ex.args)
        push!(inner_args, grad(s,state)...)
    end
    [Expr(:block,inner_args...)]
end

function d_for(ex::AFor,state)
    #first, determine which vars are local and need to be initialized within the loop.
    #initialize the remaining uninitialized vars before the loop.
    #"nonlocals"
    #expect that "state" is a Dict with field "uninitialized": Set(Symbol)
    nonlocals = intersect(state["uninitialized"], keys(ex.s) )
    locals = setdiff(keys(ex.s),nonlocals)
    newargs = {}
    for xsym in nonlocals
        x = ex.s[xsym]::Active
        pop!(state["uninitialized"],xsym)
        push!( newargs,:( $(dsym(x)) = zero($(sym(x))) ) )
    end
    #loop backwards (in spirit of reverse mode)
    ix = Expr( ex.loop.head, ex.loop.args[1], :(reverse($(ex.loop.args[2]))) )
    #generate loop body:
    initializeInLoop = Set(union(locals,state["uninitialized"])...)
    inner_state = ["active"=>merge(ex.s,state["active"]),
                   "uninitialized"=>initializeInLoop ]
    inner_block = grad(ex.block,inner_state)
    push!(newargs, Expr(:for,ix,inner_block...))
    newargs
end

function d_function(f,state)
    seed=gensym("seed")
    tagged_args = {Expr(:(::),seed,:Seed)} #list of arguments of function; label active args with type "WRT"
    fname = f.args[1].args[1]
    returns = Expr(:tuple) #function value and derivatives
    block = f.args[2]
    fval=ASymbol(gensym("val"))
    from_seed = Expr(:(=),dsym(fval),:($seed.dval))
    merge!(state["active"],[sym(fval)=>fval])
    block.args[end] = Expr(:(=),fval,block.args[end])
    push!(returns.args,sym(fval))
    block_args = decode(block.args)
    dblock_args = {}
    for arg in reverse(block.args)
        #println("in d_function: taking gradient of $(arg)")
        push!(dblock_args,grad(arg,state)...)
    end
    unpack = {}
    for x in f.args[1].args[2:end]
        if isa(x,Active)
            s2 = gensym("$(sym(x))")
            push!(tagged_args, :($s2 :: WRT) )
            push!(unpack, :($(sym(x))=$(s2).val))
            push!(returns.args, :($(dsym(x))))
        else
            push!(tagged_args,x)
        end
    end
    fcall = Expr(:call,fname,tagged_args...)
    [Expr(:function,fcall,Expr(:block,[unpack,block_args,from_seed,dblock_args,returns]...))]
end

function gradient(ex,s::SymDict)
    state = initialState(s)
    grad(ex,state)
end
initialState(s::SymDict) = {"active"=>copy(s), "uninitialized"=>Set(keys(s)...)}

grad(ex::LineNumberNode,state::Dict) = {}
grad(ex::ASymbol,state::Dict) = {}
grad(ex::AFor,state::Dict) = d_for(ex,state)
grad(ex::ARef,state::Dict) = (ex,state) -> [dsym(ex)]
grad(ex::Expr,state::Dict) = d_lookup[ex.head](ex,state)
grad(ex_list::Vector,state::Dict) = error("shouldnt call this method with $(ex_list)") #map(x->grad(x,state),reverse(ex_list))
d_lookup = [:function => d_function,
            :block => d_block,
            :(=) => d_assign,
            :(+=)=>d_assign,
            :line => ((l,state)->{}), ]
