module SpimRegXML

using LightXML, AffineTransforms


abstract AbstractImageLoader

immutable KlbImageLoader <: AbstractImageLoader
    templates::Vector{AbstractString}
    timetags::Vector{AbstractString}
end


type ViewSetup
    id::Int
	name::AbstractString
	imagesizes::Array{Int}
	pixelspacings::Array{Real}
    angle::Int
    channel::Int
	illumination::Int
end

ViewSetup() = ViewSetup(-1, "", [], [], -1, -1, -1)


immutable SequenceDescription{T<:AbstractImageLoader}
    loader::T
    setups::Vector{ViewSetup}
end


immutable NamedAffine
	name::AbstractString
	affine::AffineTransform
end


function sequence_description( filepath::AbstractString )
    xdoc = parse_file(filepath)
	xseq = find_element(root(xdoc), "SequenceDescription")

    xloader = find_element(xseq, "ImageLoader")
    format = attribute(xloader, "format")
    if format == "klb"
        templates = []
        timetags = []
        xresolver = find_element( find_element(xseq, "ImageLoader"), "Resolver" )
		for xelem in child_elements(xresolver)
			if name(xelem) == "ViewSetupTemplate"
                push!(templates, content(find_element(xelem, "template")))
                xtime = find_element(xelem, "timeTag")
                if xtime != Void
                    push!(timetags, content(xtime))
                else
                    push!(timetags, "TM")
                end
			end
		end
        loader = KlbImageLoader(templates, timetags)
    else
        error(@sprintf("Unsupported ImageLoader format %s", format))
    end

	setups = ViewSetup[]
	for xsetup in child_elements( find_element(xseq, "ViewSetups") )
		if name(xsetup) != "ViewSetup"
			continue
		end

		setup = ViewSetup()
        push!(setups, setup)

        setxfields!(setup, (:id, :name), xsetup)

		imagesize = split(
            content( find_element(xsetup, "size") ),
            r"\s+" )
		setup.imagesizes = reshape(
            [ parse(Int, s) for s in imagesize ],
            (length(imagesize), 1) )

		xpixelspacing = find_element(xsetup, "voxelSize")
		pixelspacing = split(
            content( find_element(xpixelspacing, "size") ),
            r"\s+" )
		setup.pixelspacings = reshape(
            [ float(s) for s in pixelspacing ],
            (length(pixelspacing), 1) )

		xattrs = find_element(xsetup, "attributes")
        setxfields!(setup, (:angle, :channel, :illumination), xattrs)
	end

	SequenceDescription(loader, setups)
end


function transforms( filepath::AbstractString )
	out = Dict{ Int, Dict{Int, Vector{NamedAffine}} }()
	xdoc = parse_file(filepath)
	registrations = find_element(root(xdoc), "ViewRegistrations")
	for registration in child_elements(registrations)
		t = int( attribute(registration, "timepoint") )
		setup = int( attribute(registration, "setup") )
		if !haskey(out, t)
			out[t] = Dict{Int, Vector{NamedAffine}}()
		end
		out[t][setup] = affine_list(registration)
	end
	return out
end


function affine_list( xml::XMLElement )
	@assert name(xml) == "ViewRegistration"
	return [ affine(e) for e in get_elements_by_tagname(xml, "ViewTransform") ]
end


function affine( xml::XMLElement )
	@assert name(xml) == "ViewTransform" && attribute(xml, "type") == "affine"

	nam = ""
	xelem = find_element(xml, "Name")
	if typeof(xelem) == XMLElement
		nam = strip( content(xelem) )
	end

	parts = split( strip( content( find_element(xml, "affine"))), r"\s+" )
	values = Array(Real, 4, 3)
	for (i, s) in enumerate(parts)
		values[i] = float(s)
	end
	values = transpose(values)

	return NamedAffine(nam, AffineTransform(values[:, 1:3], values[:, 4]))
end


function xml(
		affines::Dict{ Int, Dict{Int, Vector{NamedAffine}} },
		filepath_in::AbstractString,
		filepath_out::AbstractString
		)
	xdoc = parse_file(filepath_in)
	xroot = root(xdoc)

	trafos_old = find_element(xroot, "ViewRegistrations")
	unlink(trafos_old)
	free(trafos_old)

	trafos_new = xml(affines)
	add_child(xroot, trafos_new)

	save_file(xdoc, filepath_out)
end


function xml( affines::Dict{ Int, Dict{Int, Vector{NamedAffine}} } )
	out = new_element("ViewRegistrations")
	for t in sort!( [ t for t in keys(affines) ] )
		setups = affines[t]
		for s in sort!( [ s for s in keys(setups) ] )
			trafos = setups[s]
			xtrafos = xml(trafos)
			set_attribute(xtrafos, "timepoint", string(t))
			set_attribute(xtrafos, "setup", string(s))
			add_child(out, xtrafos)
		end
	end
	return out
end


function xml( affines::Vector{NamedAffine} )
	out = new_element("ViewRegistration")
	for a in affines
		add_child(out, xml(a))
	end
	return out
end


function xml( affine::NamedAffine )
	out = new_element("ViewTransform")
	set_attribute(out, "type", "affine")

	if length(affine.name) > 0
		e = new_child(out, "Name")
		add_text(e, affine.name)
	end

	values = Array(Real, 12)
	trafo = affine.affine
	values[ 1: 3] = trafo.scalefwd[1, :]
	values[ 5: 7] = trafo.scalefwd[2, :]
	values[ 9:11] = trafo.scalefwd[3, :]
	values[ 4] = trafo.offset[1]
	values[ 8] = trafo.offset[2]
	values[12] = trafo.offset[3]

	e = new_child(out, "affine")
	add_text(e, join(values, " "))
	return out
end


function setxfield!(
    value,
    name::Symbol,
    xelem::LightXML.XMLElement,
    xname::AbstractString = string(name)
    )
    x = content( find_element(xelem, xname) )
    try
        setfield!(value, name, x)
    catch TypeError
        setfield!(value, name, parse( fieldtype(typeof(value), name), x ))
    end
end


function setxfields!(
    value,
    names,
    xelem::LightXML.XMLElement,
    xnames = [string(i) for i in names]
    )
    for (i, name) in enumerate(names)
        setxfield!(value, name, xelem, xnames[i])
    end
end

end # module
