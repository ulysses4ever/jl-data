export ddMulticlassifierSystem, multiclassifierFusion, calcMethod1

#Creates binomial(d,comb) feature combinations where d is the count of features of data_set
#Returns indices of possible feature combinations
function createFeatureCombinations{T<:Number}(data_set::AbstractArray{T,2},comb::Int64=2)
	return collect(combinations(1:length(data_set[1,:]),comb))
end

#creates ddMulticlassifierSystem 
function ddMulticlassifierSystem{T<:Number}(data_set::AbstractArray{T,2},classlabels::AbstractVector,depth_function::Function,comb::Int64=2,
											calc_function::Function=calcMethod1,mcd::Bool=false,k::Int64=-1,randvectors=[])
	featureComb = createFeatureCombinations(data_set,comb)
	uniqueClasslabels = unique(sort(classlabels))
	
	res = cell(length(featureComb))

	#for i in 1:length(featureComb)
		#selectedData = data_set[:,featureComb[i]]
		#if(k == -1)
		#	dd = dd_plot(selectedData,classlabels,depth_function,mcd)
		#else
		#	dd = dd_plot(selectedData,classlabels,depth_function,mcd,k,randvectors)
		#end
		#
		#tmp1 = abs(minimum(dd[:,1]) - maximum(dd[:,2]))
	#	tmp2 = abs(maximum(dd[:,1]) - minimum(dd[:,2]))
	#	res[i] = (mean([tmp1,tmp2]),featureComb[i])
	#end

	for i in 1:length(featureComb)
		selectedData = data_set[:,featureComb[i]]
		if(k == -1)
			dd = dd_plot(selectedData,classlabels,depth_function,mcd)
		else
			dd = dd_plot(selectedData,classlabels,depth_function,mcd,k,randvectors)
		end
		
		calcMethod = calc_function(dd,classlabels)
		res[i] = (calcMethod,featureComb[i])
	end
	
	#for i in 1:length(featureComb)
	#	selectedData = data_set[:,featureComb[i]]
	#	dd = dd_plot(selectedData,classlabels,depth_function)
	#	tmp = similar(dd)[:,1]
	#	for j in 1:length(dd[:,1])
	#		tmp[j] = abs(dd[j,1] - dd[j,2])
	#	end
	#	res[i] = (mean(tmp),featureComb[i])
	#end
	
	return sort(res,rev=true,lt=(x,y)->x[1] <= y[1])
end

#This uses the average distance of points of one class to all points of the another class as separation criterium
function calcMethod1(ddplot::AbstractArray{Float64,2},classlabels::AbstractVector)
	uniqueClasslabels = sort(unique(classlabels))
	ind_class1 = findin(classlabels,uniqueClasslabels[1])
	ind_class2 = findin(classlabels,uniqueClasslabels[2])
	
	tmp1 = []
	for i in ind_class1
		for j in ind_class2
			append!(tmp1, [norm(vec(ddplot[i,:]) - vec(ddplot[j,:]))])
		end
	end
	tmp1 = mean(tmp1)
	
	tmp2 = []
	for i in ind_class2 
		for j in ind_class1
			append!(tmp2, [norm(vec(ddplot[i,:]) - vec(ddplot[j,:]))])
		end
	end
	tmp2 = mean(tmp2)
	
	return mean([tmp1,tmp2])
end

#Negative correlation between DD coordinates
function calcMethod2(ddplot::AbstractArray{Float64,2},classlabels::AbstractVector)

end

function multiclassifierFusion(sortedRes::AbstractVector, cnt::Int64=20)
	res = cell(cnt)
	
	for i in 1:cnt
		res[i] = sortedRes[i][2]
	end
	
	return unique(res)
end