#
# Naive-Needleman-Wunsch
# Copyright (C) 2012  Khalique Williams
#
# This file is part of Naive-Needlemann-Wunch.
#
# Naive-Needleman-Wunsch is free software: you can redistribute it and/or modify
# it under the terms of the   GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Naive-Needleman-Wunsch is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Naive-Needleman-Wunsch.  If not, see <http://www.gnu.org/licenses/>.
#
# If you wish to contact the author of Naive-Needleman-Wunsch, you may do so at
# kwillia.pub@gmail.com
#

abstract ISequence

type SequenceK1 <: ISequence

end

type SequenceK2 <: ISequence

end

type NoSequence <: ISequence

end

abstract IState

type State <: IState
    _id::Int64
    _transitions::Dict{Any,Any}
end

type NullState <: IState
end

abstract IStateKey;

# State A is the first character considered in a repetitive seq. eg: A in AAA
type StateKeyA <: IStateKey
end

# State B is the second unique character considered in a repetitive seq. eg: B in ABABABAB
type StateKeyB <: IStateKey
end

# State C is the third unique character considered in a repetitive seq. eg: C in BACBACBACBAC
type StateKeyC <: IStateKey
end

# State A' is the first character considered in a repetitive seq. eg: A in AAA
type StateKeyAprime <: IStateKey
end

# State B' is the second unique character considered in a repetitive seq. eg: B in ABABABAB
type StateKeyBprime <: IStateKey
end

# State C' is the third unique character considered in a repetitive seq. eg: C in BACBACBACBAC
type StateKeyCprime <: IStateKey
end

type RecognitionStackEntry
    _sequenceId::ISequence
    _currentIndexInTarget::Int64
    _target::Array{Char}
end

# organized with entries containing (repitionLength,currentPlace,"AB"}
type RecognitionStack
    _entries::Array{RecognitionStackEntry}
end

##################################################################################



##################################################################################

function hash(stateKey::StateKeyA)
    return 1
end

function hash(stateKey::StateKeyB)
    return 2
end

function hash(stateKey::StateKeyC)
    return 3
end

function hash(stateKey::StateKeyAprime)
    return 4
end

function hash(stateKey::StateKeyBprime)
    return 5
end

function hash(stateKey::StateKeyCprime)
    return 6
end

function pop(array::Array{RecognitionStackEntry})
    println("POPPING ::Array{RecognitionStackEntry}")

    if isempty(array)
        return RecognitionStackEntry(NoSequence(),0,[' '])
    else
        poppedElement = array[end]
        ccall(:jl_array_del_end, Void, (Any, Uint), array, 1)
        return poppedElement
    end
end

##################################################################################


##################################################################################

function pop(recognitionStack::RecognitionStack)
    return pop(recognitionStack._entries)
end

function nwstring(A::StateKeyA)
    return "<StateKey:A>"
end

function nwstring(B::StateKeyB)
    return "<StateKey:B>"
end

function nwstring(C::StateKeyC)
    return "<StateKey:C>"
end

# we have to override this fn, to prevent it from trying to details of its members.
# as some objects are self referential
function nwstring(state::State)
    return strcat("<State:",string(state._id),">")
end

function nwstring(state::NullState)
    return "<State:NullState>"
end

abstract PushDownAutomata

type RecognitionPDA <: PushDownAutomata
    _stack::RecognitionStack
    _startState::IState
    _currentState::IState
end

##################################################################################

##################################################################################

function getTransitionMap(state::State)
    return state._transitions;
end

function createState(id::Int64)
    return State(id, Dict())
end

function init(state::State,transitions::Array{Dict{Any,Any}})
    del_all(state._transitions)

    print("\nInit(")
    print(state)
    println(")")

    for transition in transitions
        println(transition)
        state._transitions = merge(state._transitions, transition)
    end

    ## tests ##
    for transition in transitions
        ## for each dictionary check that the keys all address a value ##
        for key in keys(transition)
            val = get(state._transitions, key, NullState())
            
            print("\t -- ")
            print(key)
            print(" => ")
            show(nwstring(val))
            print("\n")
        end
    end

    print("\n")
end

function createRecognitionStack()
    return RecognitionStack([RecognitionStackEntry(NoSequence(),0,[' '])])
end

function createRecognitionPDA(stack::RecognitionStack,startState::IState)
    return RecognitionPDA(stack, startState, startState)
end

function getEntries(stack::RecognitionStack)
    return stack._entries
end

function pushToStack(pda::RecognitionPDA, entry::RecognitionStackEntry)
    pdaStack = pda._stack
    stackEntries = getEntries(pdaStack)
    push(stackEntries, entry)
end

function popTopOfStack(pda::RecognitionPDA)
    pdaStack = pda._stack
    stackEntries = getEntries(pdaStack)
    poppedEntry = pop(stackEntries)

    return poppedEntry
end

##################################################################################
##################################################################################

function getNextState(aState::IState, input::IStateKey)
    nextState = get(getTransitionMap(aState), input, NullState())
    return nextState
end

# creates push down automata for pattern recognition 
function createRecognitionPDA()
    ## state definitions ##
    s0 = createState(0)
    s1 = createState(1)
    s2 = createState(2)
    s3 = createState(3)
    s4 = createState(4)
    s5 = createState(5)
    s6 = createState(6)
    s7 = createState(7)
    s8 = createState(8)
    s9 = createState(9)
    s10 = createState(10)
    s11= createState(11)
    s12 = createState(12)

    print("\n")
    show(s0)

    ## transition defns ##
    init(s0, [{StateKeyA()=>s1}, {StateKeyAprime()=>s7}])

    ## k1 ##
    init(s1, [{StateKeyA()=>s1}, {StateKeyB()=>s2}])
    init(s2, [{StateKeyA()=>s3}, {StateKeyC()=>s4}])
      init(s3, [{StateKeyB()=>s2}])
    init(s4, [{StateKeyA()=>s5}])
      init(s5, [{StateKeyB()=>s6}])
        init(s6, [{StateKeyC()=>s4}])

    ## k2 ##
    init(s7, [{StateKeyAprime()=>s7}, {StateKeyBprime()=>s8}])
    init(s8, [{StateKeyAprime()=>s9}, {StateKeyCprime()=>s10}])
      init(s9, [{StateKeyBprime()=>s8}])
    init(s10, [{StateKeyAprime()=>s11}])
      init(s11, [{StateKeyBprime()=>s12}])
        init(s12, [{StateKeyCprime()=>s10}])

    ## tests ##
    testS0_1 = getNextState(s0, StateKeyC())
    println(nwstring(testS0_1))

    testS0_2 = getNextState(s0, StateKeyA())
    println(nwstring(testS0_2))

    if isa(Type{NullState},typeof(testS0_1))
        println("S0 Test Failed\n")
    else
        println("S0 Test Succeeded\n")
    end

    recognitionStack = createRecognitionStack()

    recognitionPDA = createRecognitionPDA(recognitionStack, s0)
    # just testing out basic functionality of recognition stack
    topOfRecognitionStack = popTopOfStack(recognitionPDA)
    print("Test(1) - Top Of Recognition Stack: ")
    println(topOfRecognitionStack)

    topOfRecognitionStack._sequenceId = SequenceK1()
    topOfRecognitionStack._currentIndexInTarget = topOfRecognitionStack._currentIndexInTarget + 1
    topOfRecognitionStack._target = ['C']
    pushToStack(recognitionPDA, topOfRecognitionStack)

    topOfRecognitionStack1 = popTopOfStack(recognitionPDA)
    print("Test(2) - Top Of Recognition Stack: ")
    println(topOfRecognitionStack1)

    push(topOfRecognitionStack1._target, 'G')
    topOfRecognitionStack1._currentIndexInTarget = topOfRecognitionStack1._currentIndexInTarget + 1
    pushToStack(recognitionPDA, topOfRecognitionStack1)

    topOfRecognitionStack2 = popTopOfStack(recognitionPDA)
    print("Test(3) - Top Of Recognition Stack: ")
    println(topOfRecognitionStack2)

    return recognitionPDA
end

function tickPDAGivenInput(pda::RecognitionPDA, input::Char)
    print("Ticking '")
    print(input)
    println("'")

    topRecognitionStackEntry = popTopOfStack(pda)

    println(topRecognitionStackEntry)

    # if top of stack is empty, then we know:
    #   1) either PDA just initialized or reset due to non occurence
    #       of expected value in target pattern.
    #   2) _ index = 0 and _target=[] should be only StackEntry (if any).
    #   3) the choices for StateKey will be {StateKeyA,StateKeyAprime}

    if isa(typeof(topRecognitionStackEntry._sequenceId),Type{NoSequence})
        println("Top of stack is empty")

        pushToStack(pda, RecognitionStackEntry(SequenceK1(), 1, [input]))
    else
        println("Top of stack NOT empty")

        # here the _index and the length of _target in RecognitionStackEntry tell us what to
        targetIndex = topRecognitionStackEntry._currentIndexInTarget
        targetArray = topRecognitionStackEntry._target

        if targetIndex == length(targetArray)
            ## todo:will here we have to analysethe current state and what the keys are than are valid for it#
            ## if we're deaing with a single value repetition we know thatwe're either at s1 or s7 and shoul choose StateKeyA#
            ##  otherwise it depends ##         
        else
            ## todo: ##
        end

        push(topRecognitionStackEntry._target, 'G')
        topRecognitionStackEntry._currentIndexInTarget = topRecognitionStackEntry._currentIndexInTarget + 1
        pushToStack(pda, topRecognitionStackEntry)        
    end
end

##################################################################################

println("Naive-Needleman-Wunsch")

thePDA = createRecognitionPDA()
tickPDAGivenInput(thePDA, 'C')
tickPDAGivenInput(thePDA, 'G')

