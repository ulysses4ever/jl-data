#
# Naive-Needleman-Wunsch
# Copyright (C) 2012  Khalique Williams
#
# This file is part of Naive-Needlemann-Wunch.
#
# Naive-Needleman-Wunsch is free software: you can redistribute it and/or modify
# it under the terms of the   GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Naive-Needleman-Wunsch is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Naive-Needleman-Wunsch.  If not, see <http://www.gnu.org/licenses/>.
#
# If you wish to contact the author of Naive-Needleman-Wunsch, you may do so at
# kwillia.pub@gmail.com
#

include("modelling_functions.jl")
include("nw_algorithm.jl")

##################################################################################



##################################################################################

type ModifiedNWSystem
  _matrix::NWMatrix

  _seq1::Array{Char}
  _seq2::Array{Char}

  _pdaSeq1::RecognitionPDA
  _pdaSeq2::RecognitionPDA
end

type NaiveNWSystem
  _matrix::NWMatrix

  _seq1::Array{Char}
  _seq2::Array{Char}

  _substitutionMatrix::SubstMatrix
end

function getLengthOfSeq1(system::ModifiedNWSystem)
  return length(system._seq1)
end

function getLengthOfSeq1(system::NaiveNWSystem)
  return length(system._seq1)
end


function getLengthOfSeq2(system::ModifiedNWSystem)
  return length(system._seq2)
end

function getLengthOfSeq2(system::NaiveNWSystem)
  return length(system._seq2)
end


function getNuclInSeq1(system::ModifiedNWSystem, i::Int64)
    return system._seq1[i]
end

function getNuclInSeq1(system::NaiveNWSystem, i::Int64)
    return system._seq1[i]
end

function getNuclInSeq2(system::ModifiedNWSystem, j::Int64)
    return system._seq2[j]
end

function getNuclInSeq2(system::NaiveNWSystem, j::Int64)
    return system._seq2[j]
end

function getFullSeq1(system::NaiveNWSystem)
  return system._seq1
end

function getFullSeq1(system::ModifiedNWSystem)
  return system._seq1
end

function getFullSeq2(system::NaiveNWSystem)
  return system._seq2
end

function getFullSeq2(system::ModifiedNWSystem)
  return system._seq2
end

function getScoreInMatrix(system::NaiveNWSystem, i::Int64, j::Int64)
  return getMatrixValue(system._matrix,i,j)
end

function getScoreInMatrix(system::ModifiedNWSystem, i::Int64, j::Int64)
  return getMatrixValue(system._matrix,i,j)
end

function getIdentityOrSubstitutionScore(system::NaiveNWSystem, 
                                        nucl_a::Char,
                                        nucl_b::Char)
  return getScore(system._substitutionMatrix, nucl_a, nucl_b)
end

function createModifiedNWSystem(seq1::Array{Char}, seq2::Array{Char})
    lenOfSeq1 = length(seq1)
    lenOfSeq2 = length(seq2)

    if lenOfSeq1 > lenOfSeq2
        return ModifiedNWSystem(createMatrix(lenOfSeq2, lenOfSeq1), seq2, seq1,
          createRecognitionPDA(lenOfSeq1), createRecognitionPDA(lenOfSeq1))  
    else
        return ModifiedNWSystem(createMatrix(lenOfSeq1, lenOfSeq2), seq1, seq2,
          createRecognitionPDA(lenOfSeq2), createRecognitionPDA(lenOfSeq2))
    end
end

function createNaiveNWSystem(seq1::Array{Char}, seq2::Array{Char})
    lenOfSeq1 = length(seq1)
    lenOfSeq2 = length(seq2)

    if lenOfSeq1 > lenOfSeq2
        return NaiveNWSystem(createMatrix(lenOfSeq2, lenOfSeq1), seq2, seq1,
          createDefaultSubstitutionMatrix())
    else
        return NaiveNWSystem(createMatrix(lenOfSeq1, lenOfSeq2), seq1, seq2,
          createDefaultSubstitutionMatrix())
    end
end

abstract SubstMatrixChoice

type DefaultSubstMatrix <: SubstMatrixChoice
end

type CustomSubstMatrix1 <: SubstMatrixChoice
end

function createNaiveNWSystem(seq1::Array{Char}, seq2::Array{Char}, aChoiceOfSubstMatrix::SubstMatrixChoice)
    lenOfSeq1 = length(seq1)
    lenOfSeq2 = length(seq2)

    if isa(typeof(aChoiceOfSubstMatrix), Type{DefaultSubstMatrix})
      chosenSubstMatrix = createDefaultSubstitutionMatrix()
    elseif isa(typeof(aChoiceOfSubstMatrix), Type{CustomSubstMatrix1})
      chosenSubstMatrix = createCustomSubstitutionMatrix1()
    else
      chosenSubstMatrix = createDefaultSubstitutionMatrix()
    end

    if lenOfSeq1 > lenOfSeq2
        return NaiveNWSystem(createMatrix(lenOfSeq2, lenOfSeq1), seq2, seq1,
          chosenSubstMatrix)
    else
        return NaiveNWSystem(createMatrix(lenOfSeq1, lenOfSeq2), seq1, seq2,
          chosenSubstMatrix)
    end
end

##################################################################################


##################################################################################

# this right now is wrong/could be better (what if there's tie...yeah, but the solution is interesting!)
function putTogetherConsensusString(system::NaiveNWSystem)
  i,j = getNumOfRows(system._matrix),getNumOfCols(system._matrix)

  # println("(i,j) = ( $i , $j )")

  consensusSeq1 = "$(getNuclInSeq1(system,i))"
  consensusSeq2 = "$(getNuclInSeq2(system,j))"

  # println("Initial Consensus Seq 1: $consensusSeq1")
  # println("Initial Consensus Seq 2: $consensusSeq2")

  while i >= 1 && j >= 1
    #println("Now at (i,j) = ( $i , $j )")

    F_imin1_jmin1 = (((i-1) < 1 || (j-1) < 1) ? -float(0xffff) : getScoreInMatrix(system, i-1, j-1))
    F_i_jmin1     = ((i < 1 || (j-1) < 1) ? -float(0xffff) : getScoreInMatrix(system, i, j-1))
    F_imin1_j     = (((i-1) < 1 || j < 1) ? -float(0xffff) : getScoreInMatrix(system, i-1, j))
                    
    # println("Calculated F's, < F_{i-1}_{j-1}, F_{i}_{j-1}, F_{i-1}_{j} > = [$F_imin1_jmin1,$F_i_jmin1, $F_imin1_j]") 

    maxF = max(F_imin1_jmin1,F_i_jmin1,F_imin1_j)

    # println("Max(F's) = $maxF")
    
    if maxF == -float(0xffff)
      break
    end
             
    if F_imin1_jmin1 == maxF
      # println("F_imin1_jmin1: Trying to access index $(i-1) in nuclSeq1: $(getFullSeq1(system))")
      consensusSeq1 = "$(getNuclInSeq1(system,i-1))$consensusSeq1"
      consensusSeq2 = "$(getNuclInSeq2(system,j-1))$consensusSeq2"
      i,j = i-1,j-1
    elseif F_i_jmin1 == maxF
      # println("F_i_jmin1: Trying to access index $(j-1) in nuclSeq2: $(getFullSeq2(system))")
      consensusSeq1 = "-$consensusSeq1"
      consensusSeq2 = "$(getNuclInSeq2(system,j-1))$consensusSeq2"
      j = j-1
    elseif F_imin1_j == maxF
      # println("F_imin1_j: Trying to access index $(i-1) in nuclSeq1: $(getFullSeq1(system))")
      consensusSeq1 = "$(getNuclInSeq1(system,i-1))$consensusSeq1"
      consensusSeq2 = "-$consensusSeq2"
      i = i-1
    end
  end

  return (consensusSeq1,consensusSeq2)
end



##################################################################################

##################################################################################

abstract NaiveGapModel

type LinearGapModel <: NaiveGapModel end
type AffineGapModel <: NaiveGapModel end


function runNeedlemanWunsch(system::NaiveNWSystem, gapModel::AffineGapModel)
  println("Running Naive Needleman Wunsch Algorithm (Filling Matrix, F)")

  matrix = system._matrix

  numberOfRows = getNumOfRows(matrix)
  numberOfCols = getNumOfCols(matrix)

  println("Number of rows: $numberOfRows")
  println("Number of cols: $numberOfCols")

  ## for testing here only ## 
  gapPenalty = 5.0

  println("Gap Penalty: $gapPenalty")

  j = 1
  while j <= numberOfCols
    setMatrixValue(system._matrix, 1, j, -j*gapPenalty)
    j = j + 1
  end

  i = 1                                
  while i <= numberOfRows
    setMatrixValue(system._matrix, i, 1, -i*gapPenalty)
    i = i + 1 
  end 

  i,j = 2, 2

  identity_or_subst_score = 0 
  deletion_score = 0
  insertion_score = 0

  affineSystem = createAffineSystem()

  lastAffineState = getCurrentState(affineSystem)
  currAffineState = lastAffineState

  while i <= numberOfRows
    j = 2
    while j <= numberOfCols
      ## calculate the scores and costs for all options

      identity_or_subst_score =
        getIdentityOrSubstitutionScore(system,
                                       getNuclInSeq1(system, i),
                                       getNuclInSeq2(system, j))

      ## initial debug...i.e. not what it should be
      s1_curr = getNuclInSeq1(system, i)
      s2_curr = getNuclInSeq2(system, j)

      F_case_after_identity_or_subst = getMatrixValue(matrix, i-1, j-1) + identity_or_subst_score

      currentAffineState = getCurrentAffineSystem

      F_case_after_deletion = getMatrixValue(matrix, i-1, j) - gapPenalty
      F_case_after_insertion = getMatrixValue(matrix, i, j-1) - gapPenalty

      setMatrixValue(matrix, i, j, max(F_case_after_identity_or_subst,
                                       F_case_after_deletion,
                                       F_case_after_insertion))

      j += 1
    end

    i += 1
  end

  # drawMatrix(matrix)
  # print("\n $(drawMatrixWithNumbers(matrix))")
end


function runNeedlemanWunsch(system::NaiveNWSystem, gapModel::LinearGapModel)
#  println("Running Naive Needleman Wunsch Algorithm (Filling Matrix, F)")

  matrix = system._matrix

  numberOfRows = getNumOfRows(matrix)
  numberOfCols = getNumOfCols(matrix)

#  println("Number of rows: $numberOfRows")
#  println("Number of cols: $numberOfCols")

  ## for testing here only ## 
  gapPenalty = 5.0

#  println("Gap Penalty: $gapPenalty")

  j = 1
  while j <= numberOfCols
    setMatrixValue(system._matrix, 1, j, -j*gapPenalty)
    j = j + 1
  end

  i = 1
  while i <= numberOfRows
    setMatrixValue(system._matrix, i, 1, -i*gapPenalty)
    i = i + 1
  end

  i,j = 2, 2

  identity_or_subst_score = 0
  deletion_score = 0
  insertion_score = 0

  while i <= numberOfRows
    j = 2
    while j <= numberOfCols
      ## calculate the scores and costs for all options

      identity_or_subst_score = 
        getIdentityOrSubstitutionScore(system,
                                       getNuclInSeq1(system, i),
                                       getNuclInSeq2(system, j)) 

      ## initial debug...i.e. not what it should be
      s1_curr = getNuclInSeq1(system, i)
      s2_curr = getNuclInSeq2(system, j)

      F_case_after_identity_or_subst = getMatrixValue(matrix, i-1, j-1) + identity_or_subst_score
      F_case_after_deletion = getMatrixValue(matrix, i-1, j) - gapPenalty
      F_case_after_insertion = getMatrixValue(matrix, i, j-1) - gapPenalty

      setMatrixValue(matrix, i, j, max(F_case_after_identity_or_subst,
                                       F_case_after_deletion,
                                       F_case_after_insertion))

      j += 1
    end

    i += 1
  end

  # drawMatrix(matrix)
  # print("\n $(drawMatrixWithNumbers(matrix))")
end


function runNeedlemanWunsch(system::ModifiedNWSystem)
#  println("Running Modified Needleman Wunsch Algorithm")

  matrix = system._matrix

  numberOfRows = getNumOfRows(matrix)
  numberOfCols = getNumOfCols(matrix)

#  println("Number of rows: $numberOfRows")
#  println("Number of cols: $numberOfCols")

  j = 1
  while j < numberOfCols
    setMatrixValue(system._matrix, 1, j, 0.0)
    j = j + 1
  end

  i = 1
  while i < numberOfRows
    setMatrixValue(system._matrix, i, 1, 0.0)
    i = i + 1
  end

  i,j = 1, 1

  while i <= numberOfRows
    while j <= numberOfCols
      ## calculate the scores and costs for all options
            
      ## initial debug...i.e. not what it should be
      s1_curr = getNuclInSeq1(system, i)
      s2_curr = getNuclInSeq2(system, j)

      if s1_curr == s2_curr
        setMatrixValue(matrix, i, j, 6.0)
      end

      j += 1
    end

    i += 1
  end

  # drawMatrix(matrix)
  # print("\n $(drawMatrixWithNumbers(matrix))")
end

function getConsensusDNASeq(system::NaiveNWSystem)
  return putTogetherConsensusString(system)
end

function getConsensusDNASeq(system::ModifiedNWSystem)
  return putTogetherConsensusString(system)
end

##################################################################################

println("
#
# Naive-Needleman-Wunsch
# Copyright (C) 2012  Khalique Williams
#
# This file is part of Naive-Needlemann-Wunch.
#
# Naive-Needleman-Wunsch is free software: you can redistribute it and/or modify
# it under the terms of the   GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Naive-Needleman-Wunsch is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Naive-Needleman-Wunsch.  If not, see <http://www.gnu.org/licenses/>.
#
# If you wish to contact the author of Naive-Needleman-Wunsch, you may do so at
# kwillia.pub@gmail.com
#\n")

println("Naive-Needleman-Wunsch")

runHandWrittenQualitativeRecognitionTests()

const numberOfTimes = 50 # number of times to run test, taking average of summed recorded times
alignmentResults = ()


print("----------------------------------------------------------------------------------\n")
println("Creating Modified Needleman Wunsch System (PDA+NWMatrix+etc)\n")
println("\n----------------------------------------------------------------------------------")
println("Running Modified NW...\n")

# forcing the garbage collector to run
gc()

# time_start = time_ns()

theModifiedNWSystem = createModifiedNWSystem(['G','T','C'],['G','A','A','A','A','T','C'])
runNeedlemanWunsch(theModifiedNWSystem)

# time_end = time_ns()
# time_elapsed_ns = time_end - time_start
 
println("\nResults For ModifiedNW Pairwise Alignment On Data (GTC vs. GAAAATC) with CustomMatrix1")
println("  Alignment Time: (no time avail. as of yet) milliseconds")


print("----------------------------------------------------------------------------------\n")
println("Creating Naive Needleman Wunsch System (Default Matrix) (PDA+NWMatrix+etc)\n")
println("\n----------------------------------------------------------------------------------")
println("Running Naive NW...\n")

# forcing the garbage collector to run
gc()

sumOfTimes = 0
i = 0

while i < numberOfTimes

time_start = time_ns()

theNaiveNWSystem = createNaiveNWSystem(['G','T','C'],['G','A','A','A','A','T','C'])
runNeedlemanWunsch(theNaiveNWSystem, LinearGapModel())
alignmentResults = putTogetherConsensusString(theNaiveNWSystem)

time_end = time_ns()
time_elapsed_ns = time_end - time_start

sumOfTimes += time_elapsed_ns
i+= 1

end

println("\nResults For Pairwise Alignment On Data (GTC vs. GAAAATC) with DefaultMatrix")
println("  Avg Alignment Time: $((sumOfTimes/1000000)/numberOfTimes) milliseconds")
println("  DNA Alignment:\n\t$(alignmentResults[1])\n\t$(alignmentResults[2])")



print("\n----------------------------------------------------------------------------------\n")
println("Creating Naive Needleman Wunsch System (Custom Subst. Matrix 1) (PDA+NWMatrix+etc)\n")
println("\n----------------------------------------------------------------------------------")
println("Running Naive NW (Custom Subst. Matrix 1)...\n")

# forcing the garbage collector to run
gc()

sumOfTimes = 0
i = 0

while i < numberOfTimes

time_start = time_ns()

theNaiveNWSystem = createNaiveNWSystem(['G','T','C'],['G','A','A','A','A','T','C'],CustomSubstMatrix1())
runNeedlemanWunsch(theNaiveNWSystem, LinearGapModel())
alignmentResults = putTogetherConsensusString(theNaiveNWSystem)

time_end = time_ns()
time_elapsed_ns = time_end - time_start

sumOfTimes += time_elapsed_ns
i+= 1

end

println("\nResults For Pairwise Alignment On Data (GTC vs. GAAAATC) with CustomMatrix1")
println("  Avg Alignment Time: $((sumOfTimes/1000000)/numberOfTimes) milliseconds")
println("  DNA Alignment:\n\t$(alignmentResults[1])\n\t$(alignmentResults[2])")



print("\n----------------------------------------------------------------------------------\n")
println("Creating Naive Needleman Wunsch System (Custom Subst. Matrix 1) (PDA+NWMatrix+etc)\n")

println("\n----------------------------------------------------------------------------------")
println("Running Naive NW On Generated Data(Adamson-300dna, Eve-250dna)...\n")

# forcing the garbade collector to run
gc()

time_start = time_ns()

sumOfTimes = 0
i = 0
maxTime = 0
minTime = 0xffff

while i < numberOfTimes

theNaiveNWSystem = createNaiveNWSystem(
  chars("TTTAGTGCGCGCGCGCGCGCGCGCGCGCGCCCGACCTCAGCAGCAGCAGCAGCAGCAGCAGCAGCAGCACACACACACACACACACGCAACAACAACAACAACAACAGCTTATGTGCCTTGTATCTCAGTGAAGACGGCGGCGGCGGCGGCGGCGGCGGCGGCGGCGGCGGCGGCGGCGGCGGCGGCGGCGGCGGCGGCGGCGGCGGCGGCGGCGGCGGCGGCGGCGTAGAAGCCTTGCCACAGACTGCCCTACTACTACTACTACTACTACTACTACTACTACTACTACTACTACTACC"),
  chars("AGCCTCCAGCCACGCACGTCATGCCCACGCGTGGACCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCGTCAATGAGTAGTAGTAGTAGTAGTAGTAGTAGTAGTAGTGCCTCGATATTATTATTATTATTATTATTATTATTATTATTATTATTATTATTATTATTATTATTATTATTATTATTATTATTATTATTAACTTGGCCGATTAGCGAAAGTATATATATATATATATAGCCACATGTCTCTCTCTCTCTCTCTCTCTCTCAAGAAGAAGAAGAAGAAGAAA"))

runNeedlemanWunsch(theNaiveNWSystem, LinearGapModel())
alignmentResults = putTogetherConsensusString(theNaiveNWSystem)

time_end = time_ns()
time_elapsed_ns = time_end - time_start

maxTime = max(maxTime,time_elapsed_ns)
minTime = min(minTime,time_elapsed_ns)

sumOfTimes += time_elapsed_ns
i+= 1

end

println("\nResults For Pairwise Alignment On Generated Data (Adamson-300dna vs. Eve-250dna) With CustomMatrix1")
println("  Avg Alignment Time: $((sumOfTimes/1000000)/numberOfTimes) milliseconds")
println("  Highest Time: $(maxTime/1000000)")
println("  Lowest Time: $(minTime/1000000)")
println("  Avg Alignment Time Without Highest: $(((sumOfTimes - maxTime)/1000000)/(numberOfTimes-1))")
println("  Avg Alignment Time Without Highest + Lowest: $(((sumOfTimes - maxTime - minTime)/1000000)/(numberOfTimes-2))")
println("  DNA Alignment:\n\t$(alignmentResults[1])\n\t$(alignmentResults[2])")



print("\n----------------------------------------------------------------------------------\n")
println("Creating Naive Needleman Wunsch System (Custom Subst. Matrix 1) (PDA+NWMatrix+etc)\n")

println("\n----------------------------------------------------------------------------------")
println("Running Naive NW On Generated Data(Adamson-600dna, Eve-600dna)...\n")

# forcing the garbade collector to run
gc()

sumOfTimes = 0
i = 0
maxTime = 0
minTime = 0xffff

while i < numberOfTimes
 
time_start = time_ns()

theNaiveNWSystem = createNaiveNWSystem(
  chars(
    "TTGCGCGCGCGCGCGCGCGCGCGCGCAGGGTGGCCTTAGCACAACAACAACAACAACAACAGAGACGCCGCGATTTAGCACACACACACACACAACCCAGCAGCAGCAGCAGCAGCAGCAGCAGCAGCACGAACAGCTACGCTACCGGGGCCCCGAACTCCCCTAAACAAAAGTCAAAAGTGTGTCGAGTGCCACCTGTCAACGTAAGTCCACATTTTAGCAGCGGCTCCTCAATATCGGCATTTTCATAAAGCAATTACGAAAGCGCTGTTCCAGGAGCGAAACCCAATACTTCCTGAAGCCTAAGAGTTACATCTATGTTTTTGTCAACCGGCCAGGGTTAACGCACTCCATATGCTCGTATAGAACGCCGTCTGATGACGAACTCTTTATGGATAAAACTTAAGCAATCACAAGTCTTGCTGCATCGCCCTAAGACCCTAGAGGGGAGGCTGATAGCGGCGGCGGCGGCGGCGGCGGCGGCGGCGGCGGCGGCGGCGGCGGCGGCGGCGGCGGCGGCGGCGGCGGCGGCGGCGGCGGCGGCGGCGGCGACTACTACTACTACTACTACTACTACTACTACTACTACTACTACTATCT"
  ),
  chars(
    "TCTTTTGGGTCTACGTTGTCCGAGTGCGCGTATATTATTATTATTATTATTATTATTATTATTATTATTATTATTATTATTATTATTATTATTATTATTATTATTATTATTATTACCTGTCTGCTATTAACTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTGGTCTAGGGGGTGTTCTCCCGGGGGTGGTTGAGCTGTCACGTGTCCACCGAGGAGCCGGGTATGGATCTAAGAAGAAGAAGAAGAAGAAATGATGTACGAGTCGTTTTCGAAACGTGATTGGCACGTCGATTGTCTGTAAACTCGGTAGCTCAAGCACTGTAGTAGTAGTAGTAGTAGTAGTAGTAGTAGTAATAGTCTGTATTGAACTCGTCTATATATATATATATATAGTCTAAGCCCTGGAGCGCCGCGGCCTGCATGGCGATCAATTTTACATGTTTAGTCTCTCTCTCTCTCTCTCTCTCTCAAAGATGTAAGACGCGACATACAGGCAATACACGAGTGAGAGAAGCGACTAGGTAGAGGATAGACTCCAC"
  ))

runNeedlemanWunsch(theNaiveNWSystem, LinearGapModel())
alignmentResults = putTogetherConsensusString(theNaiveNWSystem)

time_end = time_ns()
time_elapsed_ns = time_end - time_start

maxTime = max(maxTime,time_elapsed_ns)
minTime = min(minTime,time_elapsed_ns)

sumOfTimes += time_elapsed_ns

i += 1

end



println("\nResults For Pairwise Alignment On Generated Data (Adamson-600dna vs. Eve-600dna) With CustomMatrix1")
println("  Avg Alignment Time: $((sumOfTimes/1000000)/numberOfTimes) milliseconds")
println("  Highest Time: $(maxTime/1000000)")
println("  Lowest Time: $(minTime/1000000)")
println("  Avg Alignment Time Without Highest: $(((sumOfTimes - maxTime)/1000000)/(numberOfTimes-1))")
println("  Avg Alignment Time Without Highest + Lowest: $(((sumOfTimes - maxTime - minTime)/1000000)/(numberOfTimes-2))")
println("  DNA Alignment:\n\t$(alignmentResults[1])\n\t$(alignmentResults[2])")

testDefaultScoring()

# testRecognitionStackDataMap()
