#
# Naive-Needleman-Wunsch
# Copyright (C) 2012  Khalique Williams
#
# This file is part of Naive-Needlemann-Wunch.
#
# Naive-Needleman-Wunsch is free software: you can redistribute it and/or modify
# it under the terms of the   GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Naive-Needleman-Wunsch is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Naive-Needleman-Wunsch.  If not, see <http://www.gnu.org/licenses/>.
#
# If you wish to contact the author of Naive-Needleman-Wunsch, you may do so at
# kwillia.pub@gmail.com
#

#finds 6-mer of most likely upregulating promotor from data.
# data consists of two sets of sequences identifying regions around binding sites,
# the first known to be a list of positive promotors, while second being list of neg.
#  -- method: find starting points for 6-tuples amoung each sequence
#             to construct alignment matrix. From alignment matrix construct profile
#             matrix. From profile matrix (representing variability of nucleotide
#             composition at each point of a particular choice of l-mers (6-mers here))
#             we choose consensus l-mer (the consensus string) representing
#             most represented nucleotide.
#             The score of each consens l-mer is the summation of the magnitudes 
#             representing the most frequence nucleotide in each column.
#             In other words, for each nucleotide in string, take sum of the numbers
#             that led us to choose that particular nucleotide.

#       eg: for t sequences S_1 .. S_t
#               l-mer(S_1) ATCCAGCT
#               l-mer(S_2) GGGCAACT
#               l-mer(S_3) ATGGATCT
#                   ..       ...
#               l-mer(S_t) ATGGCACT
#                       ||
#                       \/
#                partial alignment matrix
#                       ||
#                       \/
#                partial profile matrix             
#            j= 1 2 3 4 5 6 7 l=8
#               - - - - - - - -
#         i= A |5 1 0 0 5 5 0 0
#            G |1 7 0 0 0 1 1 6
#            C |1 1 6 3 0 1 0 0
#            T |0 0 1 4 2 0 6 -
#          
#               A T G C A A C T

type LMer
    _data::Array{Char}
end

function createLMer(data::Array{Char})
    return LMer(data)
end

type BestLMer
    _lmer::LMer
end

function createEmptyLMer()
    return LMer([' '])
end

function createBestLMer(lmer::LMer)
    return BestLMer(lmer)
end

function createBestLMer(lmerArray::Array{Char})
    return BestLMer(LMer(lmerArray))
end

function createEmptyBestLMer()
    return createBestLMer(createEmptyLMer())
end

type SequenceAndPartialProfileMatrix
     _seq::Array{Char}

    # best profile contribution is mapping of both sequence number {i|1<=i<=t}, and nucleotide base {'A'|'C'|'G'|'T'}
    _bestProfileContributions::Dict{Any,Any} #this is set in algorithm

    # best l-mer(6-mer) for sequence i that contributes to the profile matrix, actually the value is an array since there are
    #  multiple permations hat may maximize the value in A, but may or may not maximize the value in others.
    #    ** but we worry about that after all the 'candidate' lmers for a given sequence have been compiled (again here only
    #        the lmers that contributes to best score for nucleotide (eg. for just A or just for B)
    _bestlmers::Dict{Any,Any} #This will be set in algorithm. All high scoring values will the same profile contribution
end

function getBestPartialProfileScore(sppm::SequenceAndPartialProfileMatrix, seq_number::Int64, nucleotide::Char)
    return get(sppm._bestProfileContributions, (seq_number, nucleotide), -1)
end

function getBestScoringProfileLMers(sppm::SequenceAndPartialProfileMatrix, seq_number::Int64, nucleotide::Char)
    println("called getBestScoringProfileLMers")
    ret = get(sppm._bestlmers, (seq_number,nucleotide),[createEmptyBestLMer()])
    return ret 
end
#a homologous function to the above
function getBestLMers(sppm::SequenceAndPartialProfileMatrix, seq_number::Int64, nucleotide::Char)
    return getBestScoringProfileLMers(sppm,seq_number,nucleotide)
end

#resets the score, and resets aswell the associated list of l-mers to empty list
function resetBestProfileContribution(sppm::SequenceAndPartialProfileMatrix, seq_number::Int64, nucleotide::Char, newScore::Int64, newBestLMer::BestLMer)
    if has(sppm._bestProfileContributions, (seq_number,nucleotide))
        del(sppm._bestProfileContributions,(seq_number, nucleotide))
    end
    merge!(sppm._bestProfileContributions, {(seq_number,nucleotide)=>newScore})

    if has(sppm._bestlmers,(seq_number,nucleotide))
        del(sppm._bestlmers,(seq_number,nucleotide))
    end
    merge!(sppm._bestlmers,{(seq_number,nucleotide)=>[newBestLMer]})
end

function addToBestLMers(sppm::SequenceAndPartialProfileMatrix,seq_number::Int64,nucleotide::Char,lmer::BestLMer)
    if !has(sppm._bestlmers,(seq_number,nucleotide))
        existingBestLMers = getBestLMers(sppm,seq_number,nucleotide)
        push(existingBestLMers,lmer)
    else
        merge!(sppm._bestlmers, {(seq_number,nucleotide)=>[lmer]})
    end
end


function createSPPM(seq::Array{Char})
    initBestPartialProfileScores = {(-1,'A')=>0,(-1,'C')=>0,(-1,'G')=>0,(-1,'T')=>0}
    initBestScoringLMers = {(-1,'A')=>[createEmptyBestLMer()],(-1,'C')=>[createEmptyBestLMer()],(-1,'G')=>[createEmptyBestLMer()],(-1,'T')=>[createEmptyBestLMer()]} 

    ret = SequenceAndPartialProfileMatrix(seq, initBestPartialProfileScores, initBestScoringLMers)
    del_all(ret._bestlmers)

    return ret
end

abstract Node

# scheme for tree: S1->S2->...->S_t

#                                 
#
#                 S1_1 ... ... S2_numOfBestTuplesForA
#                    
#                  / \         / \
#             S2_c .. S2_c  S2_c .. S2_c
#              / \     ..\   /..    / \
#          S3_g..S3_g    .. .. S3_g..S3_g     
#              .  .    .        .   .  .
#           . ..  .. .  .     .  . ..  .. .
#       .. .. ..  .. .. ..   .. .. ..  .. .. ..
#         /\              /\              /\            
#     S10_1..S10_j .. S10_1..S10_j .. S10_1..S10_j
#                                                     <- leaves are the solution
#     BEWARE - I lose my understanding of how this works every 10 mins(sad, but true -- still this could be wrong)
#       we have the PARTIAL scores for A, meaning that 
#        the highest values
abstract TreeType

type LeafNode
end
 
type RootNode
end

type InternalNode
end

type EmptyTreeNode <: Node
end

function createEmptyTreeNodeArray()
    retArray = [EmptyTreeNode()]
    del_all(retArray)

    return retArray
end

type TreeNode <: Node
    _type::TreeType

    _seqId::Int64
    _lmer::BestLMer
    _children::Array{Node} # pointers to nodes
end

function createRoot()
    root = TreeNode(RootNode(),createEmptyLMer(),[createEmptyLMer()])
    del_all(root._children)
end

function addChildToRoot(root::TreeNode, child::TreeNode)
    push(root._children,child)
end

function isLeaf(node::TreeNode)
    if isa(typeof(node),Type{LeafNode})
        return true
    else
        return false
    end
end

function isRoot(node::TreeNode)
    if isa(typeof(node),Type{RootNode})
        return true
    else
        return false
    end
end

function isInternalNode(node::treeNode)
    if isa(typeof(node),Type{InternalNode})
        return true
    else
        return false
    end
end

function convertToTreeNodes(lmers::Array{BestLMer})
    nodeArray = emptyEmptyTreeNodeArray()

    for anLMer in lmers
        push(nodeArray,TreeNode(false,anLMer,createEmptyTreeNodeArray())
    end

    return nodeArray
end

function createLeafNode(seqNumber::Int64, bestLMer::BestLMer)
    node = TreeNode(LeafNode(),bestLMer,createEmptyTreeNodeArray())

    print("{")
    print(seqNumber)
    print(",")
    print(node._lmer)
    print(",")
    print(node._type)
    println("}")

    return node
end

function createInternalTreeNode(seqNumber::Int64, bestLMer::BestLMer, childBestLMerArray::Array{BestLMer})
    # do conversion to make array of nodes from
    if length(childBestLMerArray) == 0
        error("Internal Tree Node must be created with children")
    end

    childNodes = convertToTreeNodes(childBestLMerArray)    

    node = TreeNode(InternalNode(),bestLMer,childBestLMerArray)

    print("{")
    print(seqNumber)
    print(",")
    print(node._lmer)
    print(",")
    print(node._type)
    println("}")
 
    return node
end

# in construction of nodes, best to go bottom up: 
#   1) construct leaves s10_1 ... s10_n10
#   2) construct nodes that point directly to s10's, s9's (s9_1,s9_2....s9_n9) each pointing to each of s10's
#   3) until s_1's are created return them as array
# so input needs access to all sequences, and outputs array of s1's as nodes                                          

#I've never actually made an algorithm so lazily(re:abhorrentky)- structure, we're push some boundries here!
function constructTree(sppm::SequenceAndPartialProfileMatrix)
    # for each best we slap down one of a short sighted choice.
    #  e.g n_1: start with best of A
    #       Bam! Best of C-> follow {Don't slap down A}
    #       Bam! Best of G-> follow {Don't slap down A}
    #       Bam! Best of T-> follow {Don't slap down A}
    #                                                   n_k: with any best(including start) of C{list of evaluated nucleotides}
    #                                                      Bam! Best of A -> follow A (unless already Evaluated) | {Dont S.D. C}
    #                                                      Bam! Best of G           . . .                        |     . . . 
    #                                                      Bam! Best of C           . . .                        |     . . .
    #                                                      Bam! Best of T           . . .                        |     . . .
    #                    n_k+j:    . . . 
    #                              . . .
    #                

    lastIndexOfSequence = length(sppm._seq)
    
    bestLMersForChildrenNodes = sppm._seq[lastIndexOfSequence]._bestLMers
    for bestLMer in bestLMersForChildrenNodes
        push(childrenNodes,createLeafNode(lastIndexOfSequence,bestLMer))
    end

    for i=(lastIndexOfSequence-1):1
        #for this one we need to pick a nucletide to maximize that hasn't been already
    end
end

# given root we exhaustively go through to all leaves, keeping only the one(s) producing best score
function findBestLmerCombo(root::TreeNode)
    
end

function doWork()
    positivePromotorFile = open("promotorPositive.fa","r")

    positivePromotorLines = readlines(positivePromotorFile)

    maxLengthOfPositivePromotorSeq = 0
    #convert input promotor sequences to array of characters, and place into array of seq.
    positivePromotorSequences = [createSPPM([' '])]
    del_all(positivePromotorSequences)

    for line in positivePromotorLines
        if !begins_with(line,'>')
            lengthOfPositivePromotorSeq = length(line)

            if (lengthOfPositivePromotorSeq > maxLengthOfPositivePromotorSeq)
                maxLengthOfPositivePromotorSeq = lengthOfPositivePromotorSeq
            end
            push(positivePromotorSequences, createSPPM(chars(line)))
        end
    end

    print("Max length of positive promotor sequence: ")
    println(maxLengthOfPositivePromotorSeq)

    #now sequentially pick frames of 6 beginning from 1 to size of promotor sequences
    #and run algorithm
    t = length(positivePromotorSequences)
    print("t=")
    println(t)
    l = 6

    for i=1:t
        sequenceAndPartialProfileMatrix = positivePromotorSequences[i]

        characterArray = sequenceAndPartialProfileMatrix._seq
        print("Character array: ")
        println(characterArray)

        print("i=")
        println(i)

        lengthOfCharacterArray = length(characterArray)
        #try out every start position for l-mer
        for k=1:(lengthOfCharacterArray - l - 1)
            startOflmer = k
            lastIndexOflmer = startOflmer + l - 1

            print("i=")
            print(i)
            print(", k=")
            println(k)

            alignmentMatrix = [' ']
            del_all(alignmentMatrix)
            for j=startOflmer:lastIndexOflmer
                push(alignmentMatrix,characterArray[j])
            end

            print("Alignment matrix")
            println(alignmentMatrix)

            currentLMerScoreForNucl = { 'A'=>0,'C'=>0,'G'=>0,'T'=>0}

            # So we here calculate the single portions of the "best profile matrix" we can find
            #  that is, the portions of the entry that this lmer would(ideally) contribute to
            #  for each individual nucleotide.
            #      fancy way of saying: yeah y=here we're just gonna exclude all the non contributing tuples for a particular
            #      nucleotide.  After we've done that, we can merge the set of lmers that each sequence generates that suffices
            #      accross ALL solutions all solutions noting that if we don't add one solution to the list for a specific
            #      nucleotide (technically it was ALWAYS be represented in another solution -- therefore its either that there
            #      is a unique solution or there a multitude of solutions. Technically it doesn't matter. And technically our
            #      algorithm would have a higher running time if there were a multitude. The multitude only matters when we 
            #      think of the branching facto and full consensus calculations.
            #        so think of it like this, in maximizing jth column: we may not be left with many other choices for the
            #        other values of j, similar logic trickles down. Then we save those multitude of solutions at the end of that
            #        cycle we SAVE ONE value. Then move on to maximizing j+1th until we get through to j=6.  At that point
            #        we have 6 different points of view, where we assumed that the jth column had the highest score. All but
            #        one of these assumptions are wrong.
            for j=1:l
                if alignmentMatrix[j] == 'A'
                    oldVal = get(currentLMerScoreForNucl, 'A', 'X')
                    
                    if (oldVal == 'X')
                        error("currentLMerScoreForNucl dictionary SHOULD have a value")
                    else
                        del(currentLMerScoreForNucl,'A')
                        merge!(currentLMerScoreForNucl, {'A'=>(1)})
                    end
                end
                if alignmentMatrix[j] == 'C'
                    oldVal = get(currentLMerScoreForNucl, 'C', 'X')

                    if (oldVal == 'X')
                        error("currentLMerScoreForNucl dictionary SHOULD have a value")
                    else
                        del(currentLMerScoreForNucl,'C')
                        merge!(currentLMerScoreForNucl,{'C'=>(1)})
                    end
                end
                if alignmentMatrix[j] == 'G'
                    oldVal = get(currentLMerScoreForNucl, 'G', 'X')

                    if (oldVal == 'X')
                        error("currentLMerScoreForNucl dictionary SHOULD have a value")
                    else
                        del(currentLMerScoreForNucl,'G')
                        merge!(currentLMerScoreForNucl,{'G'=>(1)})
                    end
                end
                if alignmentMatrix[j] == 'T'
                    oldVal = get(currentLMerScoreForNucl, 'T', 'X')

                    if (oldVal == 'X')
                        error("currentLMerScoreForNucl dictionary SHOULD have a value")
                    else
                        del(currentLMerScoreForNucl,'T')
                        merge!(currentLMerScoreForNucl,{'T'=>(1)})
                    end
                end
            end

            # NEW calculate the totals amoung the colums for each: A, C, G, T individually
            #  if that tuple happens to be a high fo that nucleotide, record it in the approriate index list (we may record same
            #  multiple times (ACCROSS) indices) but not in the same indice.

            for nucleotide in ['A','C','G','T']
                bestPartialScore = getBestPartialProfileScore(sequenceAndPartialProfileMatrix,i,nucleotide)
                currentPartialScoreForNucl = get(currentLMerScoreForNucl,nucleotide,-1)

                if bestPartialScore < currentPartialScoreForNucl
                    # Old best score and corresponding l-mers are invalidated, and new best score is set along with
                    #  the l-mer that produced it

                    newBestLMerForNucl = createBestLMer(alignmentMatrix)
                    resetBestProfileContribution(sequenceAndPartialProfileMatrix,i,nucleotide,currentPartialScoreForNucl,newBestLMerForNucl)
                    print("-- ReplacedBestMatrixRow with l-mer:")
                    print((nucleotide,newBestLMerForNucl))
                    print(" with a score = ")
                    println(get(currentLMerScoreForNucl,nucleotide,-1))
                elseif bestPartialScore == currentPartialScoreForNucl
                    print("-- Tied Best Profile Contribution for S_")
                    print(i)
                    print(" --")

                    # Check best results to see if this l-mer doesn't match character for character (in direct sequence)
                    #  with another l-mer (from the same sequence S_i) already in bestResults
    
                    isUniqueForAll = true
                   
                    for aBestLmer in getBestLMers(sequenceAndPartialProfileMatrix,i,nucleotide)
                        theLMerOfABestLMer = aBestLmer._lmer
                        isUniqueToThisOne = false
                        for aCharacter::Char in theLMerOfABestLMer._data, currLmerCharacter::Char in alignmentMatrix
                            if aCharacter != currLmerCharacter
                                isUniqueToThisOne = true
                                break
                            end
                        end
                  
                        # Being unique to just ONE of the lmers in the collection alredy in 
                        #  bestLMers is not enough, it must be unique to them ALL

                        if isUniqueForAll && !isUniqueToThisOne
                            isUniqueForAll = false
                            break
                        end
                    end

                    # if this new sequence is NOT in best results, put it in best results
                    if isUniqueForAll
                        addToBestLMers(sequenceAndPartialProfileMatrix,i,nucleotide,createBestLMer(alignmentMatrix))

                        print("-- l-tuple is a unique lmer that produces the best partial score for nucleotide'")
                        print(nucleotide)
                        print("' with lmer: ")
                        print(alignmentMatrix)
                        print("is a unique lmer that produces best score = ")
                        println(get(currentLMerScoreForNucl,nucleotide,-1))
                    end
                end
            end
        end

        for nucleotide in ['A','C','G','T']
            print("Best score for ")
            print(nucleotide)
            print(" is ")
            println(getBestPartialProfileScore(sequenceAndPartialProfileMatrix,i,nucleotide))
        end
    end

     println("\n")

    # the result of this is that we have the most likely solutions to 

    for i=1:10
        print("Sequence_")
        print(i)
        println(":")
        for nucleotide in ['A','C','G','T']
            print("\tBest score for ")
            print(nucleotide)
            print(" is ")
            println(getBestPartialProfileScore(positivePromotorSequences[i],i,nucleotide))
        end
    end

    # construct a tree structure with nodes for all varying amount choices
    #treeNodes = convertToTreeNodes(positivePromotorSequences[i]::SequenceAndPartialProfileMatrix)
    #root = constructTree(treeNodes)
end


doWork()
