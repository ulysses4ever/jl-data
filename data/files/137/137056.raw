#
# Naive-Needleman-Wunsch
# Copyright (C) 2012  Khalique Williams
#
# This file is part of Naive-Needlemann-Wunch.
#
# Naive-Needleman-Wunsch is free software: you can redistribute it and/or modify
# it under the terms of the   GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Naive-Needleman-Wunsch is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Naive-Needleman-Wunsch.  If not, see <http://www.gnu.org/licenses/>.
#
# If you wish to contact the author of Naive-Needleman-Wunsch, you may do so at
# kwillia.pub@gmail.com
#

#finds 6-mer of most likely upregulating promotor from data.
# data consists of two sets of sequences identifying regions around binding sites,
# the first known to be a list of positive promotors, while second being list of neg.
#  -- method: find starting points for 6-tuples amoung each sequence
#             to construct alignment matrix. From alignment matrix construct profile
#             matrix. From profile matrix (representing variability of nucleotide
#             composition at each point of a particular choice of l-mers (6-mers here))
#             we choose consensus l-mer (the consensus string) representing
#             most represented nucleotide.
#             The score of each consens l-mer is the summation of the magnitudes 
#             representing the most frequence nucleotide in each column.
#             In other words, for each nucleotide in string, take sum of the numbers
#             that led us to choose that particular nucleotide.

#       eg: for t sequences S_1 .. S_t
#               l-mer(S_1) ATCCAGCT
#               l-mer(S_2) GGGCAACT
#               l-mer(S_3) ATGGATCT
#                   ..       ...
#               l-mer(S_t) ATGGCACT
#                       ||
#                       \/
#                partial alignment matrix
#                       ||
#                       \/
#                partial profile matrix             
#            j= 1 2 3 4 5 6 7 l=8
#               - - - - - - - -
#         i= A |5 1 0 0 5 5 0 0
#            G |1 7 0 0 0 1 1 6
#            C |1 1 6 3 0 1 0 0
#            T |0 0 1 4 2 0 6 -
#          
#               A T G C A A C T

type LMer
    _data::Array{Char}
end

type BestLMer
    _lmer::LMer
end

function createEmptyLMer()
    return LMer([' '])
end

function createBestLMer(lmer::LMer)
    return BestLMer(lmer)
end

function createEmptyBestLMer()
    return createBestLMer(createEmptyLMer())
end

type SequenceAndPartialProfileMatrix
     _seq::Array{Char}

    # best profile contribution is mapping of both sequence number {i|1<=i<=t}, and nucleotide base {'A'|'C'|'G'|'T'}
    _bestProfileContributions::Dict{(Int64, Char),Int64} #this is set in algorithm

    # best l-mer(6-mer) for sequence i that contributes to the profile matrix, actually the value is an array since there are
    #  multiple permations hat may maximize the value in A, but may or may not maximize the value in others.
    #    ** but we worry about that after all the 'candidate' lmers for a given sequence have been compiled (again here only
    #        the lmers that contributes to best score for nucleotide (eg. for just A or just for B)
    _bestlmers::Dict{(Int64,Char),Any} #This will be set in algorithm. All high scoring values will the same profile contribution
end

function getBestProfileScore(sppm::SequenceAndPartialMatrix, seq_number::Int64, nucleotide::Char)
    return get(sppm._bestProfileContributions, (seq_number, nucleotide), ' ')
end

function getBestScoringProfileLMers(sppm::SequenceAndPartialMatrix, seq_number::Int64, nucleotide::Char)
    return get(sppm._bestProfileContributions, (seq_number, nucleotide), [createBestLMer(createEmptyLMer))])
end
//a homologous function to the above
function getBestLMers(sppm::SequenceAndPartialMatrix, seq_number::Int64, nucleotide::Char)
    return getBestScoringProfileLMers(sppm,seq_number,nucleotide)
end

#resets the score, and resets aswell the associated list of l-mers to empty list
function resetBestProfileContribution(sppm::SequenceAndPartialMatrix, seq_number::Int64, nucleotide::Char, newScore::Int64, newBestLMer::BestLMer)
    del(sppm._bestProfileContributions,(seq_number, nucleotide))
    merge!(sppm._bestProfileContribution, {(seq_number,nucleotide)=>newScore})

    if has(sppm._bestProfileContributions,(seq_number,nucleotide))
        del(sppm._bestProfileContributions,(seq_number,nucleotide))
        
    end
end

function addToBestLMers((sppm::SequenceAndPartialMatrix,seq_number::Int64,nucleotide::Char,lmer::BestLMer)
    if !has(sppm._bestlmers,(seq_number,nucleotide))
        existingBestLMers = getBestLMers(sppm,seq_number,nucleotide)
        push(existingBestLMers,lmer)
    else
        merge!(sppm._bestProfileContributions, {(seq_number,nucleotide)=>[lmer]})
    end
end

# todo:will, create createEmptyBestLMer or createEmptyLMer to make code less clunky below (where its hard to debug)
# todo:will, create resetElemerArray, and maybe addFirstFirstLMer, or reinitializeWithBestLMer

function createSPPM(seq::Array{Char})
    ret = SequenceAndPartialProfileMatrix(seq, {'A'=>0,'C'=>0,'G'=>0, 'T'=>0}, {'A'=>[createEmptyLMer()],'C'=>[createEmptyLMer()], 'G'=>[createEmptyLMer()], 'T'=>[createEmptyLMer()]})
    del_all(ret._bestlmers)

    return ret
end

function doWork()
    positivePromotorFile = open("promotorPositive.fa","r")

    positivePromotorLines = readlines(positivePromotorFile)

    maxLengthOfPositivePromotorSeq = 0
    #convert input promotor sequences to array of characters, and place into array of seq.
    positivePromotorSequences = [createSPPM([' '])]
    del_all(positivePromotorSequences)

    for line in positivePromotorLines
        if !begins_with(line,'>')
            lengthOfPositivePromotorSeq = length(line)

            if (lengthOfPositivePromotorSeq > maxLengthOfPositivePromotorSeq)
                maxLengthOfPositivePromotorSeq = lengthOfPositivePromotorSeq
            end
            push(positivePromotorSequences, createSPPM(chars(line)))
        end
    end

    print("Max length of positive promotor sequence: ")
    println(maxLengthOfPositivePromotorSeq)

    #now sequentially pick frames of 6 beginning from 1 to size of promotor sequences
    #and run algorithm
    t = length(positivePromotorSequences)
    print("t=")
    println(t)
    l = 6

    for i=1:t
        println("wooot")

        sequenceAndPartialProfileMatrix = positivePromotorSequences[i]

        println("wooot")
        characterArray = sequenceAndPartialProfileMatrix._seq
        print("Character array: ")
        println(characterArray)

        print("i=")
        println(i)

        lengthOfCharacterArray = length(characterArray)
        #try out every start position for l-mer
        for k=1:(lengthOfCharacterArray - l - 1)
            startOflmer = k
            lastIndexOflmer = startOflmer + l - 1

            print("i=")
            print(i)
            print(", k=")
            println(k)

            alignmentMatrix = ['a']
            del_all(alignmentMatrix)
            for j=startOflmer:lastIndexOflmer
                push(alignmentMatrix,characterArray[j])
            end

            print("Alignment matrix")
            println(alignmentMatrix)

            #so here calculate portion owing to some desired profile matrix
            #that this tuple would contribute to
            profileMatrixRow = [0,0,0,0]

            for j=1:l
                if alignmentMatrix[j] == 'A'
                   profileMatrixRow[1] = profileMatrixRow[1]+1
               end
               if alignmentMatrix[j] == 'C'
                   profileMatrixRow[2] = profileMatrixRow[2]+1
               end
               if alignmentMatrix[j] == 'G'
                   profileMatrixRow[3] = profileMatrixRow[3]+1
               end
               if alignmentMatrix[j] == 'T'
                   profileMatrixRow[4] = profileMatrixRow[4]+1
               end
            end

            #new, calculate the totals amoung the colums for each: A, C, G, T individually
            #if that tuple happens to be a high fo that nucleotide, record it in the approriate index list (we may record same
            #multiple times (ACCROSS) indices) but not in the same indice.


            currentlmerScore = { 'A'=>profileMatrixRow[1],'C'=>profileMatrixRow[2],'G'=>profileMatrixRow[3],'T'=>profileMatrixRow[4]}
 
            for nucleotide in ['A','C','G','T']
            bestScore = get(sequenceAndPartialProfileMatrix._bestProfileContribution,nucleotide,-1)
            typeof(bestScore)
            if bestScore < get(currentlmerScore,nucleotide,-1)
                del(sequenceAndPartialProfileMatrix._bestProfileContribution,nucleotide)

                merge!(sequenceAndPartialProfileMatrix._bestProfileContribution,{nucleotide=>get(currentlmerScore,nucleotide,-1)})
                del_all(get(sequenceAndPartialProfileMatrix._bestlmers,nucleotide,[]))
                push(get(sequenceAndPartialProfileMatrix._bestlmers,nucleotide,[BestLMer([' '])]),BestLMer(alignmentMatrix))
                print("-- ReplacedBestMatrixRow")
                print(nucleotide)
                println(get(currentlmerScore,nucleotide,-1))
            elseif bestScore == get(currentlmerScore,nucleotide,-1)
                # we might have to compile a list of possible choices
                print("-- Tied Best Profile Contribution for S_")
                print(i)
                print(" --")

                # check best results to see if this l-mer doesn't match character for character (in direct sequence)
                # with an l-mer already in bestResults
    
                isUniqueForAll = true
                for aBestLmer in get(sequenceAndPartialProfileMatrix._bestlmers,nucleotide,[BestLMer([' '])])
                    isUnique = false
                    for aCharacter in aBestLmer._lmer, currLmerCharacter in alignmentMatrix
                        if aCharacter != currLmerCharacter
                            isUnique = true
                        end
                    end

                    isUniqueForAll = isUniqueForAll && isUnique
                    if !isUniqueForAll
                        break
                    end
                end

                # if this new sequence is NOT in best results, put it in best results
                if isUniqueForAll
                    print("Found unique best match ")
                    print(length(get(sequenceAndPartialProfileMatrix._bestlmers,nucleotide,[BestLMer([' '])]))+1)
                    print(" for score: ")
                    println(get(currentlmerScore,nucleotide,-1))

                    push(get(sequenceAndPartialProfileMatrix._bestlmers,nucleotide,[BestLMer([' '])]),BestLMer(alignmentMatrix))
                end
            end
        end
    end
end
end


doWork()
