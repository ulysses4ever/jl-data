module lexer
include("tools.jl")
include("numbers.jl")

"""
Contains the regexes to use in legacy mode
"""
legacy_regexes = Dict{AbstractString, Regex}(
    "string" => r"'(^'|'')*'",
    "item" => r".+[\.:]+|[^\w][\.:]+",
    "name" => r"[A-Za-z][\w\d]*",
    "number" => r"[\d_]([\w\d]*(\s*[\d_])?)+",
    "paren" => r"[()]",
)

"""
Contains the regexes to use in non-legacy mode
"""
regexes = Dict{AbstractString, Regex}(
    "string" => r"'([^']|\.)*'",
    "multistring" => r"'''.*?'''", # The ? is lazy matching
    "item" => r"[^()']+[\.:]+|[^\w()'][\.:]*",
    "name" => r"[^!-@\[-`{-~\s][^!-/:-@\[-`{-~]", #Supports unicode
    "number" => r"[\d_]([\w\d]*(\s*[\d_])?)+",
    "paren" => r"[()]",
)

"""
A convenience dict to ease the selection of the regex dict to use (legacy vs
non-legacy)
"""
regex_meta_dict = Dict{Bool, Dict{AbstractString, Regex}}(
    true => legacy_regexes,
    false => regexes
)

"""
Contains the characters that are used as escapes
"""
escape_chars = Dict{Bool, Char}(
    true => '\'',
    false => '\\'
)

"""
Contains the escapes to use in legacy mode (should be only "'" => "'")
"""
legacy_escapes = Dict{Char, Char}(
    '\'' => '\''
)

"""
Contains the escapes to use in non-legacy mode.
"""
escapes = Dict{Char, Char}(
    '\\' => '\\',
    'n' => '\n',
    '\'' => '\'',
    '0' => '\0'
)

"""
Helper dict to decide which escape dict to use in a nicer way.
"""
escape_dicts = Dict{Bool, Dict{Char, Char}}(
    true => legacy_escapes,
    false => escapes
)

"""
Runs on strings without surrounding quotes, and produces the escaped version of
that string.
"""
function stripped_string_parser(to_parse::AbstractString, legacy::Bool=false)
    quote_char = '\''

    return_vector = Vector{Char}()
    escaped = false
    escape_char = escape_chars[legacy]
    escape_dict = escape_dicts[legacy]

    for i in to_parse
        if !escaped
            if i == escape_char
                escaped = true
            elseif i == quote_char
                raise("Unescaped quote found in string $to_parse", 0)
            else
                push!(return_vector, i)
            end
        else
            push!(return_vector, escape_dict[i])
            escaped = false
        end
    end

    if escaped
        raise("Escape char at last place of string. $to_parse", 0)
    end

    return_vector
end

"""
Takes the number of quotes to use, removes them (if this is possible, raises
an exception otherwise.) Then the resulting string is passed to
stripped_string_parser
"""
function generic_string_parser(to_parse::AbstractString,
    number_of_quotes::Integer, parser_name::AbstractString, legacy::Bool=false)
    if match(regex_meta_dict[legacy][parser_name], to_parse) === nothing
        raise(
            "Trying to parse invalid string: " *
            "$to_parse (does not match regex)", 0
        )
    end

    inner_string = to_parse[1 + number_of_quotes:end - number_of_quotes]
    stripped_string_parser(inner_string, legacy)
end

"""
Takes a string and passes it to generic_string_parser with the correct settings
"""
function string_parser(to_parse::AbstractString, legacy::Bool=false)
    generic_string_parser(to_parse, 1, "string", legacy)
end

"""
Takes a string and passes it to generic_string_parser with the correct settings
"""
function multistring_parser(to_parse::AbstractString, legacy::Bool=false)
    if legacy
        raise("You did not intend to use multistring_parser in legacy mode." *
              "(If you think otherwise, you are wrong; plain wrong.)", 0)
    end
    generic_string_parser(to_parse, 3, "multistring", legacy)
end
end
