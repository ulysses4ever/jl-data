module numbers
include("tools.jl")

base_alphabet = join('0':'9') * join('a':'z')

function convert_int_base(base, expression)
    expression = map(search, repeated(base_alphabet), expression) - 1
    if base == 1
        sum(expression)
    else
        l = length(expression)
        sum(expression .* (base .^ collect(range(l-1, -1, l))))
    end
end

function convert_base(base, expression)
    if base == 0
        search(base_alphabet, expression[end]) - 1
    else
        count_decimal_points = count_number(expression, '.')
        if count_decimal_points == 1
            before, after = split(expression, '.', limit=2, keep=true)
            +(
                convert_int_base(base, before),
                convert_int_base(base, after) * 10.0 ^ -length(after)
            )
        elseif count_decimal_points == 0
            convert_int_base(base, expression)
        else
            raise("More than 1 decimal point in expression $expression", 0)
        end
    end
end


exponents = Dict{Char, Number}(
# TODO: implement a legacy version of this  dict
# Number instead of Real because imaginary exponents are not unfeasible
    'x' => e,
    'p' => π,
    'π' => π,
    'e' => 10,
    'E' => 10
)

function handle_exponent(to_parse::AbstractString, legacy::Bool=false)
    for key in keys(exponents)
        if count_number(to_parse, key) == 1
            factor, exponent = map(
                number_parser,
                split(to_parse, key, limit=2, keep=true)
            )
            base = exponents[key]
            return factor * base ^ exponent
        end
    end
    raise("Wrong number of exponents in (part of) number: $to_parse", 1)
end

function handle_base(to_parse::AbstractString, legacy::Bool=false)
    base, expression = split(to_parse, 'b', limit=2, keep=true)
    base = number_parser(base)
    if !legacy
        expression = lowercase(expression)
        if base <= 1
            raise(
                "Using a base <= 1 can have (yet completely predictable, no " *
                "randomness involved) unexpected results. If you want a " *
                "negative expression in a certain base, use " *
                "(base)b_(number) instead. So: _16bff becomes 16b_ff.", 1
            )
        end
    end
    convert_base(base, expression)
end

function handle_bignum(to_parse::AbstractString, legacy::Bool=false)
    stripped = to_parse[1:end-1]
    if stripped == "_"
        BigFloat(Inf)
    else
        parse('.' ∈ stripped ? BigFloat : BigInt, stripped)
    end
end

function handle_frac(to_parse::AbstractString, legacy::Bool=false)
    #TODO: what were the names for top and bottom of a fraction again?
    top, bottom = map(number_parser, split(to_parse, 'r'))
    top // bottom
end

postfixes = ['x', 'p', 'π']

downgrades = Dict{DataType, DataType}(
    AbstractFloat => Int,
    Integer => Bool,
    BigInt => BigInt,
    BigFloat => BigFloat
    # BigInt and BigFloat are here, because BigInt <: Integer and BigFloat <:
    # AbstractFloat
)

function downgrade{from <: Number}(parsed::from)
    current = from
    while current <: Number
        if current ∈ keys(downgrades) && downgrades[current] !== typeof(parsed)
            try
                parsed = downgrades[current](parsed)
            catch InexactError
                break
            end
            current = typeof(parsed)
        else
            current = super(current)
        end
    end
    parsed
end

function number_parser(to_parse::AbstractString, legacy::Bool=false)
    if match(r"\s", to_parse) !== nothing
        map(number_parser, split(to_parse), repeated(legacy))

    elseif 'b' ∈ to_parse # Explicit base
        handle_base(to_parse, legacy)

    elseif "_" == to_parse
        Inf

    # TODO: This should probably be bundled with the bignum implementation
    elseif !legacy && endswith(to_parse, ['p', 'π'])
        number_parser(to_parse[1:end-1]) * π

    # The …[2:end-1] excludes catches in the begin and end, those are invalid
    # in this context, and handled elsewhere. For example, 3x shouldn't match.
    elseif length(to_parse[2:end-1] ∩ keys(exponents)) > 0
        handle_exponent(to_parse, legacy)

    elseif 'r' ∈ to_parse
        handle_frac(to_parse, legacy)

    #HACK: The rstrip is fugly
    elseif startswith(to_parse, "_") && rstrip(to_parse, postfixes) != "_"
        # This doesn't catch ∞, because it is handled earlier
        -number_parser(to_parse[2:end])

    elseif endswith(to_parse, "x")
        handle_bignum(to_parse)

    else
        parse('.' ∈ to_parse ? float : Int, to_parse)
    end
end
end
