module Digger

using Flow, MacroTools, Dagger

g(a...) = IVertex{Any}(a...)

const binary = [(.+), (.-), (.*), (./), (*), (.^), (.%), (*)]

for f in binary
  @eval nargs(::typeof($f)) = 2
end

const unary = [sum, exp, log, log10, transpose, ctranspose, sqrt,
               sin, sinpi, cos, cospi, tan, sec, cot, csc,
               sinh, cosh, tanh, coth, sech, csch, sinc, cosc]

for f in unary
  @eval nargs(::typeof($f)) = 1
end

function pop_random!(xs)
  i = rand(1:length(xs))
  x = xs[i]
  deleteat!(xs, i)
  x
end

function grow(bs, n)
  unused = map(g, bs)
  nodes = similar(unused, 0)
  function getnode()
    isempty(unused) && return rand(nodes)
    x = pop_random!(unused)
    push!(nodes, x)
    x
  end
  for i = 1:n
    op = rand(vcat(binary, unary))
    push!(unused, g(op, (getnode() for i in 1:nargs(op))...))
  end
  unused[end]
end

function code(bs, xs, g)
  :(let $([:($b = $x) for (b, x) in zip(bs, xs)]...)
      $(Flow.syntax(g))
    end)
end

function maketest(size, nodes)
  x, y = rand(size), rand(size)
  cfx, cfy = Distribute(BlockPartition(100, 100), x), Distribute(BlockPartition(100, 100), y)
  @assert gather(cfx) == x && gather(cfy) == y
  bs = [gensym() for x in 1:2]
  g = grow(bs, nodes)
  acode = code(bs, [x, y], g)
  dcode = code(bs, [cfx, cfy], g)
  acode, dcode
end

# runtest((10,10), 10)[2] |> eval |> gather

end # module
