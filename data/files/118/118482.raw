__precompile__(true)

module Graphics2D

import Base.show,
       Base.*,
       Base.-,
       Cairo

export Line,
       Arrow,
       Point,
       Circle,
       Arc,
       GraphicText,
       showgraphics,
       save,
       GraphicElement,
       boundingbox,
       listplot,
       samplescene,
       COLORS

COLORS = Dict(
"red" =>    [1.0, 0.0, 0.0],
"green" =>  [0.0, 1.0, 0.0],
"blue" =>   [0.0, 0.0, 1.0],
"yellow" => [1.0, 1.0, 0.0],
"purple" => [0.5, 0.0, 0.5],
"orange" => [1.0, 0.4, 0.0], 
"white" =>  [1.0, 1.0, 1.0],
"black" =>  [0.0, 0.0, 0.0],
"gray" =>   [0.5, 0.5, 0.5]
)

abstract GraphicElement

immutable BoundingBox
    xmin::Real
    xmax::Real
    ymin::Real
    ymax::Real
end

immutable Point <: GraphicElement
    x::Real
    y::Real
    pointsize::Real
    color::Array{Float64,1}
end

immutable Line{T<:Real} <: GraphicElement
    coords::Array{T,2}
    linewidth::Real
    color::Array{Float64,1}
    fill::Bool
    fillcolor::Array{Float64,1}
end

immutable Arrow{T<:Real} <: GraphicElement
    coords::Array{T,2}
    linewidth::Real
    color::Array{Float64,1}
    arrowsize::Real
    arrowloc::Real
end

immutable Circle <: GraphicElement
    center::Array{Float64,1}
    radius::Float64
    linewidth::Real
    color::Array{Float64,1}
    fill::Bool
    fillcolor::Array{Float64,1}
end

immutable Arc <: GraphicElement
    center::Array{Float64,1}
    radius::Real
    theta1::Real
    theta2::Real
    linewidth::Real
    color::Array{Float64,1}
    fill::Bool
    fillcolor::Array{Float64,1}
end

immutable GraphicText <: GraphicElement
    location::Array{Float64,1}
    text::AbstractString
    textsize::Real
    color::Array{Float64,1}
end

*(x::Real,s::String) = x * COLORS[s]

tocolor(string_or_rgb) = isa(string_or_rgb,AbstractString) ? 
                            COLORS[string_or_rgb] : string_or_rgb
function Point(x::Real, 
               y::Real; 
               pointsize::Real=0.005, 
               color=[0.0,0.0,0.0])
    return Point(x,y,pointsize,tocolor(color))
end

function Point{T<:Real}(z::Complex{T}; args...)
    return Point(real(z),imag(z); args...)
end

function Point{T<:Real}(p::Tuple{T,T}; args...)
    return Point(p[1],p[2]; args...)
end

function Point{T<:Real}(a::Array{T,1}; args...)
    return Point(a[1],a[2]; args...)
end

function Line{T<:Real}(A::Array{T,2};
                       linewidth::Real=1.0,
                       color=[0.0,0.0,0.0],
                       fill::Bool=false,
                       fillcolor=[1.0,1.0,1.0])
    return Line(A,linewidth,tocolor(color),fill,tocolor(fillcolor))
end

function Line{T}(a::Array{T,2};args...)
    return Line(map(float,a);args...)
end

function Line{T}(a::Array{Complex{T},1};args...)
    return Line(hcat(real(a),imag(a));args...)
end

function Line{T}(a::Array{Array{T,1},1};args...)
    return Line(hcat(T[a[k][1] for k=1:length(a)],T[a[k][2] for k=1:length(a)]);args...)
end

function Line{T}(a::Array{Tuple{T,T},1};args...)
    return Line(hcat(T[a[k][1] for k=1:length(a)],T[a[k][2] for k=1:length(a)]);args...)
end

function Line(a::Arrow)
    return Line(a.coords;linewidth=a.linewidth,color=a.color)
end

function Arrow{T<:Real}(A::Array{T,2};
		        linewidth::Real=1.0,
	                color=[0.0,0.0,0.0],
		        arrowsize::Real=0.05,
			arrowloc::Real=0.5)
    return Arrow(A,linewidth,tocolor(color),arrowsize,arrowloc)
end

function Arrow{T}(a::Array{T,2};args...)
    return Arrow(map(float,a);args...)
end

function Arrow{T}(a::Array{Complex{T},1};args...)
    return Arrow(hcat(real(a),imag(a));args...)
end

function Arrow{T}(a::Array{Array{T,1},1};args...)
    return Arrow(hcat(T[a[k][1] for k=1:length(a)],T[a[k][2] for k=1:length(a)]);args...)
end

function Arrow{T}(a::Array{Tuple{T,T},1};args...)
    return Arrow(hcat(T[a[k][1] for k=1:length(a)],T[a[k][2] for k=1:length(a)]);args...)
end

function -(a::Arrow)
    return Arrow(a.coords[end:-1:1,1:end],
                 a.linewidth,
		 a.color,
		 a.arrowsize,
		 a.arrowloc)
end

function *(i::Integer,a::Arrow)
    return signbit(i) ? -a : a
end


function Circle{T,U}(center::Array{T,1},
                     radius::U;
                     linewidth::Real=1.0,
                     color=[0.0,0.0,0.0],
                     fill::Bool=false,
                     fillcolor=[1.0,1.0,1.0]
                     )
    return Circle(map(float,center),float(radius),linewidth,tocolor(color),fill,tocolor(fillcolor))
end

function Circle{T,U}(x::T,
                     y::T,
                     radius::U;
                     args...
                     )
    return Circle(T[x,y],radius;args...)
end

function Circle{T,U}(p::Tuple{T,T},
                     radius::U;
                     args...
                     )
    return Circle(p[1],p[2],radius;args...)
end

function Arc{T}(center::Array{T,1},
                radius,
                theta1,
                theta2;
                linewidth::Real=1.0,
                color=[0.0,0.0,0.0],
                fill::Bool=false,
                fillcolor=[1.0,1.0,1.0]
                )
    return Arc(map(float,center),
               float(radius),
               float(theta1),
               float(theta2),
               linewidth,
               tocolor(color),
               fill,
               tocolor(fillcolor))
end

function GraphicText{T}(location::Array{T,1},
                text::AbstractString;
                textsize::Float64=0.2,
                color=[0.0,0.0,0.0]
                )
    return GraphicText(location,text,textsize,tocolor(color))
end

function show(io::IO,line::Line)
    print(io,"Line(coordinates =\n")
    show(io,line.coords)
    print(io,",\nlinewidth = ",line.linewidth)
    if line.fill
        print(io,",\nfillcolor = ")
        print(io,"[",line.fillcolor[1],",",
              line.fillcolor[2],",",line.fillcolor[3],"]")
    else
        print(io,",\nfill = ",line.fill)
    end
    print(io,")")
end

function show(io::IO,arrow::Arrow)
    print(io,"Arrow(coordinates =\n")
    show(io,arrow.coords)
    print(io,",\nlinewidth = ",arrow.linewidth)
    print(io,",\narrowsize = ",arrow.arrowsize)
    print(io,",\narrowloc = ",arrow.arrowloc)
    print(io,")")
end

function show(io::IO,point::Point)
    print(io,"Point(")
    print(io,point.x)
    print(io,",")
    print(io,point.y)
    print(io,")")
end

function boundingbox(l::Line)
    # Coordinates are returned in the order xmin, xmax, ymax, ymin
    return BoundingBox(minimum(l.coords[:,1]), maximum(l.coords[:,1]), minimum(l.coords[:,2]),maximum(l.coords[:,2]))
end

function boundingbox(a::Arrow)
    # Coordinates are returned in the order xmin, xmax, ymax, ymin
    return boundingbox(map(boundingbox,[Line(a),arrowhead(a)]))
end

function boundingbox(c::Circle)
    return BoundingBox(c.center[1] - c.radius, c.center[1] + c.radius, c.center[2] - c.radius, c.center[2] + c.radius)
end

function boundingbox(p::Point)
    return BoundingBox(p.x,p.x,p.y,p.y)
end

function boundingbox(a::Arc)
    return BoundingBox(a.center[1] - a.radius, a.center[1] + a.radius, a.center[2] - a.radius, a.center[2] + a.radius)
end

function boundingbox(t::GraphicText)
    return BoundingBox(t.location[1],t.location[1],t.location[2],t.location[2])
end

function boundingbox(A::Array)
    a = minimum([bb.xmin for bb in A])
    b = maximum([bb.xmax for bb in A])
    c = maximum([bb.ymax for bb in A])
    d = minimum([bb.ymin for bb in A])
    if a == b || c == d
        error("Bounding box has empty interior")
    end
    return BoundingBox(a - 0.05*(b-a), b + 0.05*(b-a), d - 0.05*(c-d), c + 0.05*(c-d))
end

function sketch(cr::Cairo.CairoContext,
                l::Line,
                bb::BoundingBox;
                fill::Array{Float64,1}=Float64[1.0,1.0,1.0])

    Cairo.set_line_width(cr,l.linewidth)

    Cairo.move_to(cr,l.coords[1,1],l.coords[1,2]);
    for i=1:size(l.coords)[1]-1
        Cairo.line_to(cr,l.coords[i+1,1],l.coords[i+1,2]);
    end

    if l.coords[end,:] == l.coords[1,:]
        Cairo.close_path(cr)
    end

    if l.coords[end,:] == l.coords[1,:] && l.fill
        Cairo.set_source_rgb(cr,l.fillcolor[1], l.fillcolor[2], l.fillcolor[3])
        Cairo.fill_preserve(cr)
        Cairo.set_source_rgb(cr,l.color[1], l.color[2], l.color[3])
        Cairo.stroke(cr)
    else
        Cairo.set_source_rgb(cr,l.color[1], l.color[2], l.color[3])
        Cairo.stroke(cr)
    end
end

function arrowhead(a::Arrow)
    A = a.coords[end-1,:]
    B = a.coords[end,:]
    z = (B-A)[1] + im*((B-A)[2])
    θ = angle(z)
    ψ = 20π/180
    l = a.arrowsize
    tip = A + a.arrowloc*(B-A)
    C = tip-abs(z)*l*[cos(θ+ψ),sin(θ+ψ)]
    D = tip-abs(z)*l*[cos(θ-ψ),sin(θ-ψ)]

    return Line([tip,C,D,tip],fill=true,color=a.color,fillcolor=a.color)
end

function sketch(cr::Cairo.CairoContext,
                a::Arrow,
                bb::BoundingBox)

    Cairo.set_line_width(cr,a.linewidth)

    Cairo.move_to(cr,a.coords[1,1],a.coords[1,2]);
    for i=1:size(a.coords)[1]-1
        Cairo.line_to(cr,a.coords[i+1,1],a.coords[i+1,2]);
    end

    Cairo.set_source_rgb(cr,a.color[1], a.color[2], a.color[3])
    Cairo.stroke(cr)

    sketch(cr,arrowhead(a),bb)

end


function sketch(cr::Cairo.CairoContext,
                c::Circle,
                bb::BoundingBox)

    Cairo.set_line_width(cr,c.linewidth)
    Cairo.arc(cr, c.center[1], c.center[2], c.radius, 0, 2*pi)

    if c.fill
        Cairo.set_source_rgb(cr,c.fillcolor...)
        Cairo.fill_preserve(cr)
    end

    Cairo.set_source_rgb(cr,c.color...)
    Cairo.stroke(cr)
end

function sketch(cr::Cairo.CairoContext,
                a::Arc,
                bb::BoundingBox)
    Cairo.arc(cr, a.center[1], a.center[2], a.radius, a.theta1, a.theta2);
    Cairo.set_source_rgb(cr,a.color...)
    Cairo.stroke(cr)
end

function sketch(cr::Cairo.CairoContext,
                p::Point,
                bb::BoundingBox)

    Cairo.arc(cr, p.x, p.y, 
              p.pointsize*max(bb.xmax-bb.xmin,bb.ymax-bb.ymin), 0, 2*pi);
    Cairo.set_source_rgb(cr,p.color...)
    Cairo.fill(cr)
end

function sketch(cr::Cairo.CairoContext,
                t::GraphicText,
                bb::BoundingBox)

    Cairo.save(cr)

    Cairo.set_font_size(cr,t.textsize)
    Cairo.set_source_rgb(cr,t.color...)

    x_bearing, y_bearing, width, height = Cairo.text_extents(cr,t.text)

    Cairo.move_to(cr,t.location[1] - width/2 - x_bearing, t.location[2] + height/2 + y_bearing)
  
    Cairo.scale(cr,1,-1)
    Cairo.show_text(cr,t.text)
    Cairo.restore(cr)
end

function draw(A::Array,
              c::Cairo.CairoSurface,
              cr::Cairo.CairoContext;
              dim::Integer=512)
    bb = boundingbox(map(boundingbox,A))
    asp_ratio = (bb.xmax - bb.xmin)/(bb.ymax - bb.ymin)

    Cairo.set_coordinates(cr, 0, 0, dim, round(Int,asp_ratio\dim), bb.xmin, bb.xmax, bb.ymax, bb.ymin)
    Cairo.set_source_rgb(cr, 1, 1, 1)  # set color to white
    Cairo.paint(cr) 

    Cairo.set_line_width(cr,1)
    Cairo.set_line_join(cr, Cairo.Cairo.CAIRO_LINE_JOIN_ROUND)
    
    for i=1:length(A)
        sketch(cr,A[i],bb)
    end
end


function showgraphics(A::Array;
                      dim::Integer=512)
    bb = boundingbox(map(boundingbox,A))
    asp_ratio = (bb.xmax - bb.xmin)/(bb.ymax - bb.ymin)
    c = Cairo.CairoRGBSurface(dim,round(Int,asp_ratio\dim)) 
    cr = Cairo.CairoContext(c) 
    draw(A,c,cr,dim=dim)
    return c
end

function save{T<:GraphicElement}(filename::AbstractString,
                                 A::Array{T,1};
                                 dim::Integer=512)
    showgraphics(filename,A,dim)
end

function showgraphics(g::GraphicElement;
                      dim::Integer=512)
    showgraphics([g];dim=dim)
end

function showgraphics(filename::AbstractString,
                      A::Array;
                      dim::Integer=512)
    bb = boundingbox(map(boundingbox,A))
    asp_ratio = (bb.xmax - bb.xmin)/(bb.ymax - bb.ymin)
    if contains(filename,".pdf")
        c = Cairo.CairoPDFSurface(filename,dim,round(Int,asp_ratio\dim))
    elseif contains(filename,".png")
        c = Cairo.CairoRGBSurface(dim,round(Int,asp_ratio\dim))
    else
        error("File name must end in .pdf or .png")
    end
    cr = Cairo.CairoContext(c);
    draw(A,c,cr;dim=dim)
    if contains(filename,".png")
        Cairo.write_to_png(c,filename)
    end
    Cairo.finish(c)
end

function showgraphics(filename::AbstractString,
                      g::GraphicElement;
                      dim::Integer=512)
    showgraphics(filename,[g];dim=dim)
end

show{T<:GraphicElement}(io::IO, ::MIME"image/png", A::Array{T,1}) =
    Cairo.write_to_png(showgraphics(A),io)

function listplot(v::Array{Float64,1};args...)
    return listplot(Array{Float64,1}[v];args...)
end

function listplot(vectorlist::Array{Array{Float64,1},1};
                  plotmin::Real=-Inf,
                  plotmax::Real=Inf)
    if plotmax == Inf
        M = maximum(map(maximum,vectorlist))
    else
        M = plotmax
    end
    if plotmin == -Inf
        m = minimum(map(minimum,vectorlist))
    else
        m = plotmin
    end
    colors = String["blue","red","orange","green"]
    graphicslist = GraphicElement[
        Line([0 0; 2.1 0]),
        Line([0 0; 0 1.1]),
        Line([-0.05 1; 0.05 1]),
        GraphicText([-0.15,0.0],format(m);textsize=0.07),
        GraphicText([-0.15,1.0],format(M);textsize=0.07),
        Point(-0.2,0.5;color="white")
        ]
    if m < 0.0 < M && 0.1 < -m / (M-m) < 0.9
        push!(graphicslist,Line([-0.05 -m/(M-m); 0.05 -m/(M-m)]))
        push!(graphicslist,GraphicText([-0.15,-m/(M-m)],"0";textsize=0.07))
    end
    for i = 1:length(vectorlist)
        vscaled = (vectorlist[i]-m)./(M-m)
        if i < 5
            push!(graphicslist,Line(hcat(linspace(0,2,length(vscaled)),vscaled);
                                    color=colors[i]))
        else
            push!(graphicslist,Line(hcat(linspace(0,2,length(vscaled)),vscaled);
            color=[rand(),rand(),rand()]
            ))
        end
    end
    return graphicslist
end

function format(x::Float64)
    if 0.01 < abs(x) < 100.0 
        return string(round(x,2))
    else
        return @sprintf("%1.2e",x)
    end
end

function samplescene()
    return [
        Line([0 1; 2 0; 2 2; 0 1];color="red",linewidth=3),
        Arrow([-0.5 0; 0.5 0.25];color="orange",
              linewidth=3,
              arrowsize=0.2,
              arrowloc=0.6),
        Point(1.5,1.0;pointsize=0.01,color=0.5*"green"),
        Circle([0.0; 1.4],1;color="blue"),
        Arc([0.0; 1.4],0.9,pi/2,pi;color=[0.2,0.6,0.1]),
        GraphicText([0.0;1.4],"example text";textsize=0.1,
                    color=[0.1,0.2,0.4])
    ]
end

end # module
