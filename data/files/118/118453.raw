module Graphics2D

import Base.Graphics,
       Base.show,
       Cairo

export Line,
       Point,
       Circle,
       Arc,
       Text,
       showgraphics,
       save,
       GraphicElement,
       boundingbox,
       red,
       green,
       blue,
       yellow, 
       purple,
       orange,
       white,
       black,
       gray,
       COLORS
       

red =    [1.0, 0.0, 0.0]
green =  [0.0, 1.0, 0.0]
blue =   [0.0, 0.0, 1.0]
yellow = [1.0, 1.0, 0.0] 
purple = [0.5, 0.0, 0.5]
orange = [1.0, 0.4, 0.0] 
white =  [1.0, 1.0, 1.0]
black =  [0.0, 0.0, 0.0]
gray =   [0.5, 0.5, 0.5]

COLORS = ["red","green","blue","yellow","purple","orange","white","black","gray"]

abstract GraphicElement

immutable Point <: GraphicElement
    x::Real
    y::Real
    rs::Real
    color::Array{Float64,1}
end

immutable Line{T<:Real} <: GraphicElement
    coords::Array{T,2}
    rs::Real
    color::Array{Float64,1}
    fill::Bool
    fillcolor::Array{Float64,1}
end

immutable Circle <: GraphicElement
    center::Array{Float64,1}
    radius::Float64
    rs::Real
    color::Array{Float64,1}
    fill::Bool
    fillcolor::Array{Float64,1}
end

immutable Arc <: GraphicElement
    center::Array{Float64,1}
    radius::Real
    theta1::Real
    theta2::Real
    rs::Real
    color::Array{Float64,1}
    fill::Bool
    fillcolor::Array{Float64,1}
end

immutable Text <: GraphicElement
    location::Array{Float64,1}
    text::String
    textsize::Real
    color::Array{Float64,1}
end

function Point(x::Real,y::Real;rs::Real=0.005,color::Array{Float64,1}=[0.0,0.0,0.0])
    return Point(x,y,rs,color)
end

function Line{T<:Real}(A::Array{T,2};
                       rs::Real=1.0,
                       color::Array{Float64,1}=[0.0,0.0,0.0],
                       fill::Bool=false,
                       fillcolor::Array{Float64,1}=[1.0,1.0,1.0])
    return Line(A,rs,color,fill,fillcolor)
end

function Line{T}(a::Array{T,2};args...)
    return Line(map(float,a);args...)
end

function Circle{T,U}(center::Array{T,1},
                     radius::U;
                     rs::Real=1.0,
                     color::Array{Float64,1}=[0.0,0.0,0.0],
                     fill::Bool=false,
                     fillcolor::Array{Float64,1}=[1.0,1.0,1.0]
                     )
    return Circle(map(float,center),float(radius),rs,color,fill,fillcolor)
end

function Arc{T}(center::Array{T,1},
                radius,
                theta1,
                theta2;
                rs::Real=1.0,
                color::Array{Float64,1}=[0.0,0.0,0.0],
                fill::Bool=false,
                fillcolor::Array{Float64,1}=[1.0,1.0,1.0]
                )
    return Arc(map(float,center),float(radius),float(theta1),float(theta2),rs,color,fill,fillcolor)
end

function Text{T}(location::Array{T,1},
                text::String;
                textsize::Float64=0.2,
                color::Array{Float64,1}=[0.0,0.0,0.0]
                )
    return Text(location,text,textsize,color)
end

function show(io::IO,point::Point)
    print(io,"Point(")
    print(io,point.x)
    print(io,",")
    print(io,point.y)
    print(io,")")
end

function boundingbox(l::Line)
    # Coordinates are returned in the order xmin, xmax, ymax, ymin
    return Base.Graphics.BoundingBox(minimum(l.coords[:,1]), maximum(l.coords[:,1]), minimum(l.coords[:,2]),maximum(l.coords[:,2]))
end

function boundingbox(c::Circle)
    return Base.Graphics.BoundingBox(c.center[1] - c.radius, c.center[1] + c.radius, c.center[2] - c.radius, c.center[2] + c.radius)
end

function boundingbox(p::Point)
    return Base.Graphics.BoundingBox(p.x,p.x,p.y,p.y)
end

function boundingbox(a::Arc)
    return Base.Graphics.BoundingBox(a.center[1] - a.radius, a.center[1] + a.radius, a.center[2] - a.radius, a.center[2] + a.radius)
end

function boundingbox(t::Text)
    return Base.Graphics.BoundingBox(t.location[1],t.location[1],t.location[2],t.location[2])
end

function boundingbox(A::Array)
    a = minimum([bb.xmin for bb in A])
    b = maximum([bb.xmax for bb in A])
    c = maximum([bb.ymax for bb in A])
    d = minimum([bb.ymin for bb in A])
    if a == b || c == d
        error("Bounding box has empty interior")
    end
    return Base.Graphics.BoundingBox(a - 0.05*(b-a), b + 0.05*(b-a), d - 0.05*(c-d), c + 0.05*(c-d))
end

function sketch(cr::Cairo.CairoContext,
                l::Line,
                bb::Base.Graphics.BoundingBox;
                fill::Array{Float64,1}=Float64[1.0,1.0,1.0])

    Cairo.set_line_width(cr,l.rs)

    Cairo.move_to(cr,l.coords[1,1],l.coords[1,2]);
    for i=1:size(l.coords)[1]-1
        Cairo.line_to(cr,l.coords[i+1,1],l.coords[i+1,2]);
    end

    if l.coords[end,:] == l.coords[1,:]
        Cairo.close_path(cr)
    end

    if l.coords[end,:] == l.coords[1,:] && l.fill
        Cairo.set_source_rgb(cr,l.fillcolor[1], l.fillcolor[2], l.fillcolor[3])
        Cairo.fill_preserve(cr)
        Cairo.set_source_rgb(cr,l.color[1], l.color[2], l.color[3])
        Cairo.stroke(cr)
    else
        Cairo.set_source_rgb(cr,l.color[1], l.color[2], l.color[3])
        Cairo.stroke(cr)
    end
end

function sketch(cr::Cairo.CairoContext,
                c::Circle,
                bb::Base.Graphics.BoundingBox)

    Cairo.arc(cr, c.center[1], c.center[2], c.radius, 0, 2*pi)

    if c.fill
        Cairo.set_source_rgb(cr,c.fillcolor[1], c.fillcolor[2], c.fillcolor[3])
        Cairo.fill_preserve(cr)
    end

    Cairo.set_source_rgb(cr,c.color[1], c.color[2], c.color[3])
    Cairo.stroke(cr)
end

function sketch(cr::Cairo.CairoContext,
                a::Arc,
                bb::Base.Graphics.BoundingBox)
    Cairo.arc(cr, a.center[1], a.center[2], a.radius, a.theta1, a.theta2);
    Cairo.set_source_rgb(cr,a.color[1], a.color[2], a.color[3])
    Cairo.stroke(cr)
end

function sketch(cr::Cairo.CairoContext,
                p::Point,
                bb::Base.Graphics.BoundingBox)
    Cairo.arc(cr, p.x, p.y, p.rs*max(bb.xmax-bb.xmin,bb.ymax-bb.ymin), 0, 2*pi);
    Cairo.set_source_rgb(cr,p.color[1], p.color[2], p.color[3])
    Cairo.fill(cr)
end

function sketch(cr::Cairo.CairoContext,
                t::Text,
                bb::Base.Graphics.BoundingBox)

    Cairo.save(cr)

    Cairo.set_font_size(cr,t.textsize)
    Cairo.set_source_rgb(cr,t.color[1], t.color[2], t.color[3])

    x_bearing, y_bearing, width, height = Cairo.text_extents(cr,t.text)

    Cairo.move_to(cr,t.location[1] - width/2 - x_bearing, t.location[2] + height/2 + y_bearing)
  
    Cairo.scale(cr,1,-1)
    Cairo.show_text(cr,t.text)
    Cairo.restore(cr)
end

function draw(A::Array,
              c::Cairo.CairoSurface,
              cr::Cairo.CairoContext;
              dim::Integer=512)
    bb = boundingbox(map(boundingbox,A))
    asp_ratio = (bb.xmax - bb.xmin)/(bb.ymax - bb.ymin)

    Cairo.set_coords(cr, 0, 0, dim, int(asp_ratio\dim), bb.xmin, bb.xmax, bb.ymax, bb.ymin)
    Cairo.set_source_rgb(cr, 1, 1, 1)  # set color to white
    Cairo.paint(cr) 

    Cairo.set_line_width(cr,1)
    Cairo.set_line_join(cr, Cairo.Cairo.CAIRO_LINE_JOIN_ROUND)
    
    for i=1:length(A)
        sketch(cr,A[i],bb)
    end
end


function showgraphics(A::Array;
                      dim::Integer=512)
    bb = boundingbox(map(boundingbox,A))
    asp_ratio = (bb.xmax - bb.xmin)/(bb.ymax - bb.ymin)
    c = Cairo.CairoRGBSurface(dim,int(asp_ratio\dim)) 
    cr = Cairo.CairoContext(c) 
    draw(A,c,cr,dim=dim)
    return c
end

function showgraphics(g::GraphicElement;
                      dim::Integer=512)
    showgraphics([g];dim=dim)
end

function save(filename::String,
              A::Array;
              dim::Integer=512)
    bb = boundingbox(map(boundingbox,A))
    asp_ratio = (bb.xmax - bb.xmin)/(bb.ymax - bb.ymin)
    if contains(filename,".pdf")
        c = Cairo.CairoPDFSurface(filename,dim,int(asp_ratio\dim))
    elseif contains(filename,".png")
        c = Cairo.CairoRGBSurface(dim,int(asp_ratio\dim))
    else
        error("File name must end in .pdf or .png")
    end
    cr = Cairo.CairoContext(c);
    draw(A,c,cr;dim=dim)
    if contains(filename,".png")
        Cairo.write_to_png(c,filename)
    end
    Cairo.finish(c)
end

function save(filename::String,
              g::GraphicElement;
              dim::Integer=512)
    save(filename,[g];dim=dim)
end

end # module
