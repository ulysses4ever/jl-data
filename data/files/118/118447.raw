module Graphics2D

import Base.Graphics,
       Base.show,
       Cairo

export Line,
       Point,
       Circle,
       Arc,
       showgraphics,
       savePDF,
       savePNG,
       GraphicElement,
       boundingbox

abstract GraphicElement

immutable Point <: GraphicElement
    x::Real
    y::Real
    rs::Real
end

immutable Line{T<:Real} <: GraphicElement
    coords::Array{T,2}
    rs::Real
end

immutable Circle <: GraphicElement
    center::Array{Float64,1}
    radius::Float64
    rs::Real
end

immutable Arc <: GraphicElement
    center::Array{Float64,1}
    radius::Real
    theta1::Real
    theta2::Real
end

function Line{T}(a::Array{T,2},rs::Real)
    return Line(map(float,a),rs)
end

function Circle{T,U}(center::Array{T,1},radius::U,rs::Real)
    return Circle(map(float,center),float(radius),rs)
end

function Arc{T}(center::Array{T,1},radius,theta1,theta2)
    return Arc(map(float,center),float(radius),float(theta1),float(theta2))
end

function Point(x::Real,y::Real;rs::Real=0.005)
    return Point(x,y,rs)
end

function Line{T<:Real}(A::Array{T,2};rs::Real=1.0)
    return Line(A,rs)
end

function Circle{T,U}(center::Array{T,1},radius::U;rs::Real=1.0)
    return Circle(map(float,center),float(radius),rs)
end

function show(io::IO,point::Point)
    print(io,"Point(")
    print(io,point.x)
    print(io,",")
    print(io,point.y)
    print(io,")")
end

function boundingbox(l::Line)
    # Coordinates are returned in the order xmin, xmax, ymax, ymin
    return Base.Graphics.BoundingBox(minimum(l.coords[:,1]), maximum(l.coords[:,1]), minimum(l.coords[:,2]),maximum(l.coords[:,2]))
end

function boundingbox(c::Circle)
    return Base.Graphics.BoundingBox(c.center[1] - c.radius, c.center[1] + c.radius, c.center[2] - c.radius, c.center[2] + c.radius)
end

function boundingbox(p::Point)
    return Base.Graphics.BoundingBox(p.x,p.x,p.y,p.y)
end

function boundingbox(a::Arc)
    return Base.Graphics.BoundingBox(a.center[1] - a.radius, a.center[1] + a.radius, a.center[2] - a.radius, a.center[2] + a.radius)
end

function boundingbox(A::Array)
    a = minimum([bb.xmin for bb in A])
    b = maximum([bb.xmax for bb in A])
    c = maximum([bb.ymax for bb in A])
    d = minimum([bb.ymin for bb in A])
    if a == b || c == d
        error("Bounding box has empty interior")
    end
    return Base.Graphics.BoundingBox(a - 0.05*(b-a), b + 0.05*(b-a), d - 0.05*(c-d), c + 0.05*(c-d))
end

function sketch(cr::Cairo.CairoContext,
                l::Line,
                bb::Base.Graphics.BoundingBox;
                color::Array{Float64,1}=Float64[0.0,0.0,0.0],
                fill::Array{Float64,1}=Float64[1.0,1.0,1.0])

    Cairo.set_line_width(cr,l.rs)

    Cairo.move_to(cr,l.coords[1,1],l.coords[1,2]);
    for i=1:size(l.coords)[1]-1
        Cairo.line_to(cr,l.coords[i+1,1],l.coords[i+1,2]);
    end

    if l.coords[end,:] == l.coords[1,:]
        Cairo.close_path(cr)
    end

    if l.coords[end,:] == l.coords[1,:] && sum(fill) < 3.0
        Cairo.set_source_rgb(cr,fill[1], fill[2], fill[3])
        Cairo.fill_preserve(cr)
        Cairo.set_source_rgb(cr,color[1], color[2], color[3])
        Cairo.stroke(cr)
    else
        Cairo.set_source_rgb(cr,color[1], color[2], color[3])
        Cairo.stroke(cr)
    end
end

function sketch(cr::Cairo.CairoContext,
                c::Circle,
                bb::Base.Graphics.BoundingBox;
                color::Array{Float64,1}=Float64[0.0,0.0,0.0],
                fill::Array{Float64,1}=Float64[1.0,1.0,1.0])

    Cairo.arc(cr, c.center[1], c.center[2], c.radius, 0, 2*pi)

    if sum(fill) < 3.0
        Cairo.set_source_rgb(cr,fill[1], fill[2], fill[3])
        Cairo.fill_preserve(cr)
    end

    Cairo.set_source_rgb(cr,color[1], color[2], color[3])
    Cairo.stroke(cr)
end

function sketch(cr::Cairo.CairoContext,
                a::Arc,
                bb::Base.Graphics.BoundingBox;
                color::Array{Float64,1}=Float64[0.0,0.0,0.0],
                fill::Array{Float64,1}=Float64[1.0,1.0,1.0])
    Cairo.arc(cr, a.center[1], a.center[2], a.radius, a.theta1, a.theta2);
    Cairo.set_source_rgb(cr,color[1], color[2], color[3])
    Cairo.stroke(cr)
end

function sketch(cr::Cairo.CairoContext,
                p::Point,
                bb::Base.Graphics.BoundingBox;
                color::Array{Float64,1}=Float64[0.0,0.0,0.0],
                fill::Array{Float64,1}=Float64[1.0,1.0,1.0])
    Cairo.arc(cr, p.x, p.y, p.rs*max(bb.xmax-bb.xmin,bb.ymax-bb.ymin), 0, 2*pi);
    Cairo.set_source_rgb(cr,color[1], color[2], color[3])
    Cairo.fill(cr)
end

function draw(A::Array,
              c::Cairo.CairoSurface,
              cr::Cairo.CairoContext;
              dim::Integer=512,
              color::Array{Array{Float64,1},1}=Array{Float64,1}[[0.0,0.0,0.0]],
              fill::Array{Array{Float64,1},1}=Array{Float64,1}[[1.0,1.0,1.0]])
    if color == Array[[0.0,0.0,0.0]]
        color = [[0.0,0.0,0.0] for k = 1:length(A)]
    end
    if fill == Array[[1.0,1.0,1.0]]
        fill = [[1.0,1.0,1.0] for k=1:length(A)]
    end
    bb = boundingbox(map(boundingbox,A))
    asp_ratio = (bb.xmax - bb.xmin)/(bb.ymax - bb.ymin)

    Cairo.set_coords(cr, 0, 0, dim, int(asp_ratio\dim), bb.xmin, bb.xmax, bb.ymax, bb.ymin)
    Cairo.set_source_rgb(cr, 1, 1, 1)  # set color to white
    Cairo.paint(cr) 

    Cairo.set_line_width(cr,1)
    Cairo.set_line_join(cr, Cairo.Cairo.CAIRO_LINE_JOIN_ROUND)
    
    for i=1:length(A)
        sketch(cr,A[i],bb;color=color[i],fill=fill[i])
    end
end


function showgraphics(A::Array;
                      dim::Integer=512,
                      color::Array{Array{Float64,1},1}=Array{Float64,1}[[0.0,0.0,0.0]],
                      fill::Array{Array{Float64,1},1}=Array{Float64,1}[[1.0,1.0,1.0]])
    bb = boundingbox(map(boundingbox,A))
    asp_ratio = (bb.xmax - bb.xmin)/(bb.ymax - bb.ymin)
    c = Cairo.CairoRGBSurface(dim,int(asp_ratio\dim)) 
    cr = Cairo.CairoContext(c) 
    draw(A,c,cr,dim=dim,color=color,fill=fill)
    return c
end

function showgraphics(g::GraphicElement;
                      dim::Integer=512,
                      color::Array{Array{Float64,1},1}=Array{Float64,1}[[0.0,0.0,0.0]],
                      fill::Array{Array{Float64,1},1}=Array{Float64,1}[[1.0,1.0,1.0]])
    showgraphics([g];dim=dim,color=color,fill=fill)
end

function savePDF(filename::String,
                 A::Array;
                 dim::Integer=512,
                 color::Array{Array{Float64,1},1}=Array{Float64,1}[[0.0,0.0,0.0]],
                 fill::Array{Array{Float64,1},1}=Array{Float64,1}[[1.0,1.0,1.0]])
    bb = boundingbox(map(boundingbox,A))
    asp_ratio = (bb.xmax - bb.xmin)/(bb.ymax - bb.ymin)
    c = Cairo.CairoPDFSurface(filename,dim,int(asp_ratio\dim));
    cr = Cairo.CairoContext(c);
    draw(A,c,cr;dim=dim,color=color,fill=fill)
    Cairo.finish(c)
end

function savePNG(filename::String,
                 A::Array;
                 dim::Integer=512,
                 color::Array{Array{Float64,1},1}=Array{Float64,1}[[0.0,0.0,0.0]],
                 fill::Array{Array{Float64,1},1}=Array{Float64,1}[[1.0,1.0,1.0]])
    bb = boundingbox(map(boundingbox,A))
    asp_ratio = (bb.xmax - bb.xmin)/(bb.ymax - bb.ymin)
    c = Cairo.CairoRGBSurface(dim,int(asp_ratio\dim));
    cr = Cairo.CairoContext(c);
    draw(A,c,cr;dim=dim,color=color,fill=fill)
    Cairo.write_to_png(c,filename)
    Cairo.finish(c)
end

end # module
