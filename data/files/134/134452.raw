
# Global visualization of basins of univariate rational functions

using Polynomials
using PyPlot
using Colors

#\section{Mathematical framework and theoretical justification of the algorithms}

#\subsection{Discrete metric semi-flows and basins}

#subsection{The augmented sphere and the augmented projective line 
#({\small Normalized homogeneous coordinates and sphere bijections)} }

coefficientlistnumcompila=complex([1.,0.,0.,2.])
coefficientlistdencompila=complex([0.,0.,3.,0.])



function homogeneousNormalization{T<:Number,S<:Number}(twotuple::(T,S),
    minprecision::Int64=15)
    tt1=complex(twotuple[1])
    tt2=complex(twotuple[2])
    if (abs(tt1)<1.0/10^minprecision && abs(tt2)<1.0/10^minprecision)
        hpoint=(complex(0.0),complex(0.0))
    else
        if abs(tt1)<= abs(tt2)
            hpoint=(complex(tt1/tt2),complex(1.0))
        else
            hpoint=(complex(1.0),complex(tt2/tt1))
        end
    end
    return hpoint
end

homogeneousNormalization((1.0+0.0*im, 0.0+1.0*im))


function sphereBijection(twotuple::(Complex{Float64},Complex{Float64}),
                        minprecision::Int64=8)
    z=twotuple[1]
    t=twotuple[2]
    if (abs(z)<1.0/10^minprecision && abs(t)<1.0/10^minprecision)
    point=[0.0,0.0,0.0]
    else
    point=[real((conj(z)*t + conj(t)*z)/(conj(t)*t + conj(z)*z)),
            real((1im*(conj(z)*t - conj(t)*z))/(conj(t)*t + conj(z)*z)),
            real((-conj(t)*t + conj(z)*z)/(conj(t)*t + conj(z)*z))]
    end
    return point
end

sphereBijection((1.0+0.0*im, 0.0+1.0*im),9)

#\subsection{Metrics on $S^{2+}\cong \p^{1+}(\C)$} 

function chordalMetric(twotuple::(Complex{Float64},Complex{Float64}),
                        twotuple1::(Complex{Float64},Complex{Float64}),
                        minprecision::Int64=8)
    return norm((sphereBijection(twotuple,minprecision)-
    sphereBijection(twotuple1,minprecision)))
end

chordalMetric((1.0+0.0*im, 0.0+1.0*im),(0.0+0.0*im, 1.0+0.0*im),9)


#\subsection{Complex rational maps} \label{rf}


function bivariatepolyfunction{T<:Number,S<:Number,R<:Number}(coefficientlist::Array{T,1},
                                        u::S,
                                        t::R,
                                        d::Int)
    coefficientlistcomplex=complex(coefficientlist)
    ff=coefficientlistcomplex[1]*t^d
    for i in 2:length(coefficientlist)
        ff=ff+coefficientlist[i]*u^(i-1)*t^(d-i+1)
    +i
    end
    return ff
end


bivarej=bivariatepolyfunction(coefficientlistnumcompila, 1.0+im* 2.3, 2.0+im*0.9,8)


function pairoffunctions{A<:Number, B<:Number}(coefficientlistnum::Array{A,1}, 
                                    coefficientlistden::Array{B,1})
    ln=length(coefficientlistnum)-1
    ld=length(coefficientlistden)-1
    d=max(ln,ld)
    fff{S<:Number,R<:Number}(u::S, t::R)=
    bivariatepolyfunction(coefficientlistnum,u,t,d)
    ggg{S<:Number,R<:Number}(u::S, t::R)=
    bivariatepolyfunction(coefficientlistden,u,t,d)
    return fff, ggg
end

hpaircompila=pairoffunctions(coefficientlistnumcompila, coefficientlistdencompila)



function rationalFunction(hpair::(Function,Function),
    twotuple::(Complex{Float64},Complex{Float64}),
    minprecision::Int64=15)
    c=twotuple[1]
    d=twotuple[2]
    F=hpair[1]
    G=hpair[2]
    cnew=F(c,d)
    dnew=G(c,d)
    hresult=homogeneousNormalization((cnew,dnew), minprecision)
    return  hresult
end

rationalFunction(hpaircompila,(1.0+0.0*im, 0.0+1.0*im),9)



#\section{Description of the employed algorithms} 

#\subsection{Calculation of the f{}ixed points of $f$}

function fixedPointsofaIrreduciblePair{T<:Number,S<:Number}(coefficientlistnum::Array{T,1},
        coefficientlistden::Array{S,1},
        minprecision::Int64=15)
    coefficientlistnumcomplex=complex(coefficientlistnum)
    coefficientlistdencomplex=complex(coefficientlistden)
    if length(coefficientlistnum)!=length(coefficientlistden)    
    println("The length of the first list is different of the length of the second")      
    elseif  length(coefficientlistnum)==1 && length(coefficientlistden)==1
        finallistoffixedpoint=homogeneousNormalization((coefficientlistnumcomplex[1],
        coefficientlistdencomplex[1]),
        minprecision)
    return [finallistoffixedpoint]
    elseif abs(coefficientlistnum[1])==0.0 &&
        coefficientlistden[length(coefficientlistden)]==0.0 &&
        sum(i->abs(coefficientlistnum[i]-coefficientlistden[i-1]),  
        2:length(coefficientlistden))==0.0
        newfixed=[(complex(0.0),complex(0.0))]
        morenewfixed=[(complex(1.0),complex(0.0))]
        fixed=["All the points are fixed points"]        
        return newfixed, morenewfixed, fixed
        else
        ffgg=pairoffunctions(coefficientlistnumcomplex, coefficientlistdencomplex)
        Polynumerator=Poly(coefficientlistnumcomplex)
        Polydenominator=Poly(coefficientlistdencomplex)
        Polyx=Poly([0.0+ 0.0* im,1.0+0.0*im])
        lookingzeros= Polynumerator- Polydenominator * Polyx
        fix=roots(lookingzeros)
        le=length(fix)
        fixed=[(complex(fix[i]),1.0+0.0*im) for i in 1:le]
            if abs(ffgg[1](complex(0.0),complex(0.0)))==0.0 && 
                abs(ffgg[2](complex(0.0),complex(0.0)))==0.0
                   newfixed=[(complex(0.0),complex(0.0))]
            else
           newfixed=[]
            end
            if abs(ffgg[1](complex(1.0),complex(0.0)))!=0.0 && 
            abs(ffgg[2](complex(1.0),complex(0.0)))==0.0
            morenewfixed=[(complex(1.0),complex(0.0))]
            else
            morenewfixed=[]
            end
    return newfixed, morenewfixed, fixed
    end
end

fixedPointsofaIrreduciblePairex=
fixedPointsofaIrreduciblePair(coefficientlistnumcompila,coefficientlistdencompila,9)[3]


function newstep(hpair::(Function,Function), 
                    iter::Int64,
                    minprecision::Int64,
                    iterprecision::Int64, 
                    hpoint::(Complex{Float64},Complex{Float64}))
    point = hpoint
    tol=1.0/10^(iterprecision)
    number = 0
    imagepoint = rationalFunction(hpair,point,minprecision)
    while (chordalMetric(point, imagepoint,iterprecision) > tol) && (number < iter)
    point = imagepoint
    imagepoint = rationalFunction(hpair,point,minprecision)
    number=number+1
    end
    return [imagepoint,number]
end

newstep(hpaircompila, 25, 15, 3, (1.0+0.0*im, 0.0+1.0*im))




#\subsection{Construction of position-interation arrays of
#a list of points} 


function rectangle(xinterval::(Float64,Float64)=(-1.5,1.5),
                    yinterval::(Float64,Float64)=(-1.5,1.5), 
                    expprecision=10)
    tol=1.0/(2^expprecision)
    a=xinterval[1]
    b=xinterval[2]
    c=yinterval[1]
    d=yinterval[2]
    red=[(complex(r,i),complex(1.0)) for i=d:-tol:c, r=a:tol:b]
    return red
end

rectanglecompila=rectangle((0.0,1.0),(0.0,1.0),1)

function invertedrectangle(xinterval::(Float64,Float64)=(-1.5,1.5),
                    yinterval::(Float64,Float64)=(-1.5,1.5), 
                    expprecision=10)
    tol=1.0/(2^expprecision)
    a=xinterval[1]
    b=xinterval[2]
    c=yinterval[1]
    d=yinterval[2]
    red=[(complex(1.0), complex(r,i)) for i=d:-tol:c, r=a:tol:b]
    return red
end

invertedrectanglecompila=invertedrectangle((0.0,1.0),(0.0,1.0),1)





function newstep(hpair::(Function,Function), 
                    iter::Int64,
                    minprecision::Int64,
                    iterprecision::Int64, 
                    hpoint::(Complex{Float64},Complex{Float64}))
    point = hpoint
    tol=1.0/10^(iterprecision)
    number = 0
    imagepoint = rationalFunction(hpair,point,iterprecision)
    while (chordalMetric(point, imagepoint,iterprecision) > tol) && (number < iter)
    point = imagepoint
    imagepoint = rationalFunction(hpair,point,minprecision)
    number=number+1
    end
    return [imagepoint,number]
end

newstep(hpaircompila, 25, 15, 3, (1.0+0.0*im, 0.0+1.0*im))






function newstep(hpair::(Function,Function), 
        iter::Int64,
        minprecision::Int64,
        iterprecision::Int64, 
    hrectangle::Array{(Complex{Float64},Complex{Float64}),2})
        size1=size(hrectangle)
        result=[newstep(hpair, iter,minprecision, iterprecision, hrectangle[i,j])
        for i=1:size1[1], j=1:size1[2]]
    return result
end

newstep(hpaircompila, 25,15, 3, rectanglecompila)

#\subsection{Construction of position-interation arrays of
#a list of points} 



function positionuptotolerance(fixedPointList::Array{(Complex{Float64},
                            Complex{Float64}),1},
                            minprecision::Int64,
                            aproxprecision::Int64, 
                            twotuple::(Complex{Float64},Complex{Float64}))
    pos=0
    it=1
    le = length(fixedPointList)
    tol=1/10^(aproxprecision)
    while (it < le+1)
        if (chordalMetric(twotuple, fixedPointList[it],minprecision) < tol)
            pos = it
        end
    it=it+1
    end
    return convert(Int64,pos)
end

positionuptotolerance(fixedPointsofaIrreduciblePairex,
15,3,(-0.5 - 0.28867513459481275im,1.0 + 0.0im) )


function iteration_upto_tolerances(hpair::(Function,Function), 
        iter::Int64,
        minprecision::Int64,
        iterprecision::Int64, 
        twotuple::(Complex{Float64},Complex{Float64}))
        endpoint_iterations=newstep(hpair, iter, minprecision, iterprecision, twotuple)
        iterations=convert(Int64,endpoint_iterations[2])
    return iterations
end

iteration_upto_tolerances(hpaircompila, 
11, 3, 2, (1.0+0.0*im, 0.0+1.0*im))

function iteration_upto_tolerances(hpair::(Function,Function), 
        iter::Int64,
        minprecision::Int64,
        iterprecision::Int64, 
        hrectangle::Array{(Complex{Float64},Complex{Float64}),2})
        size1=size(hrectangle)
        result=[iteration_upto_tolerances(hpair, iter, minprecision, iterprecision,hrectangle[i,j])
        for i=1:1size1[1], j=1:1:size1[2]]
    return result
end

iterrectangle=iteration_upto_tolerances(hpaircompila,11,15,3, rectanglecompila)


function position_iteration_upto_tolerances(hpair::(Function,Function),
        fixedPointList::Array{(Complex{Float64},Complex{Float64}),1}, 
        iter::Int64,
        tolerances::(Int64,Int64,Int64), 
        twotuple::(Complex{Float64},Complex{Float64}))
    minprecision=tolerances[1]
    iterprecision=tolerances[2]
    aproxprecision=tolerances[3]
    endpoint_iterations=newstep(hpair, iter, minprecision, iterprecision, twotuple)
    endpoint=endpoint_iterations[1]
    iterations=convert(Int64,endpoint_iterations[2])
    pos=positionuptotolerance(fixedPointList, minprecision, aproxprecision, endpoint)
    return pos, iterations
    endpoint
end

position_iteration_upto_tolerances(hpaircompila,fixedPointsofaIrreduciblePairex, 11, (15,3,2), (1.0+0.0*im, 0.0+1.0*im))




function position_iteration_upto_tolerances(hpair::(Function,Function),
        fixedPointList::Array{(Complex{Float64},Complex{Float64}),1}, 
        iter::Int64,
        tolerances::(Int64,Int64,Int64),
        hrectangle::Array{(Complex{Float64},Complex{Float64}),2})
    minprecision=tolerances[1]
    iterprecision=tolerances[2]
    aproxprecision=tolerances[3]
    size1=size(hrectangle)
    result=[position_iteration_upto_tolerances(hpair,fixedPointList, iter,
        tolerances, 
        hrectangle[i,j]) for i=1:size1[1], j=1:size1[2]]
    return result
end

position_iteration_upto_tolerances(hpaircompila,fixedPointsofaIrreduciblePairex,
11, (15,3,2), rectanglecompila)

function fixedPointListex_matrixpositioninterations_RationalFunction{T<:Number}(
        coefficientlistnum::Array{T,1},
        coefficientlistden::Array{T,1},
        expresolution::Int=8,
        iteration_max::Int=25,
        tolerances::(Int64,Int64,Int64)=(15,3,3),
        modeldomain::AbstractString="localrectangle",
        rectanglesidesdomain::(Float64,Float64,Float64,Float64)=(-1.5,1.5,-1.5,1.5))
    minprecision=tolerances[1]
    iterprecision=tolerances[2]
    aproxprecision=tolerances[3] 
    xinterv=(rectanglesidesdomain[1],rectanglesidesdomain[2])
    yinterv=(rectanglesidesdomain[3],rectanglesidesdomain[4])
    if modeldomain=="localrectangle"
        rect=rectangle(xinterv,  yinterv, expresolution)
    elseif modeldomain=="invertedlocalrectangle"
        rect=invertedrectangle(xinterv,  yinterv, expresolution)
    end    
        hpair=pairoffunctions(coefficientlistnum, coefficientlistden)
        coefficientlistnumcomplex=complex(coefficientlistnum)
        coefficientlistdencomplex=complex(coefficientlistden)
    fixedPointListexcomplete=fixedPointsofaIrreduciblePair(coefficientlistnumcomplex,
        coefficientlistdencomplex,
        minprecision)
    fixedPointListexcompletea=fixedPointListexcomplete[1]
    if length(fixedPointListexcomplete[2])==0
    fixedPointListexcompleteb=fixedPointListexcompletea
    else 
    fixedPointListexcompleteb=union(fixedPointListexcompletea,
        [(complex(1.0),complex(0.0))])
    end
    fixedPointListexample=union(fixedPointListexcompleteb,fixedPointListexcomplete[3])
    positer=position_iteration_upto_tolerances(hpair,fixedPointListexample,
    iteration_max, tolerances, rect)
    return   fixedPointListexcomplete, positer
end


fmf=fixedPointListex_matrixpositioninterations_RationalFunction(
coefficientlistnumcompila,coefficientlistdencompila,8)

function constructseed(issuperzero::Bool,
                    isinfinity::Bool,
                    numberofordinaryfixedpoint::Int64)
        if  issuperzero==false && isinfinity==false
        seed1=[RGB(0.0,0.0,0.0)];numberofcolors=numberofordinaryfixedpoint+1
        elseif  issuperzero==false && isinfinity==true
        seed1=[RGB(0.0,0.0,0.0),RGB(1.0,1.0,0.0)]; numberofcolors=numberofordinaryfixedpoint+2
        elseif  issuperzero==true && isinfinity==false
        seed1=[RGB(0.0,0.0,0.0),RGB(0.5,0.5,0.5)]; numberofcolors=numberofordinaryfixedpoint+2
        else
        seed1=[RGB(0.0,0.0,0.0),RGB(0.5,0.5,0.5),RGB(1.0,1.0,0.0)]
        numberofcolors=numberofordinaryfixedpoint+3
        end
    seed=union(seed1,[RGB(1.0,0.0,0.0),RGB(0.0,1.0,0.0),RGB(0.0,0.0,1.0)])
    gseed=distinguishable_colors(numberofcolors, seed)
    gseedtriple=[(gseed[i].r,gseed[i].g,gseed[i].b) for i in 1:length(gseed)]
    return gseedtriple , gseed
end


listofthreetuplesex=constructseed(true,true,4)[1]

#\subsection{Plotting  position-interation arrays of
#a list of points} 

function plot_2arrayofpairsofintergerspositer(
    matrixofpairs,
    plot_iteration_max::Int,
    listofthreetuples,
    therectanglesides::(Float64,Float64,Float64,Float64)=(-1.5,1.5,-1.5,1.5))
    ab=size(matrixofpairs) 
    twoarrayposition=[matrixofpairs[i,j][1] for i in 1:ab[1], j in 1:ab[2]]
    twoarrayiteration=[(1.0*(matrixofpairs[i,j][2])/plot_iteration_max)+0.4*(1-(matrixofpairs[i,j][2]/plot_iteration_max)) 
        for i in 1:ab[1], j in 1:ab[2]]
    twoarrayfourtuple=[(listofthreetuples[1+twoarrayposition[i,j]][1],
        listofthreetuples[1+twoarrayposition[i,j]][2],
        listofthreetuples[1+twoarrayposition[i,j]][3],
        twoarrayiteration[i,j]) for i in 1:ab[1], j in 1:ab[2]]
    img=PyPlot.imshow(twoarrayfourtuple, extent=[therectanglesides[1], 
        therectanglesides[2], 
        therectanglesides[3],therectanglesides[4]]) 
    return img
end


re=plot_2arrayofpairsofintergerspositer(fmf[2],25,listofthreetuplesex)



#\subsection{Plotting  position-interation arrays of
#a list of points} 

function plot_2arrayofintergers(
    matrixofintegers,
    consseed,
    therectanglesides::(Float64,Float64,Float64,Float64)=(-1.5,1.5,-1.5,1.5))
    ab=size(matrixofintegers) 
    function consseedtriple(consseedex,i)
        return  (consseedex[i].r,consseedex[i].g,consseedex[i].b)
    end     
    twoarraythreetuple=[consseedtriple(consseed,matrixofintegers[i,j]+1) for i in 1:ab[1], j in 1:ab[2]]
    img=PyPlot.imshow(twoarraythreetuple, extent=[therectanglesides[1], 
        therectanglesides[2], 
        therectanglesides[3],therectanglesides[4]]) 
    return  img
end

plot_2arrayofintergers(
    iterrectangle,
    distinguishable_colors(9))




function plot_2arrayofpairsofintergers(
    matrixofpairs,
    listofthreetuples,
    therectanglesides::(Float64,Float64,Float64,Float64)=(-1.5,1.5,-1.5,1.5))
    ab=size(matrixofpairs) 
    twoarraythreetuple=[listofthreetuples[1+matrixofpairs[i,j][1]] for i in 1:ab[1], j in 1:ab[2]]
    img=PyPlot.imshow(twoarraythreetuple, extent=[therectanglesides[1], 
        therectanglesides[2], 
        therectanglesides[3],therectanglesides[4]]) 
    return   img
end




function plottingBasinsUnivariateRationalFunctions{T<:Number}(
    coefficientlistnum::Array{T,1},
    coefficientlistden::Array{T,1},
    expresolution::Int=8,
    iterationmax::Int=25,
    tolerances::(Int64,Int64,Int64)=(15,3,3);
    colorstrategy::AbstractString="positionplusiteration",
    model::AbstractString="localrectangle",
    rectanglesides::(Float64,Float64,Float64,Float64)=(-1.5,1.5,-1.5,1.5))
    minprecision=tolerances[1]
    iterprecision=tolerances[2]
    aproxprecision=tolerances[3]
    maxdegree=max(length(coefficientlistnum),length(coefficientlistden))
    samedegreecoefficientlistnum=zeros(Complex{Float64}, maxdegree)
    for i in 1:length(coefficientlistnum)
        samedegreecoefficientlistnum[i]=coefficientlistnum[i]
    end
    samedegreecoefficientlistden=zeros(Complex{Float64}, maxdegree)
    for i in 1:length(coefficientlistden)
        samedegreecoefficientlistden[i]=coefficientlistden[i]
    end
    if model=="localrectangle"
    hrectangle=rectangle((rectanglesides[1],rectanglesides[2]),
                    (rectanglesides[3],rectanglesides[4]), 
                    expresolution)
    else model=="invertedlocalrectangle"
    hrectangle=invertedrectangle((rectanglesides[1],rectanglesides[2]),
                    (rectanglesides[3],rectanglesides[4]), 
                    expresolution)
        #return hrectangle
    end
    modeldomain=model
    hpair=pairoffunctions(samedegreecoefficientlistnum, 
    samedegreecoefficientlistden)
        if colorstrategy=="iteration"
        consseed=distinguishable_colors(iterationmax+1)
        matrixofintegers=iteration_upto_tolerances(hpair::(Function,Function), 
                                                    iterationmax,
                                                    minprecision,
                                                    iterprecision, 
                                                    hrectangle)
        fig=plot_2arrayofintergers(
                    matrixofintegers,
                    consseed,
                    rectanglesides)
                    consseed
        elseif colorstrategy=="positionfixedpoints" || colorstrategy=="positionplusiteration"
        fixedpoints_matrixofpairs=fixedPointListex_matrixpositioninterations_RationalFunction(
                                    samedegreecoefficientlistnum,
                                    samedegreecoefficientlistden,
                                    expresolution,
                                    iterationmax,
                                    tolerances,
                                    modeldomain,
                                    rectanglesides)
        fixedpoints=fixedpoints_matrixofpairs[1]
        matrixofpairs=fixedpoints_matrixofpairs[2]
        fixedpointsa=fixedpoints[1]
        fixedpointsb=fixedpoints[2]
        fixedpointsc=fixedpoints[3]
        listofthreetuples=constructseed(
                    length(fixedpointsa)==1,
                    length(fixedpointsb)==1,
                    length(fixedpointsc))
            if colorstrategy=="positionfixedpoints"
            fig=plot_2arrayofpairsofintergers(
                        matrixofpairs,
                        listofthreetuples[1],
                        rectanglesides)
            #listofthreetuples[2]
            end
            if colorstrategy=="positionplusiteration"
            fig=plot_2arrayofpairsofintergerspositer(
                                matrixofpairs,
                                iterationmax,
                                 listofthreetuples[1],
                                rectanglesides)
             #listofthreetuples[2]
            end
        return fixedpoints, listofthreetuples[2]
        end

end

result=plottingBasinsUnivariateRationalFunctions(coefficientlistnumcompila,
    coefficientlistdencompila;colorstrategy="positionplusiteration")


function instructions()
    a="This is the package GVBURF. If coefficientlistnum is the list"
    b="of the coefficients of the numerator of a univariate rational" 
    c="function and coefficientlistden is the list of the coefficients"
    d="of the denominator, one can plot the basins of the function typing the command:" 
    e="plottingBasinsUnivariateRationalFunctions(coefficientlistnum,coefficientlistden)"
    println(" ")
    println(a)
    println(b)
    println(c)
    println(d)
    println(" ")
    println(e) 
end

instructions()

