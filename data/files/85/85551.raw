#the bump function reaches its maximum for t = shape*scale (obtained by differentiating the function)
_bumpvalmaximum{T<:AbstractFloat}(amplitude::T,shape::T,scale::T) = shape*scale

###Calculate a bump value for a single time point
_bumpval{T<:AbstractFloat}(amplitude::T,shape::T,scale::T,t::T) = @fastmath amplitude*exp(shape*(1 - log(shape) + log(t/scale)) - t/scale)

###Calculate the bump (current) which results from a single photon
function _bump!{T<:AbstractFloat}(amplitude::T,shape::T,scale::T,bumpvals::Vector{T})
  @simd for t=1:length(bumpvals)
    @inbounds bumpvals[t] = _bumpval(amplitude,shape,scale,T(t))
  end
  bumpvals
end

bump!{T<:AbstractFloat}(amplitude::T,shape::T,scale::T,bumpvals::Vector{T}) = _bump!(amplitude,shape,scale,bumpvals)
bump{T<:AbstractFloat}(amplitude::T,shape::T,scale::T,len::Int) = _bump!(amplitude,shape,scale,Vector{T}(len))
function bump{T<:AbstractFloat}(amplitude::T,shape::T,scale::T,tol::T =T(0.025))
  @assert tol > zero(T)
  t::Int = trunc(Int,_bumpvalmaximum(amplitude,shape,scale)*2)+1 #check for increasing t, starting from twice the maximum time of the bump function
  while _bumpval(amplitude,shape,scale,T(t)) > tol
    t+=1
  end
  _bump!(amplitude,shape,scale,Vector{T}(t-1))
end

###Calculate the macrocurrent generated by a sequence of photons (internal function)
function _macrocurrent!{T<:AbstractFloat}(photons::Vector{Int},bumpvals::Vector{T},current::Vector{T})
  bumplength = length(bumpvals)
  nsteps = length(photons)
  @simd for i = 1:nsteps-bumplength
    @inbounds p = T(photons[i])
     @simd for j = 1:bumplength
       @inbounds current[i+j-1] += p*bumpvals[j]
     end
  end
  @simd for i=nsteps-bumplength+1:nsteps
    @inbounds p = T(photons[i])
    @simd for j = 1:nsteps-i+1
      @inbounds current[i+j-1] += p*bumpvals[j]
    end
  end
  current
end

function macrocurrent!{T<:AbstractFloat}(photons::Vector{Int},bumpvals::Vector{T},current::Vector{T})
  @assert length(photons) == length(current)
  _macrocurrent!(photons,bumpvals,current)
end

macrocurrent{T<:AbstractFloat}(photons::Vector{Int},bumpvals::Vector{T}) = macrocurrent!(photons,bumpvals,zeros(T,length(photons)))



function lightinducedcurrent(receptor::PhotoReceptor,bumpvals::Vector{Float64},latpdf::Distributions.Distribution,refpdf::Distributions.Distribution)

  nsteps = numsteps(receptor)
  nvilli = numvilli(receptor)
  bumplength = length(bumpvals)
  filteredphotons = zeros(Int,nsteps)
  refractimes = zeros(Int,nvilli)

  for t=1:nsteps
    @inbounds microvilli = microvilliwithphotons(receptor,t)
    @simd for i = 1:length(microvilli)
      @inbounds m = microvilli[i]
      @inbounds if refractimes[m] < t
        @fastmath l = trunc(Int,rand(latpdf))
        if t + l <= nsteps
          @fastmath r = trunc(Int,rand(refpdf))
          @inbounds filteredphotons[t+l] += 1
          @inbounds refractimes[m] += bumplength + l + r
        end
      end
    end
  end

  macrocurrent(filteredphotons,bumpvals)
end



