using LightGraphs

# This file generated the Markdown documentation files.

# The @file macro generates the documentation for a particular file
# where the {{method1, methods2}} includes the documentation for each method
# via the `buildwriter` function.

# Currently this prints the methodtable followed by the docstring.

macro file(args...) buildfile(args...) end

buildfile(t, s::AbstractString) = buildfile(t, Expr(:string, s))

buildfile(target, source::Expr) = quote
    open(joinpath(dirname(@__FILE__), $(esc(target))), "w") do file
        println(" - '$($(esc(target)))'")
        println(file, "<!-- AUTOGENERATED. See 'doc/build.jl' for source. -->")
        $(Expr(:block, [buildwriter(arg) for arg in source.args]...))
    end
end

buildwriter(ex::Expr) = :(print(file, $(esc(ex))))

buildwriter(t::AbstractString) = Expr(:block,
    [buildwriter(p, iseven(n)) for (n, p) in enumerate(split(t, r"{{|}}"))]...
)

buildwriter(part, isdef) = isdef ?
    begin
        parts = Expr(:vect, [:(($(parse(p))), @doc($(parse(p)))) for p in split(part, r"\s*,\s*")]...)
        quote
            for (f, docstring) in $(esc(parts))
                if isa(f, Function)
                    md_methodtable(file, f)
                end
                writemime(file, "text/plain", docstring)
                println(file)
            end
        end
    end :
    :(print(file, $(esc(part))))

function md_methodtable(io, f)
    println(io, "### ", first(methods(f)).func.code.name)
    println(io, "```")
    for m in methods(f)
        md_method(io, m)
    end
    println(io, "```")
end
function md_method(io, m)
    # We only print methods with are defined in the parent (project) directory
    pd = joinpath(Pkg.dir(), string(module_name(LightGraphs)))
    if !(startswith(string(m.func.code.file), pd))
        return
    end
    print(io, m.func.code.name)
    tv, decls, file, line = Base.arg_decl_parts(m)
    if !isempty(tv)
        Base.show_delim_array(io, tv, '{', ',', '}', false)
    end
    print(io, "(")
    print_joined(io, [isempty(d[2]) ? "$(d[1])" : "$(d[1])::$(d[2])" for d in decls],
                 ", ", ", ")
    print(io, ")")
    println(io)
end

@file "about.md" "{{LightGraphs}}"
@file "basicmeasures.md" """
The following basic measures have been implemented for `Graph` and `DiGraph`
types:

## Vertices and Edges

{{vertices, edges, is_directed, nv, ne, has_edge, has_vertex, in_edges, out_edges, src, dst, reverse}}

## Neighbors and Degree

{{degree, indegree, outdegree, Δ, δ, Δout, δout, δin, Δin, degree_histogram, density, neighbors, in_neighbors, all_neighbors, common_neighbors}}
"""

@file "centrality.md" """
# Centrality Measures

[Centrality measures](https://en.wikipedia.org/wiki/Centrality) describe the
importance of a vertex to the rest of the graph using some set of criteria.
Centrality measures implemented in *LightGraphs.jl* include the following:

## Degree Centrality

{{degree_centrality, indegree_centrality, outdegree_centrality}}

### Closeness Centrality

{{closeness_centrality}}

## Betweenness Centrality

{{betweenness_centrality}}

## Katz Centrality

{{katz_centrality}}

## PageRank

{{pagerank}}
"""

@file "distance.md" """
*LightGraphs.jl* includes the following distance measurements:

{{eccentricity, radius, diameter, center, periphery}}
"""

@file "generators.md" """
### Random Graphs
*LightGraphs.jl* implements three common random graph generators:

{{erdos_renyi, watts_strogatz, random_regular_graph, random_regular_digraph}}

### Static Graphs
*LightGraphs.jl* also implements a collection of classic graph generators:

{{CompleteGraph, CompleteDiGraph, StarGraph, StarDiGraph,PathGraph, PathDiGraph, WheelGraph, WheelDiGraph}}

The following graphs are undirected only:

{{DiamondGraph, BullGraph, ChvatalGraph, CubicalGraph, DesarguesGraph, DodecahedralGraph, FruchtGraph, HeawoodGraph, HouseGraph, HouseXGraph, IcosahedralGraph, KrackhardtKiteGraph, MoebiusKantorGraph, OctahedralGraph, PappusGraph, PetersenGraph, SedgewickMazeGraph, TetrahedralGraph, TruncatedCubeGraph, TruncatedTetrahedronGraph, TutteGraph}}
"""

@file "gettingstarted.md" """
### Core Concepts
A graph *G* is described by a set of vertices *V* and edges *E*:
*G = {V, E}*. *V* is an integer range `1:n`; *E* is stored as a set
of `Edge` types containing `Pair(Int, Int)` values. Edge
relationships are stored as forward and backward adjacency vectors, indexed by
vertex.

*LightGraphs.jl* provides two graph types: `Graph` is an undirected graph, and
`DiGraph` is its directed counterpart.

Graphs are created using `Graph()` or `DiGraph()`; there are several options
(see below for examples).

Edges are added to a graph using `add_edge!(g, e)`. Instead of an edge type
integers may be passed denoting the source and destination vertices (e.g.,
`add_edge!(g, 1, 2)`).

Edges must be unique; an attempt to add an edge that already exists in the graph
will result in an error.

Edges may be removed using `rem_edge!(g, e)`. Alternately, integers may be passed
denoting the source and destination vertices (e.g., `rem_edge!(g, 1, 2)`). Note
that, particularly for very large graphs, edge removal is a (relatively)
expensive operation.

An attempt to remove an edge that does not exist in the graph will result in an
error.

Edge distances for most traversals may be passed in as a sparse or dense matrix
of  values, indexed by `[src,dst]` vertices. That is, `distmx[2,4] = 2.5`
assigns the distance `2.5` to the (directed) edge connecting vertex 2 and vertex 4.
Note that for undirected graphs, `distmx[4,2]` should also be set.

Edge distances for undefined edges are ignored.


### Installation
Installation is straightforward:
```julia
julia> Pkg.install("LightGraphs")
```

*LightGraphs.jl* requires the following packages:

- [Compat](https://github.com/JuliaLang/Compat.jl)
- [GZip](https://github.com/JuliaLang/GZip.jl)
- [StatsBase](https://github.com/JuliaStats/StatsBase.jl)
- [Docile](https://github.com/MichaelHatherly/Docile.jl)

In addition, [LightXML](https://github.com/JuliaLang/LightXML.jl) is
recommended (required for GraphML support).

### Usage Examples
(all examples apply equally to `DiGraph` unless otherwise noted):

```julia
# create an empty undirected graph
g = Graph()

# create a 10-node undirected graph with no edges
g = Graph(10)

# create a 10-node undirected graph with 30 randomly-selected edges
g = Graph(10,30)

# add an edge between vertices 4 and 5
add_edge!(g, 4, 5)

# remove an edge between vertices 9 and 10
rem_edge!(g, 9, 10)

# get the neighbors of vertex 4
neighbors(g, 4)

# show distances between vertex 4 and all other vertices
dijkstra_shortest_paths(g, 4).dists

# as above, but with non-default edge distances
distmx = zeros(10,10)
distmx[4,5] = 2.5
distmx[5,4] = 2.5
dijkstra_shortest_paths(g, 4, distmx=distmx).dists

# graph I/O
g = readgraph("mygraph.jgz")
write(g,"mygraph.jgz")
```
"""

@file "index.md" """
# LightGraphs.jl

[![Build Status](https://travis-ci.org/JuliaGraphs/LightGraphs.jl.svg?branch=master)](https://travis-ci.org/JuliaGraphs/LightGraphs.jl)
[![Coverage Status](https://coveralls.io/repos/JuliaGraphs/LightGraphs.jl/badge.svg?branch=master)](https://coveralls.io/r/JuliaGraphs/LightGraphs.jl?branch=master)
[![LightGraphs](http://pkg.julialang.org/badges/LightGraphs_release.svg)](http://pkg.julialang.org/?pkg=LightGraphs&ver=release)
[![LightGraphs](http://pkg.julialang.org/badges/LightGraphs_0.4.svg)](http://pkg.julialang.org/?pkg=LightGraphs&ver=nightly)
[![Documentation Status](https://readthedocs.org/projects/lightgraphsjl/badge/?version=latest)](https://readthedocs.org/projects/lightgraphsjl/?badge=latest)
[![Join the chat at https://gitter.im/JuliaGraphs/LightGraphs.jl](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/JuliaGraphs/LightGraphs.jl)


An optimized graphs package.

Simple graphs (not multi- or hypergraphs) are represented in a memory- and time-efficient
manner with incidence lists and edge sets. Both directed and undirected graphs are supported via separate types, and conversion is available from directed to undirected.
"""

@file "integration.md" """
*LightGraphs.jl*'s integration with other Julia packages is designed to be straightforward. Here are a few examples.

### [Graphs.jl](http://github.com/JuliaLang/Graphs.jl)
Creating a Graphs.jl `simple_graph` is easy:
```julia
julia> s = simple_graph(nv(g), is_directed=LightGraphs.is_directed(g))
julia> for e in LightGraphs.edges(g)
           add_edge!(s,src(e), dst(e))
       end
```

### [GraphLayout.jl](https://github.com/IainNZ/GraphLayout.jl)
This excellent graph visualization package can be used with *LightGraphs.jl*
as follows:

```julia
julia> g = WheelGraph(10); am = full(adjacency_matrix(g))
julia> loc_x, loc_y = layout_spring_adj(am)
julia> draw_layout_adj(am, loc_x, loc_y, filename="wheel10.svg")
```
producing a graph like this:
![Wheel Graph](https://cloud.githubusercontent.com/assets/941359/8960521/35582c1e-35c5-11e5-82d7-cd641dff424c.png)

###[TikzGraphs.jl](https://github.com/sisl/TikzGraphs.jl)
Another nice graph visulaization package. ([TikzPictures.jl](https://github.com/sisl/TikzPictures.jl)
required to render/save):
```julia
julia> g = WheelGraph(10); t = plot(g)
julia> save(SVG("wheel10.svg"), t)
```
producing a graph like this:
![Wheel Graph](https://cloud.githubusercontent.com/assets/941359/8960499/17f703c0-35c5-11e5-935e-044be51bc531.png)

###[Metis.jl](https://github.com/JuliaSparse/Metis.jl)
The Metis graph partitioning package can interface with *LightGraphs.jl*:

```julia
julia> g = Graph(100,1000)
{100, 1000} undirected graph

julia> partGraphKway(g, 6)  # 6 partitions
```
"""

@file "linalg.md" """
*LightGraphs.jl* provides the following matrix operations on both directed and
undirected graphs:

## Adjacency

{{adjacency_matrix, adjacency_spectrum}}

## Laplacian

{{laplacian_matrix, laplacian_spectrum}}
"""

@file "operators.md" """
*LightGraphs.jl* implements the following graph operators. In general,
functions with two graph arguments will require them to be of the same type
(either both `Graph` or both `DiGraph`).

{{complement, reverse, reverse!, blkdiag, intersect, difference, symmetric_difference, union, induced_subgraph}}
"""

@file "pathing.md" """
*LightGraphs.jl* provides several traversal and shortest-path algorithms, along with
various utility functions. Where appropriate, edge distances may be passed in as a
matrix of real number values. The matrix should be indexed by `[src, dst]` (see [Getting Started](gettingstarted.html) for more information).

## Graph Traversal

*Graph traversal* refers to a process that traverses vertices of a graph following certain order (starting from user-input sources). This package implements three traversal schemes:
* `BreadthFirst`,
* `DepthFirst`, and
* `MaximumAdjacency`.

{{bfs_tree, dfs_tree}}

## Connectivity / Bipartiteness
`Graph connectivity` functions are defined on both undirected and directed graphs:

{{is_connected, is_strongly_connected, is_weakly_connected, connected_components, strongly_connected_components, weakly_connected_components, has_self_loop, attracting_components, is_bipartite, condensation, period}}

## Cycle Detection
In graph theory, a cycle is defined to be a path that starts from some vertex
`v` and ends up at `v`.

{{is_cyclic}}

##Simple Minimum Cut
Stoer's simple minimum cut gets the minimum cut of an undirected graph.

{{mincut, maximum_adjacency_visit}}

## Shortest-Path Algorithms
### General properties of shortest path algorithms
*  The distance from a vertex to itself is always `0`.
* The distance between two vertices with no connecting edge is always `Inf`.

{{a_star, dijkstra_shortest_paths, bellman_ford_shortest_paths, bellman_ford_shortest_paths, floyd_warshall_shortest_paths}}

## Path discovery / enumeration

{{gdistances, gdistances!, enumerate_paths}}

For Floyd-Warshall path states, please note that the output is a bit different,
since this algorithm calculates all shortest paths for all pairs of vertices: `enumerate_paths(state)` will return a vector (indexed by source vertex) of
vectors (indexed by destination vertex) of paths. `enumerate_paths(state, v)`
will return a vector (indexed by destination vertex) of paths from source `v`
to all other vertices. In addition, `enumerate_paths(state, v, d)` will return
a vector representing the path from vertex `v` to vertex `d`.

### Path States
The `floyd_warshall_shortest_paths`, `bellman_ford_shortest_paths`,
`dijkstra_shortest_paths`, and `dijkstra_predecessor_and_distance` functions
return a state that contains various information about the graph learned during
traversal. The three state types have the following common information,
accessible via the type:

`.dists`
Holds a vector of distances computed, indexed by source vertex.

`.parents`
Holds a vector of parents of each source vertex. The parent of a source vertex
is always `0`.

In addition, the `dijkstra_predecessor_and_distance` function stores the
following information:

`.predecessors`
Holds a vector, indexed by vertex, of all the predecessors discovered during
shortest-path calculations. This keeps track of all parents when there are
multiple shortest paths available from the source.

`.pathcounts`
Holds a vector, indexed by vertex, of the path counts discovered during
traversal. This equals the length of each subvector in the `.predecessors`
output above.
"""

@file "persistence.md" """
## Writing a Graph
Graphs may be written to I/O streams and files using the `write` function:

{{write}}

## Reading a Graph From a File
Graphs stored using the `write` functions above may be loaded using `readgraph`:

{{readgraph, readgraphml, readgml}}

## Examples
```julia
julia> write(STDOUT, g)
julia> write(g, "mygraph.jgz")
julia> g = readgraph("mygraph.jgz")
julia> g = readgraphml("mygraph.xml")
julia> g = readgml("mygraph.gml")
```
"""
