#= SWC format
uid | structure id | x | y | z | radius | parent uid

where structure id:
* 1 = soma
* 2 = axon
* 3 = basal dendrite
* 4 = apical dendrite
* 5+ = custom

=#

import LightGraphs

function read_neurite(n::Int; datadir="../data/neuromorph")
    list = readdir(datadir)
    n < length(list) || error("n must be less than ", 1+length(list))
    readdlm(joinpath(datadir, list[n]))
end

function neurite_tree(neurite::Array{Float64,2})
    L = LightGraphs
    g = L.Graph()
    n = size(neurite,1)
    all(neurite[:,1]==collect(1.0:n)) || error("Vertices are not sequentially ordered with origin 1.")
    for i in 1:size(neurite,1)
        L.add_vertex!(g)
        parent = Int(neurite[i,7])
        if 0 < parent < i
            L.add_edge!(g,parent,i)
        end
    end
    g
end

function neurite_tree(n::Int; datadir="../data/neuromorph")
    neurite_tree(readneurite(n,datadir))
end

function branch_points(g::LightGraphs.Graph)
    L = LightGraphs
    find([L.degree(g,i) > 2 for i in L.vertices(g)])
end

function leaves(g::LightGraphs.Graph)
    L = LightGraphs
    find([L.degree(g,i) == 1 &&
          all(L.neighbors(g,i).< i) for i in L.vertices(g)])
end

function euclidean_distance(neurite::Array{Float64,2}, i, j)
    delta = neurite[i,3:5]-neurite[j,3:5]
    sqrt(sum(delta.^2))
end

function all_distances(neurite::Array{Float64,2})
    all(neurite[:,7] .< neurite[:,1]) || error("nodes must be in breadth-first order")
    n = size(neurite,1)
    route = zeros(Float64, n)
    euclidean = zeros(Float64, n)
    for i in 2:n
        parent = Int(neurite[i,7])
        route[i] = route[parent] +
            euclidean_distance(neurite,i,parent)
        euclidean[i] = euclidean_distance(neurite,i,1)
    end
    return route, euclidean
end

""" route_factor(neurite)
Compute the average ratio of straight-line Euclidean distance from a branch point or leaf to the root.
"""
function route_factor(neurite::Array{Float64,2};
                      tree::LightGraphs.Graph = neurite_tree(neurite),
                      branches::Array{Int,1} = branch_points(tree),
                      leavz::Array{Int,1} = leaves(tree))
    route, euclidean = all_distances(neurite)
    indices = find(euclidean .!= 0.0)
    return mean(route[indices]./euclidean[indices])
end
