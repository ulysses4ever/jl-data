"""
A Julia port of [community_structure.m](https://sites.google.com/site/bctnet/measures/list#TOC-Clustering-and-Community-Structure), a Matlab script by Mike Rubinov of U. Cambridge implementing a fast and accurate multi-iterative generalization of the original Louvain algorithm. The referenced script is part of the [Brain Connectivity Toolbox]().

* W, a weighted, directed connection matrix. Negative weights are allowed.
* gamma, a resolution parameter
  + gamma > 1 detects smaller modules
  + 0 <= gamma < 1 detects larger modules
  + gamma = 1 detects classic modules and is the default
* M0, initial community affiliation vector (optional)
* B, objective function type or custom objective matrix (optional)
  + :modularity, modularity (the default)
  + :potts,      Potts-model Hamiltonian (for binary networks)
  + :negative_sym, symmetric treatment of negative weights
  + :negative_asym, asymmetric treatment of negative weights

The Matlab implementation cites the following:

* Blondel et al. (2008)  J. Stat. Mech. P10008.
* Reichardt and Bornholdt (2006) Phys. Rev. E 74, 016110.
* Ronhovde and Nussinov (2008) Phys. Rev. E 80, 016109
* Sun et al. (2008) Europhysics Lett 86, 28004.
* Rubinov and Sporns (2011) Neuroimage 56:2068-79.

"""
function community_louvain{Tw<:Real,
                           Tg<:Real,
                           Tm<:Real,
                           Tb<:Real}(W::Matrix{Tw};
                                     gamma::Tg=1,
                                     M0::Vector{Tm}=
                                     collect(1:size(W,1)),
                                     B::Matrix{Tb}=zeros(W),
                                     option::Symbol=
                                     B==zeros(W) ? :custom :
                                     :modularity)
    s = sum(W) # total weight of edges
    n = size(W,1) # number of nodes
    if option == :modularity
        B = (W.-gamma*sum(W,2)*sum(W,1)/s)/s
    elseif option == :potts
        for w in W
            w == 1 || w == 0 || error("For the :potts option W must be binary.")
        end
        B = W - gamma*(1.-W)
    elseif option == :negative_sym || option == :negative_asym
        W0 = W.*(W.>0)
        s0 = sum(W0)
        B0 = W0.-gamma*sum(W0,2)*sum(W0,1)/s0
        W1 = -W.*(W.<0)
        s1 = sum(W1)
        B1 = s1 != 0 ? W1.-gamma*sum(W1,2)*sum(W1,1)/s1 :
            zeros(W1)
        B = (B0-B1)/(s0+s1)
    elseif option == :custom
    else
        error("Option must be one of :modularity, :potts, :negative_sym, :negative_asym, or :custom")
    end

end
