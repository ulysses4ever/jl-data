"""
A Julia port of [community_structure.m](https://sites.google.com/site/bctnet/measures/list#TOC-Clustering-and-Community-Structure), a Matlab script by Mike Rubinov of U. Cambridge implementing a fast and accurate multi-iterative generalization of the original Louvain algorithm. The referenced script is part of the [Brain Connectivity Toolbox]().

* W, a weighted, directed connection matrix. Negative weights are allowed.
* gamma, a resolution parameter
  + gamma > 1 detects smaller modules
  + 0 <= gamma < 1 detects larger modules
  + gamma = 1 detects classic modules and is the default
* M0, initial community affiliation vector (optional)
* B, objective function type or custom objective matrix (optional)
  + :modularity, modularity (the default)
  + :potts,      Potts-model Hamiltonian (for binary networks)
  + :negative_sym, symmetric treatment of negative weights
  + :negative_asym, asymmetric treatment of negative weights

The Matlab implementation cites the following:

* Blondel et al. (2008)  J. Stat. Mech. P10008.
* Reichardt and Bornholdt (2006) Phys. Rev. E 74, 016110.
* Ronhovde and Nussinov (2008) Phys. Rev. E 80, 016109
* Sun et al. (2008) Europhysics Lett 86, 28004.
* Rubinov and Sporns (2011) Neuroimage 56:2068-79.

"""
function community_louvain{Tw<:Real,
                           Tg<:Real,
                           Tm<:Real,
                           Tb<:Real}(W::Matrix{Tw};
                                     gamma::Tg=1,
                                     M0::Vector{Tm}=
                                     collect(1:size(W,1)),
                                     B::Matrix{Tb}=zeros(W),
                                     option::Symbol=
                                     B==zeros(W) ? :custom :
                                     :modularity)
    s = sum(W) # total weight of edges
    n = size(W,1) # number of nodes
    length(M0) == n || error("M0 must have length ",n)
    size(W)==size(B) || error("W and B must be the same size")
    if option == :modularity
        B = (W.-gamma*sum(W,2)*sum(W,1)/s)/s
    elseif option == :potts
        for w in W
            w == 1 || w == 0 || error("For the :potts option W must be binary.")
        end
        B = W - gamma*(1.-W)
    elseif option == :negative_sym || option == :negative_asym
        W0 = W.*(W.>0)
        s0 = sum(W0)
        B0 = W0.-gamma*sum(W0,2)*sum(W0,1)/s0
        W1 = -W.*(W.<0)
        s1 = sum(W1)
        B1 = s1 != 0 ? W1.-gamma*sum(W1,2)*sum(W1,1)/s1 :
            zeros(W1)
        B = (B0-B1)/(s0+s1)
    elseif option == :custom
    else
        error("Unrecognized option ",option,". Option must be one of :modularity, :potts, :negative_sym, :negative_asym, or :custom")
    end
    # The Matlab original uses [~,~,Mb] = unique(M0).
    # Mb in this case has the same length as M0 and contains
    # the index (in Julia's version of unique) of each unique
    # element of M0.
    temp = unique(M0)
    Mb = [findfirst(temp,x) for x in M0]
    M = deepcopy(Mb)
    B = (B + B')/2
    Hnm = zeros(n,n)
    for m in 1:maximum(Mb)
        Hnm[:,m] = sum(B[:,Mb.==m],2)
    end
    Q0 = -Inf
    # The Matlab original uses Q = sum(B(bsxfun(@eq,M0,M0')))
    # The result, say X,  of  bsxfun(@eq,M0,M0') is an nxn matrix
    # whose i,jth entry is 1 if M0[i] == M0[j], else 0.
    # B(X) is a vector of all B[i,j] for which X[i,j]==1. The
    # ultimate result is the sum of all B[i,j] for which
    # M0[i]==M0[j]. In Julia this is easier to do directly.
    Q = 0
    for i in 1:n, j in 1:n
        if M0[i]==M0[j] Q += B[i,j] end
    end
    
end
