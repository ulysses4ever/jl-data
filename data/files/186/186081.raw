#=
Various numerical experiments vaguely related to reproducing kernel Hilbert spaces.
=#

import Distributions

function stickbreak(x::Array{Float64,1}, range::UnitRange{Int}, alpha::Real)
    a = rand(Distributions.Dirichlet(length(range),alpha),1)
    y = zeros(Real, length(x))
    for k in range
        u = 2*pi*rand(1)[1]
        y += a[k+1-range[1]]*cos(2*pi*k*x + u)
    end
    return y,a
end

"""
Mat√©rn covariance function
"""
function matern(nu::Real, sigma::Real, rho::Real, d::Real)
    x = sqrt(2*nu)*d/rho
    (sigma^2*2.0^(1.0-nu)/gamma(nu))*x^nu*besselk(nu,x)
end

"""
Gaussian kernel
"""
function gaussian_kernel{T1<:Real, T2<:Real, T3<:Real}(x::Array{T1,1}, y::Array{T2,1}, sigma::T3)
    exp(-sum(((x-y)/sigma).^2/2))
end

#=
# Given an axis of rotation, u, and an angle, theta, return a 3x3 matrix
# representing rotation about u by theta, assuming the right-hand rule.
rotationMatrix <- function(u, theta){
  if(!is.numeric(u) | !is.vector(u) | 
       length(u) != 3)stop("axis of rotation must be a 3-vector")
  if(!is.numeric(theta) | length(theta) != 1)stop("theta must be a number")
  normu <- sqrt(sum(u^2))
  if(!isTRUE(all.equal(theta,0)) & 
       isTRUE(all.equal(normu, 0)))stop("axis of rotation cannot be zero unless theta is zero")
  if(normu > 0) u <- u/normu
  N <- matrix(c(0, u[3], -u[2], c, u[2], -u[1], 0), 3, 3)
  diag(1, 3, 3) + sin(theta)*N + (1-cos(theta))*(N %*% N)
}
=#

function rotationMatrix{T<:Real}(u::Array{T,1},theta::Float64)
    length(u) == 3 || error("axis of rotation, u must have length 3")
    normu = sqrt(sum(u.^2))
    if isapprox(normu,0.0) && !isapprox(theta, 0.0)
        error("axis of rotation, u, cannot be zero unless angle of rotation, theta, is zero")
    end
    u = u/normu
    N = reshape([0, u[3], -u[2], -u[3], 0, u[1], u[2], -u[1], 0],(3,3))
    eye(3) + sin(theta)*N + (1-cos(theta))*(N*N)
end
