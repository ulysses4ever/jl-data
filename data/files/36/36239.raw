module MeshModificationModule

using JFFoundationModule: JFInt, JFFlt, JFFltVec, JFIntVec, JFFltMat, JFIntMat

using FENodeSetModule
using FESetModule

function meshboundary (fes::FESetModule.FESet)
    # Extract the boundary finite elements from a mesh.
    #
    # function bdry_fes = mesh_boundary(fes, options)
    #
    # Extract the finite elements of manifold dimension (n-1) from the
    # supplied list of finite elements of manifold dimension (n).
    #    options = struct with any attributes that should be passed to the
    #    constructor of the boundary finite elements
    # 
    
    # Form all hyperfaces, non-duplicates are boundary cells
    hypf= FESetModule.boundaryconn(fes);    # get the connectivity of the boundary elements
    bdryconn =myunique(hypf);
    make = FESetModule.boundaryfe(fes);     # get the function that can make a boundary element
    
    return make(conn =bdryconn);
end


function  myunique(A::JFIntMat)
    sA=sort(A,2);
    sA= [sA (1:size(A,1))+maximum(A[:])]
    sA  = sortrows(sA);;
    rix=sA[:,end]; rix=rix[:]-maximum(A[:]);
    sA=sA[:,1:end-1];
    d=(sA[1:end-1,:].!=sA[2:end,:]); # element-wise comparison!
    ad=map((x) -> (x?1:0),[true; any(d,2)]);
    iu =map((x) -> (x>1? true: false),(ad + [ad[2:end];1]));
    Out =A[rix[iu[:]],:];
    return Out
end


function fusenodes(fens1::FENodeSetModule.FENodeSet, fens2::FENodeSetModule.FENodeSet, tolerance:: JFFlt)
    # % Fuse together nodes from two node sets.
    # %
    # % function [fens,new_indexes_of_fens1_nodes] = fuse_nodes(fens1, fens2, tolerance)
    # %
    # % Fuse two node sets. If necessary, by gluing together nodes located within tolerance of each other.
    # % The two node sets, fens1 and fens2,  are fused together by
    # % merging the nodes that fall within a box of size "tolerance".
    # % The merged node set, fens, and the new  indexes of the nodes
    # % in the set fens1 are returned.
    # %
    # % The set fens2 will be included unchanged, in the same order,
    # % in the node set fens.
    # %
    # % The indexes of the node set fens1 will have changed.
    # %
    # % Example: 
    # % After the call to this function we have
    # % k=new_indexes_of_fens1_nodes(j) is the node in the node set fens which
    # % used to be node j in node set fens1.
    # % The finite element set connectivity that used to refer to fens1
    # % needs to be updated to refer to the same nodes in  the set fens as
    # %     fes = update_conn(fes ,new_indexes_of_fens1_nodes);
    # %
    # % See also: merge_nodes, update_conn
    # %
 
    xyz1 = fens1.xyz;
    id1 =(1:size(xyz1,1))';
    dim =size(xyz1,2);
    xyz2 = fens2.xyz;
    id2 =(1:size(xyz2,1))';
    c1=ones(size(xyz2,1),1);
    # % Mark nodes from the first array that are duplicated in the second
    if (tolerance2>0) # should we attempt to merge nodes?
        for i=1:FENodeSetModule.count(fens1)
            xyz =xyz1[i,:];
            xyzd=abs(xyz2-c1*xyz);
            for j=1:size(xyzd,1)
                if (sum(xyzd[j,:])<tolerance)
                    id1[i] =-j; 
                end
            end
        end
    end
    # % Generate  fused arrays of the nodes
    xyzm = zeros(FENodeSetModule.count(fens1)+FENodeSetModule.count(fens2),dim);
   
    xyzm[1:FENodeSetModule.count(fens2),1:size(xyz2,2)]=xyz2;# fens2 are there without change
    idm = zeros(JFInt,FENodeSetModule.count(fens1)+FENodeSetModule.count(fens2),1);
    idm[1:FENodeSetModule.count(fens2)]=(1:FENodeSetModule.count(fens2));
    mid=FENodeSetModule.count(fens2)+1;
    for i=1:FENodeSetModule.count(fens1) # and then we pick only non-duplicated fens1
        if id1[i]>0
            id1[i]=mid;
            idm[mid]=mid;
            xyzm[mid,:]=xyz1[i,:];
            mid=mid+1;
        else
            id1[i]=id2[-id1[i]];
        end
    end
    nfens =mid-1;
    xyzm =xyzm[1:nfens,:];
     
    # % Create the fused Node set
    fens =FENodeSetModule.FENodeSet(xyz=xyzm);
    # % The Node set 1 numbering will change
    new_indexes_of_fens1_nodes=id1[:];
    # % The node set 2 numbering stays the same
    return fens, new_indexes_of_fens1_nodes
end

function compactfens(fens::FENodeSetModule.FENodeSet, connected::JFIntVec)
    # % Compact the finite element node set by deleting unconnected nodes.
    #  
    # % fens = array of finite element nodes
    # % connected = The array element connected(j) is either 0 (when j is an unconnected
    # %    node), or a positive number (when node j is connected to other nodes by
    # %    at least one finite element)  
    # %
    # % Output:
    # % fens = new set of finite element nodes
    # % new_numbering= array which tells where in the new fens array the
    # %      connected nodes are (or 0 when the node was unconnected). For instance,
    # %      node 5 was connected, and in the new array it is the third node: then
    # %      new_numbering(5) is 3.
    # % 
    # % Examples: 
    # %
    # % Let us say there are nodes not connected to any finite element that you
    # % would like to remove from the mesh: here is how that would be
    # % accomplished.
    # % 
    # % connected = find_unconn_fens(fens, fes);
    # % [fens, new_numbering] =compact_fens(fens, connected);
    # % fes = renumber_fe_conn(fes, new_numbering);
    # % 
    # % Finally, check that the mesh is valid:
    # % validate_mesh(fens, fes);
    # % 
    
    new_numbering=zeros(JFInt,count(fens),1);
    xyz =fens.xyz;
    nxyz =xyz;
    id=1;
    for i=1:length(connected)
        if (connected[i]>=0)
            new_numbering[i]=id; 
            nxyz[id,:] =xyz [i,:];
            id=id+1;
        end
    end
    new_numbering=new_numbering[1:id-1];
    fens=FENodeSetModule.FENodeSet (xyz=nxyz[1:id-1,:]);
    return fens, new_numbering[1:id-1]
end

function mergemeshes{T<:FESetModule.FESet}(fens1::FENodeSetModule.FENodeSet, fes1::T, fens2::FENodeSetModule.FENodeSet, fes2::T, tolerance::JFFlt)
    # % Merge together two meshes.
    # %
    # % function [fens,fes1,fes2] = merge_meshes(fens1, fes1, fens2,
    # %                     fes2, tolerance)
    # %
    # % Merge two meshes together by gluing together nodes within tolerance. The
    # % two meshes, fens1, fes1, and fens2, fes2, are glued together by merging
    # % the nodes that fall within a box of size "tolerance". If tolerance is set
    # % to zero, no merging of nodes is performed; the two meshes are simply
    # % concatenated together.
    # % 
    # % The merged node set, fens, and the two arrays of finite elements with
    # % renumbered  connectivities are returned.
    # % 
    # % Important notes: On entry into this function the connectivity of fes1
    # % point into fens1 and the connectivity of fes2 point into fens2. After
    # % this function returns the connectivity of both fes1 and fes2 point into
    # % fens. The order of the nodes of the node set fens1 in the resulting set
    # % fens will have changed, whereas the order of the nodes of the node set
    # % fens2 is are guaranteed to be the same. Therefore, the connectivity of
    # % fes2 will in fact remain the same.
    # %
    # %
    # % See also: fusenodes, updateconn
    # %  

    # % Fuse the nodes
    fens,new_indexes_of_fens1_nodes = fusenodes(fens1, fens2, tolerance);
    
    # % Renumber the finite elements
    newfes1= deepcopy(fes1)
    FESetModule.updateconn!(newfes1,new_indexes_of_fens1_nodes);
    # % Note that now the connectivity of both fes1 and fes2 point into
    # % fens.
    return fens,newfes1,fes2
end

function mergenmeshes!(fensa, fesa, tolerance::JFFlt)
#     % Merge several meshes together.
# %
# % function [fens,fesa] = merge_n_meshes(fensa, fesa, tolerance)
# %
# % Merge several meshes together either by simple concatenation of nodes or by 
# % gluing together nodes within tolerance. 
# %
# % Inputs:
# % fensa= cell array of node sets, one for each mesh;
# % fesa= cell array of finite element sets, one for each mesh;  
# % tolerance= Geometric tolerance, maybe supplied as zero (>=0). 
# % 
# % The meshes are glued together by
# % merging the nodes that fall within a box of size "tolerance". If tolerance 
# % is set to zero, no merging of nodes is performed; the nodes from the meshes are 
# % simply concatenated together.
# % 
# % The merged node set, fens, and the cell array of finite element sets with
# % renumbered  connectivities are returned.
# % 
# % Outputs:
# % fens= merged node set, 
# % fesa= cell array of finite element sets updated to use the merged node set.
# %
# %
# % See also: merge_meshes


    if (length(fensa))!=(length(fesa))
        error("(length(fensa))!=(length(fesa))");
    end
    if (length(fensa))==1
        fens=fensa[1];
        return fens,fesa        # There is nothing to be done: this is a single mesh
    end
    fens=fensa[1];
    for j=2:length(fesa)
        fens,new_indexes_of_fens1_nodes = fusenodes(fensa[j], fens, tolerance);
        FESetModule.updateconn!(fesa[j],new_indexes_of_fens1_nodes);
    end
    return fens,fesa
end

function mergenodes(fens::FENodeSetModule.FENodeSet, fes::FESetModule.FESet, tolerance::JFFlt)
    # % Merge together  nodes of a single node set.
    # %
    # % function [fens,fes] = merge_nodes(fens, fes, tolerance)
    # %
    # % Merge by gluing together nodes from a single node set located within
    # % tolerance of each other. The nodes are glued together by merging the
    # % nodes that fall within a box of size "tolerance". The merged node
    # % set, fens, and the finite element set with renumbered  connectivities
    # % are returned.
    # %
    # % See also: fuse_nodes
   
    xyz1 = fens.xyz;
    dim =size(xyz1,2);
    id1 = (1:FENodeSetModule.count(fens))';
    c1=ones(size(xyz1,1),1);
    xyzd= zeros(size(xyz1));
    d= zeros(size(xyz1,1));
    m= trues(size(xyz1,1));
    # Mark nodes from the array that are duplicated 
    for i=1:FENodeSetModule.count(fens)
        if (id1[i]>0) # This node has not yet been marked for merging
            XYZ =xyz1[i,:];
            xyzd[:,:]=abs(xyz1-c1*XYZ); #find the distances along  coordinate directions
            d=sum(xyzd,2);
            map!((x)->x<tolerance, m, d);
            jx=find(m);
            if (!isempty(jx))
                minn=minimum(jx);
                id1[jx] =-minn;
                id1[minn] =minn;
            end
        end
    end
    # Generate  merged arrays of the nodes
    xyzm = zeros(JFFlt,FENodeSetModule.count(fens),dim);
    mid=1;
    for i=1:FENodeSetModule.count(fens) # and then we pick only non-duplicated fens1
        if id1[i]>0
            id1[i]=mid;
            xyzm[mid,:]=xyz1[i,:];
            mid=mid+1;
        else
            id1[i]=id1[-id1[i]];
        end
    end
    nfens =mid-1;
    xyzm =xyzm[1:nfens,:];
    # Renumber the cells
    conns=fes.conn;
    for i=1:FESetModule.count(fes)
        conn=conns[i,:];
        conns[i,:]=id1[conn];
    end
    fes.conn=conns;
    
    fens=FENodeSetModule.FENodeSet(xyz=xyzm[1:nfens,:]);
    
    return fens,fes
end

function renumber_fe_conn(fes, new_numbering)
    # % Renumber the nodes in the connectivity of the finite elements based on a new
    # % numbering for the nodes.
    # % 
    # % function fes = renumber_fe_conn(fes, new_numbering)
    # % 
    # % fes =finite element set 
    # % new_numbering = new serial numbers for the nodes.  The connectivity
    # %           should be changed as conn(j) --> new_numbering(conn(j))
    # % 
    # % Output:
    # % fes = new Finite element set
    # % 
    # % Let us say there are nodes not connected to any finite element that you
    # % would like to remove from the mesh: here is how that would be
    # % accomplished.
    # % 
    # % connected = find_unconn_fens(fens, fes);
    # % [fens, new_numbering] =compact_fens(fens, connected);
    # % fes = renumber_fe_conn(fes, new_numbering);
    # % 
    # % Finally, check that the mesh is valid:
    # % validate_mesh(fens, fes);
    # % 
    conn =fes.conn;
    for i=1:size(conn,1)
        c=conn[i,:];
        conn[i,:] =new_numbering[c]';
    end
    fes.conn=conn;
    return fes
end


end



