# for now we're using bitmap fonts generated by
# http://www.angelcode.com/products/bmfont/

# supports only a single page for now
# and this code is pretty ugly
# ultimately it would be good to use FreeType to render the
# glyphs at runtime
immutable type Glyph
    x :: Int32
    y :: Int32
    w :: Int32
    h :: Int32
    xadvance :: Int32
    xoffset :: Int32
    yoffset :: Int32
end
import Base.split
function read_bmf_charmap(io::IOStream)
    s = replace(readall(io), "\r", "")
    lines = [split(x, " ") for x in split(s, "\n")]
    ft = Dict{Symbol, Int32}()
    cmap = Array(Glyph, 256)
    for line in lines
        if line[1] == "char"
            data = filter(x -> x != "", line[2:end])
            map = Dict{Symbol, Int32}()
            for datum in data
                d = split(datum, "=")
                s = symbol(d[1])
                v = int32(d[2])
                map[s] = v
            end
            cmap[map[:id] + 1] = Glyph(map[:x], map[:y], map[:width], map[:height], map[:xadvance], map[:xoffset], map[:yoffset])
        end
        if line[1] == "common"
            data = filter(x -> x != "", line[2:end])
            for datum in data
                d = split(datum, "=")
                try
                    if length(d) == 2
                        s = symbol(d[1])
                        v = int32(d[2])
                        ft[s] = v
                    end
                catch end
            end
        end
    end
    for i in 1:length(cmap)
    	try
            cmap[i]
        catch
            cmap[i] = cmap[int('?') + 1]
        end
    end
    (ft, cmap)
end



const s = float32(2/min(W,H))
# this projects from x,y in pixel space to NDC
const ortho_proj = translation(-1, -1, 0)*scale(s, s, 1)*proj(float32(pi/2), float32(W/H), 1f-1, 1f1)
@glsl Sprite begin
    @vertex @scope (instance) begin
        proj :: Mat4
        chardim :: Vec4
    end
    @fragment @scope (all) begin
        tex :: Texture
    end
    @vertex """
    in vec2 posn;
 
    out vec2 f_texc;
    void vertex(void) {
      gl_Position = proj*vec4(posn, -1.0, 1.0);
      f_texc = chardim.xy + chardim.zw*.5*(1. + vec2(posn.x, -posn.y));
    }"""

    @fragment """
    in vec2 f_texc;
    
    void fragment(void) {
      gl_FragColor = sample_tex(f_texc);
    }"""
end

const cdm = open(read_bmf_charmap, "./charmap.fnt")
const ftinfo = cdm[1]
const cmap = cdm[2]
const chartex = make_dds_tex(open("charmap.dds"))

function render_text(txt::UTF8String)
    lines = split(txt, "\n")
    render_lines(lines, 0, 0, 0)
end

immutable QuadVertex
    posn :: Vec2
end
copywith(v :: QuadVertex; posn = v.posn) = QuadVertex(posn)
const quad_buffer = make_vertex_buffer(QuadVertex, [vec2(-1, -1),
                                                    vec2( 1, -1),
                                                    vec2( 1,  1),
                                                    vec2(-1,  1)])
const quad_ibuffer = make_index_buffer(Uint16[0, 1, 2, 2, 3, 0])
const MAX_CHAR_INST = 128
const tf_sh = Sprite(instance_count = MAX_CHAR_INST)
const quad_bindings = bindings(tf_sh, quad_buffer, QuadVertex)

const text_rq = RenderQueue()

const text_uniforms = SpriteUniforms()
#show(names(text_uniforms))
#exit()
#text_uniforms.tex = int32(0)

function render_lines(lines, atx :: Float32, aty :: Float32, yadv :: Int)
    return
    lh = ftinfo[:lineHeight]
    bind_tex(chartex, int32(0))
    glUseProgram(shader_2d.program)
    bind(quad_bindings)
    bind(quad_ibuffer)
    for i in reverse(1:length(lines))
        if lines[i] != ""
            render_line(lines[i], atx, float32(aty + yadv*lh), text_uniforms)
        end
        yadv += 1
    end
    bind(NoIndexBuffer)
end
#DrawCall(shader_2d, text_uniforms, [chartex], quad_bindings, quad_ibuffer,
#         [PrimDrawCall(size(quad_ibuffer),
#                       n, 0, 0, 0)], GL_TRIANGLES, 0, 1)

function render_line(txt :: String, atx :: Float32, aty :: Float32, uniforms :: SpriteUniforms)
    xadv = 0

    lh = ftinfo[:lineHeight]
    for c in txt
        ccode = int(c)
	    if ccode + 1 > length(cmap) continue end
        cc = cmap[ccode + 1]
        render_char(cc, atx + xadv + cc.xoffset,aty + lh - cc.yoffset - cc.h, uniforms)
        xadv += cc.xadvance
    end
    nothing
end

type TextFrame
    at :: Vec2
    text :: Vector{Char}
    drawrefs :: Vector{DrawRef{Int}}
end
const txt_rq = RenderQueue()
TextFrame() = TextFrame(vec2(), Char[], DrawRef{Int}[])

function update(f::TextFrame)
    if length(f.drawrefs) < length(f.text)
        for i = 1:length(f.text)-length(f.drawrefs)
            push!(f.drawrefs, add!(txt_rq, Mesh(tf_sh, quad_bindings, quad_buffer, quad_ibuffer, [chartex]), true))
        end
    end
end

function fill_init(u::SpriteUniforms)
    u.proj = Array(Mat4, MAX_CHAR_INST)
    u.chardim = Array(Vec4, MAX_CHAR_INST)
    u.tex = chartex
end

function fill_frame(f::TextFrame)
    atx = f.at.x
    aty = f.at.y
    xadv = 0
    for i = 1:length(f.text)
        c = f.text[i]
        dr = f.drawrefs[i]
        ccode = int(c)
	    if ccode + 1 > length(cmap) continue end
        cc = cmap[ccode + 1]
        
        dr.uniforms.proj[dr.instance] =
        ortho_proj * scale(6f-1, 6f-1, 1f0) *
        translation(atx + xadv, aty, 0f0) *
        scale(float32(cc.w/2), float32(cc.h/2), 1f0) *
        translation(1f0, 1f0, 0f0)
        
        x = float32(cc.x/chartex.w)
        y = float32(cc.y/chartex.h)
        w = float32(cc.w/chartex.w)
        h = float32(cc.h/chartex.h)
        dr.uniforms.chardim[dr.instance] = vec4(x, y, w, h)

        xadv += cc.xadvance
    end
end

function render_char(cc :: Glyph, atx :: Float32, aty :: Float32, uniforms :: SpriteUniforms)
    x = float32(cc.x/chartex.w)
    y = float32(cc.y/chartex.h)
    w = float32(cc.w/chartex.w)
    h = float32(cc.h/chartex.h)
    mat = ortho_proj*scale(8f-1, 8f-1, 1)*translation(atx, aty, 0)*scale(float32(cc.w/2), float32(cc.h/2), 1)*translation(1, 1, 0)
    uniforms.proj = mat
    uniforms.chardim = vec4(x, y, w, h)
    bind(uniforms)
    glDrawElements(GL_TRIANGLES, length(quad_ibuffer), GL_UNSIGNED_SHORT, 0)
    nothing
end
