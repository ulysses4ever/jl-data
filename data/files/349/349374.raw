{"functionItems": {"grabcut": {"functionParams": {"img": {"index": 0, "description": " \u2013 Input 8-bit 3-channel image.", "title": "img", "required": true, "type": ["InputArray"], "isOutput": false}, "bgdModel": {"index": 3, "description": " \u2013 Temporary array for the background model. Do not modify it while you are processing the same image.", "title": "bgdModel", "required": true, "type": ["InputOutputArray"], "isOutput": false}, "fgdModel": {"index": 4, "description": " \u2013 Temporary arrays for the foreground model. Do not modify it while you are processing the same image.", "title": "fgdModel", "required": true, "type": ["InputOutputArray"], "isOutput": false}, "mask": {"index": 1, "description": " \u2013 Input/output 8-bit single-channel mask. The mask is initialized by the function when  mode is set to GC_INIT_WITH_RECT. Its elements may have one of following values:\n\nGC_BGD defines an obvious background pixels.\nGC_FGD defines an obvious foreground (object) pixel.\nGC_PR_BGD defines a possible background pixel.\nGC_PR_FGD defines a possible foreground pixel.\n\n", "title": "mask", "required": true, "references": ["mode", "GC_INIT_WITH_RECT"], "type": ["InputOutputArray"], "isOutput": false}, "mode": {"index": 6, "description": " \u2013 Operation mode that could be one of the following:\n\nGC_INIT_WITH_RECT     The function initializes the state and the mask using the provided rectangle. After that it runs  iterCount  iterations of the algorithm.\nGC_INIT_WITH_MASK     The function initializes the state using the provided mask. Note that  GC_INIT_WITH_RECT  and  GC_INIT_WITH_MASK  can be combined. Then, all the pixels outside of the ROI are automatically initialized with  GC_BGD .\nGC_EVAL     The value means that the algorithm should just resume.\n\n", "title": "mode", "required": false, "references": ["iterCount", "GC_INIT_WITH_RECT", "GC_INIT_WITH_MASK", "GC_BGD"], "type": ["int"], "isOutput": false}, "iterCount": {"index": 5, "description": " \u2013 Number of iterations the algorithm should make before returning the result. Note that the result can be refined with further calls with  mode==GC_INIT_WITH_MASK  or  mode==GC_EVAL .", "title": "iterCount", "required": true, "references": ["mode==GC_INIT_WITH_MASK", "mode==GC_EVAL"], "type": ["int"], "isOutput": false}, "rect": {"index": 2, "description": " \u2013 ROI containing a segmented object. The pixels outside of the ROI are marked as \u201cobvious background\u201d. The parameter is only used when  mode==GC_INIT_WITH_RECT .", "title": "rect", "required": true, "references": ["mode==GC_INIT_WITH_RECT"], "type": ["Rect"], "isOutput": false}}, "description": "Runs the GrabCut algorithm.", "title": "grabcut", "outputParamTypes": {"grabCut": ["void"]}, "optionalInput": ["mode"], "inputParamTypes": {"img": ["InputArray"], "bgdModel": ["InputOutputArray"], "fgdModel": ["InputOutputArray"], "mask": ["InputOutputArray"], "mode": ["int"], "iterCount": ["int"], "rect": ["Rect"]}, "input": ["img", "mask", "rect", "bgdModel", "fgdModel", "iterCount"], "invocation": ["cv2.grabCut"], "output": ["None"]}, "adaptivethreshold": {"functionParams": {"src": {"index": 0, "description": " \u2013 Source 8-bit single-channel image.", "title": "src", "required": true, "type": ["InputArray"], "isOutput": false}, "C": {"index": 5, "description": " \u2013 Constant subtracted from the mean or weighted mean (see the details below). Normally, it is positive but may be zero or negative as well.", "title": "C", "required": true, "type": ["double"], "isOutput": false}, "blockSize": {"index": 4, "description": " \u2013 Size of a pixel neighborhood that is used to calculate a threshold value for the pixel: 3, 5, 7, and so on.", "title": "blockSize", "required": true, "type": ["int"], "isOutput": false}, "dst": {"index": 6, "description": " \u2013 Destination image of the same size and the same type as  src .", "title": "dst", "required": false, "references": ["src"], "returnIndex": 0, "type": ["OutputArray"], "isOutput": true}, "maxValue": {"index": 1, "description": " \u2013 Non-zero value assigned to the pixels for which the condition is satisfied. See the details below.", "title": "maxValue", "required": true, "type": ["double"], "isOutput": false}, "thresholdType": {"index": 3, "description": " \u2013 Thresholding type that must be either  THRESH_BINARY  or  THRESH_BINARY_INV .", "title": "thresholdType", "required": true, "references": ["THRESH_BINARY", "THRESH_BINARY_INV"], "type": ["int"], "isOutput": false}, "adaptiveMethod": {"index": 2, "description": " \u2013 Adaptive thresholding algorithm to use, ADAPTIVE_THRESH_MEAN_C  or  ADAPTIVE_THRESH_GAUSSIAN_C . See the details below.", "title": "adaptiveMethod", "required": true, "references": ["ADAPTIVE_THRESH_MEAN_C", "ADAPTIVE_THRESH_GAUSSIAN_C"], "type": ["int"], "isOutput": false}}, "description": "Applies an adaptive threshold to an array.", "title": "adaptivethreshold", "outputParamTypes": {"adaptiveThreshold": ["void"]}, "optionalInput": ["dst"], "inputParamTypes": {"src": ["InputArray"], "C": ["double"], "blockSize": ["int"], "dst": ["OutputArray"], "maxValue": ["double"], "thresholdType": ["int"], "adaptiveMethod": ["int"]}, "input": ["src", "maxValue", "adaptiveMethod", "thresholdType", "blockSize", "C"], "invocation": ["cv2.adaptiveThreshold"], "output": ["dst"]}, "integral": {"functionParams": {"sdepth": {"index": 10, "description": " \u2013 desired depth of the integral and the tilted integral images,  CV_32S, CV_32F,  or  CV_64F.", "title": "sdepth", "required": false, "references": ["CV_32S", "CV_32F", "CV_64F"], "type": ["int"], "isOutput": false}, "tilted": {"index": 9, "description": " \u2013 integral for the image rotated by 45 degrees; it is  array  with the same data type as sum.", "title": "tilted", "required": false, "references": ["sum"], "returnIndex": 2, "type": ["OutputArray"], "isOutput": true}, "image": {"description": " \u2013 input image as , 8-bit or floating-point (32f or 64f).", "title": "image"}, "sqsum": {"index": 4, "description": " \u2013 integral image for squared pixel values; it is , double-precision floating-point (64f) array.", "title": "sqsum", "required": false, "returnIndex": 1, "type": ["OutputArray"], "isOutput": true}, "sum": {"index": 1, "description": " \u2013 integral image as   , 32-bit integer or floating-point (32f or 64f).", "title": "sum", "required": false, "returnIndex": 0, "type": ["OutputArray"], "isOutput": true}}, "description": "Calculates the integral of an image.", "title": "integral", "outputParamTypes": {"integral": ["void"]}, "optionalInput": ["sum", "sdepth  sum\nsrc", "sum", "sqsum", "sdepth  sum", "sqsum\nsrc", "sum", "sqsum", "tilted", "sdepth"], "inputParamTypes": {"src": ["InputArray"], "sum": ["OutputArray"], "sqsum": ["OutputArray"], "sdepth": ["int"], "tilted": ["OutputArray"]}, "input": ["src"], "invocation": ["cv2.integral", "cv2.integral2", "cv2.integral3"], "output": ["sum", "sqsum", "tilted"]}, "watershed": {"functionParams": {"image": {"index": 0, "description": " \u2013 Input 8-bit 3-channel image.", "title": "image", "required": true, "type": ["InputArray"], "isOutput": false}, "markers": {"index": 1, "description": " \u2013 Input/output 32-bit single-channel image (map) of markers. It should have the same size as  image .", "title": "markers", "required": true, "references": ["image"], "type": ["InputOutputArray"], "isOutput": false}}, "description": "Performs a marker-based image segmentation using the watershed algorithm.", "title": "watershed", "outputParamTypes": {"watershed": ["void"]}, "optionalInput": [""], "inputParamTypes": {"image": ["InputArray"], "markers": ["InputOutputArray"]}, "input": ["image", "markers"], "invocation": ["cv2.watershed"], "output": ["None"]}, "distancetransform": {"functionParams": {"src": {"index": 0, "description": " \u2013 8-bit, single-channel (binary) source image.", "title": "src", "required": true, "type": ["InputArray"], "isOutput": false}, "maskSize": {"index": 2, "description": " \u2013 Size of the distance transform mask. It can be 3, 5, or  CV_DIST_MASK_PRECISE  (the latter option is only supported by the first function). In case of the CV_DIST_L1  or  CV_DIST_C  distance type, the parameter is forced to 3 because a    mask gives the same result as    or any larger aperture.", "title": "maskSize", "required": true, "references": ["CV_DIST_MASK_PRECISE", "CV_DIST_L1", "CV_DIST_C"], "type": ["int"], "isOutput": false}, "dst": {"index": 3, "description": " \u2013 Output image with calculated distances. It is a 32-bit floating-point, single-channel image of the same size as  src .", "title": "dst", "required": false, "references": ["src"], "returnIndex": 0, "type": ["OutputArray"], "isOutput": true}, "labels": {"references": ["CV_32SC1", "src"], "description": " \u2013 Optional output 2D array of labels (the discrete Voronoi diagram). It has the type  CV_32SC1  and the same size as  src . See the details below.", "title": "labels"}, "distanceType": {"index": 1, "description": " \u2013 Type of distance. It can be  CV_DIST_L1, CV_DIST_L2 , or  CV_DIST_C .", "title": "distanceType", "required": true, "references": ["CV_DIST_L1,", "", "CV_DIST_L2", "CV_DIST_C"], "type": ["int"], "isOutput": false}, "labelType": {"references": ["labelType==DIST_LABEL_CCOMP", "src", "labelType==DIST_LABEL_PIXEL"], "description": " \u2013 Type of the label array to build. If labelType==DIST_LABEL_CCOMP then each connected component of zeros in src (as well as all the non-zero pixels closest to the connected component) will be assigned the same label. If labelType==DIST_LABEL_PIXEL then each zero pixel (and all the non-zero pixels closest to it) gets its own label.", "title": "labelType"}}, "description": "Calculates the distance to the closest zero pixel for each pixel of the source image.", "title": "distancetransform", "outputParamTypes": {"distanceTransform": ["void"]}, "optionalInput": ["dst"], "inputParamTypes": {"src": ["InputArray"], "maskSize": ["int"], "dst": ["OutputArray"], "labels": ["OutputArray"], "distanceType": ["int"], "labelType": ["int"]}, "input": ["src", "distanceType", "maskSize"], "invocation": ["cv2.distanceTransform"], "output": ["dst"]}, "floodfill": {"functionParams": {"image": {"index": 0, "description": " \u2013 Input/output 1- or 3-channel, 8-bit, or floating-point image. It is modified by the function unless the  FLOODFILL_MASK_ONLY  flag is set in the second variant of the function. See the details below.", "title": "image", "required": true, "references": ["FLOODFILL_MASK_ONLY"], "type": ["InputOutputArray"], "isOutput": false}, "mask": {"index": 1, "description": " \u2013 (For the second function only) Operation mask that should be a single-channel 8-bit image, 2 pixels wider and 2 pixels taller. The function uses and updates the mask, so you take responsibility of initializing the  mask  content. Flood-filling cannot go across non-zero pixels in the mask. For example, an edge detector output can be used as a mask to stop filling at edges. It is possible to use the same mask in multiple calls to the function to make sure the filled area does not overlap.\n\nNote\nSince the mask is larger than the filled image, a pixel    in  image  corresponds to the pixel    in the  mask .\n\n", "title": "mask", "required": true, "references": ["mask", "image", "mask"], "type": ["InputOutputArray"], "isOutput": false}, "upDiff": {"index": 5, "description": " \u2013 Maximal upper brightness/color difference between the currently observed pixel and one of its neighbors belonging to the component, or a seed pixel being added to the component.", "title": "upDiff", "required": false, "type": ["Scalar"], "isOutput": false}, "newVal": {"index": 3, "description": " \u2013 New value of the repainted domain pixels.", "title": "newVal", "required": true, "type": ["Scalar"], "isOutput": false}, "seedPoint": {"index": 2, "description": " \u2013 Starting point.", "title": "seedPoint", "required": true, "type": ["Point"], "isOutput": false}, "flags": {"index": 6, "description": " \u2013 Operation flags. Lower bits contain a connectivity value, 4 (default) or 8, used within the function. Connectivity determines which neighbors of a pixel are considered. Upper bits can be 0 or a combination of the following flags:\n\nFLOODFILL_FIXED_RANGE If set, the difference between the current pixel and seed pixel is considered. Otherwise, the difference between neighbor pixels is considered (that is, the range is floating).\nFLOODFILL_MASK_ONLY  If set, the function does not change the image ( newVal  is ignored), but fills the mask.  The flag can be used for the second variant only.\n\n", "title": "flags", "required": false, "references": ["newVal"], "type": ["int"], "isOutput": false}, "loDiff": {"index": 4, "description": " \u2013 Maximal lower brightness/color difference between the currently observed pixel and one of its neighbors belonging to the component, or a seed pixel being added to the component.", "title": "loDiff", "required": false, "type": ["Scalar"], "isOutput": false}, "rect": {"title": "rect", "returnIndex": 1, "description": " \u2013 Optional output parameter set by the function to the minimum bounding rectangle of the repainted domain.", "isOutput": true}}, "description": "Fills a connected component with the given color.", "title": "floodfill", "outputParamTypes": {"floodFill": ["int"]}, "optionalInput": ["loDiff", "upDiff", "flags"], "inputParamTypes": {"image": ["InputOutputArray"], "mask": ["InputOutputArray"], "upDiff": ["Scalar"], "newVal": ["Scalar"], "seedPoint": ["Point"], "flags": ["int"], "loDiff": ["Scalar"], "rect": ["Rect*"]}, "input": ["image", "mask", "seedPoint", "newVal"], "invocation": ["cv2.floodFill"], "output": ["retval", "rect"]}, "cvtcolor": {"functionParams": {"dstCn": {"index": 3, "description": " \u2013 number of channels in the destination image; if the parameter is 0, the number of the channels is derived automatically from  src  and   code .", "title": "dstCn", "required": false, "references": ["src", "code"], "type": ["int"], "isOutput": false}, "src": {"index": 0, "description": " \u2013 input image: 8-bit unsigned, 16-bit unsigned ( CV_16UC... ), or single-precision floating-point.", "title": "src", "required": true, "references": ["CV_16UC..."], "type": ["InputArray"], "isOutput": false}, "dst": {"index": 2, "description": " \u2013 output image of the same size and depth as src.", "title": "dst", "required": false, "references": ["src"], "returnIndex": 0, "type": ["OutputArray"], "isOutput": true}, "code": {"index": 1, "description": " \u2013 color space conversion code (see the description below).", "title": "code", "required": true, "type": ["int"], "isOutput": false}}, "description": "Converts an image from one color space to another.", "title": "cvtcolor", "outputParamTypes": {"cvtColor": ["void"]}, "optionalInput": ["dst", "dstCn"], "inputParamTypes": {"dstCn": ["int"], "src": ["InputArray"], "dst": ["OutputArray"], "code": ["int"]}, "input": ["src", "code"], "invocation": ["cv2.cvtColor"], "output": ["dst"]}, "threshold": {"functionParams": {"src": {"index": 0, "description": " \u2013 input array (single-channel, 8-bit or 32-bit floating point).", "title": "src", "required": true, "type": ["InputArray"], "isOutput": false}, "dst": {"index": 4, "description": " \u2013 output array of the same size and type as src.", "title": "dst", "required": false, "references": ["src"], "returnIndex": 1, "type": ["OutputArray"], "isOutput": true}, "thresh": {"index": 1, "description": " \u2013 threshold value.", "title": "thresh", "required": true, "type": ["double"], "isOutput": false}, "type": {"index": 3, "description": " \u2013 thresholding type (see the details below).", "title": "type", "required": true, "type": ["int"], "isOutput": false}, "maxval": {"index": 2, "description": " \u2013 maximum value to use with the THRESH_BINARY and THRESH_BINARY_INV thresholding types.", "title": "maxval", "required": true, "references": ["THRESH_BINARY", "THRESH_BINARY_INV"], "type": ["double"], "isOutput": false}}, "description": "Applies a fixed-level threshold to each array element.", "title": "threshold", "outputParamTypes": {"threshold": ["double"]}, "optionalInput": ["dst"], "inputParamTypes": {"src": ["InputArray"], "dst": ["OutputArray"], "thresh": ["double"], "type": ["int"], "maxval": ["double"]}, "input": ["src", "thresh", "maxval", "type"], "invocation": ["cv2.threshold"], "output": ["retval", "dst"]}}, "title": "[u'Miscellaneous Image Transformations']"}
