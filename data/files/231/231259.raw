#!/usr/bin/env julia

module GalsimBenchmark

import DataFrames # TODO remove after temporary code goes
import FITSIO
import WCS

import Celeste: ElboDeriv, Infer, Model, OptimizeElbo

## TODO pull this from test/SampleData.jl
function make_elbo_args(images::Vector{Model.TiledImage},
                        catalog::Vector{Model.CatalogEntry};
                        fit_psf::Bool=false,
                        patch_radius::Float64=NaN)
    vp = Vector{Float64}[Model.init_source(ce) for ce in catalog]
    patches, tile_source_map = Infer.get_tile_source_map(
        images,
        catalog,
        radius_override=patch_radius,
    )
    active_sources = collect(1:length(catalog))
    ea = ElboDeriv.ElboArgs(images, vp, tile_source_map, patches, active_sources)
    if fit_psf
        Infer.fit_object_psfs!(ea, ea.active_sources)
    end
    ea
end

function load_stamp_catalog_df(cat_dir, stamp_id, blob; match_blob=false)
    # These files are generated by
    # https://github.com/dstndstn/tractor/blob/master/projects/inference/testblob2.py
    cat_fits = FITSIO.FITS("$cat_dir/cat-$stamp_id.fits")
    num_cols = FITSIO.read_key(cat_fits[2], "TFIELDS")[1]
    ttypes = [FITSIO.read_key(cat_fits[2], "TTYPE$i")[1] for i in 1:num_cols]

    df = DataFrames.DataFrame()
    for i in 1:num_cols
        tmp_data = read(cat_fits[2], ttypes[i])
        df[Symbol(ttypes[i])] = tmp_data
    end

    close(cat_fits)

    if match_blob
        camcol_matches = df[:camcol] .== blob[3].camcol_num
        run_matches = df[:run] .== blob[3].run_num
        field_matches = df[:field] .== blob[3].field_num
        df = df[camcol_matches & run_matches & field_matches, :]
    end

    df
end


"""
Load a stamp catalog.
"""
function load_stamp_catalog(cat_dir, stamp_id, blob; match_blob=false)
    df = load_stamp_catalog_df(cat_dir, stamp_id, blob,
                                    match_blob=match_blob)
    df[:objid] = [ string(s) for s=1:size(df)[1] ]

    function row_to_ce(row)
        x_y = [row[1, :ra], row[1, :dec]]
        star_fluxes = zeros(5)
        gal_fluxes = zeros(5)
        fracs_dev = [row[1, :frac_dev], 1 - row[1, :frac_dev]]
        for b in 1:length(Model.band_letters)
            bl = Model.band_letters[b]
            psf_col = Symbol("psfflux_$bl")

            # TODO: How can there be negative fluxes?
            star_fluxes[b] = max(row[1, psf_col], 1e-6)

            dev_col = Symbol("devflux_$bl")
            exp_col = Symbol("expflux_$bl")
            gal_fluxes[b] += fracs_dev[1] * max(row[1, dev_col], 1e-6) +
                             fracs_dev[2] * max(row[1, exp_col], 1e-6)
        end

        fits_ab = fracs_dev[1] > .5 ? row[1, :ab_dev] : row[1, :ab_exp]
        fits_phi = fracs_dev[1] > .5 ? row[1, :phi_dev] : row[1, :phi_exp]
        fits_theta = fracs_dev[1] > .5 ? row[1, :theta_dev] : row[1,
:theta_exp]

        # tractor defines phi as -1 * the phi catalog for some reason.
        if !match_blob
            fits_phi *= -1.
        end

        re_arcsec = max(fits_theta, 1. / 30)  # re = effective radius
        re_pixel = re_arcsec / 0.396

        phi90 = 90 - fits_phi
        phi90 -= floor(phi90 / 180) * 180
        phi90 *= (pi / 180)

        Model.CatalogEntry(x_y, row[1, :is_star], star_fluxes,
            gal_fluxes, row[1, :frac_dev], fits_ab, phi90, re_pixel,
            row[1, :objid], 0)
    end

    Model.CatalogEntry[row_to_ce(df[i, :]) for i in 1:size(df, 1)]
end

## end code from SampleData

const FILENAME = "output/galsim_test_image.fits"

function make_psf()
    alphaBar = [1.; 0.; 0.]
    xiBar = [0.; 0.]
    tauBar = [1. 0.; 0. 1.]
    [Model.PsfComponent(alphaBar[k], xiBar, tauBar) for k in 1:3]
end

function read_psf_from_sdss_header(header)
    alphaBar = [header["PSF_P0"]; header["PSF_P1"]; header["PSF_P2"]]
    xiBar = [
        [header["PSF_P3"]  header["PSF_P4"]];
        [header["PSF_P5"]  header["PSF_P6"]];
        [header["PSF_P7"]  header["PSF_P8"]]]'

    tauBar = Array(Float64, 2, 2, 3)
    tauBar[:,:,1] = [[header["PSF_P9"] header["PSF_P11"]];
                     [header["PSF_P11"] header["PSF_P10"]]]
    tauBar[:,:,2] = [[header["PSF_P12"] header["PSF_P14"]];
                     [header["PSF_P14"] header["PSF_P13"]]]
    tauBar[:,:,3] = [[header["PSF_P15"] header["PSF_P17"]];
                     [header["PSF_P17"] header["PSF_P16"]]]

    [Model.PsfComponent(alphaBar[k], xiBar[:, k], tauBar[:, :, k]) for k in 1:3]
end

function read_fits(filename; read_sdss_psf=false)
    @assert isfile(filename)
    fits = FITSIO.FITS(filename)
    pixels = read(fits[1])
    header_str = FITSIO.read_header(fits[1], String)
    wcs = WCS.from_header(header_str)[1]
    if read_sdss_psf
        header = FITSIO.read_header(fits[1])
        psf = read_psf_from_sdss_header(header)
    else
        psf = make_psf()
    end
    close(fits)
    pixels, psf, wcs
end

function make_band_images(band_pixels, band_psfs, wcs)
    H, W = size(band_pixels[1])
    [
        Model.TiledImage(
            Model.Image(
                H,
                W,
                band_pixels[band],
                band,
                wcs,
                band_psfs[band],
                0, # SDSS run
                0, # SDSS camcol
                0, # SDSS field
                fill(0., H, W), #epsilon_mat,
                fill(950., H), #iota_vec,
                Model.RawPSF(Array(Float64, 0, 0), 0, 0, Array(Float64, 0, 0, 0)),
            ),
            tile_width=48,
        )
        for band in 1:5
    ]
end

# TODO: from test/SampleData.jl
const sample_star_fluxes = [
    4.451805E+03,1.491065E+03,2.264545E+03,2.027004E+03,1.846822E+04]
const sample_galaxy_fluxes = [
    1.377666E+01, 5.635334E+01, 1.258656E+02,
    1.884264E+02, 2.351820E+02] * 100  # 1x wasn't bright enough

function make_catalog_entry()
    Model.CatalogEntry(
        [18., 18.], # pos
        false, # is_star
        sample_star_fluxes,
        sample_galaxy_fluxes,
        0.1, # gal_frac_dev
        0.7, # gal_ab
        pi / 4, # gal_angle
        4., # gal_scale
        "sample", # objid
        0, # thing_id
    )
end

function pretty_print_params(params)
    ids = Model.ids
    @printf "Location in world coords: (%.2f, %.2f)\n" params[ids.u[1]] params[ids.u[2]]
    @printf "Weight on exponential (vs. Vaucouleurs): %.2f\n" params[ids.e_dev]
    @printf "Minor/major axis ratio: %.2f\n" params[ids.e_axis]
    @printf "Angle: %.2f rad (%.1f deg)\n" params[ids.e_angle] params[ids.e_angle] * 180/pi
    @printf "Scale: %.2f\n" params[ids.e_scale]
    @printf "Galaxy brightness lognormal mean %.2f, var %.2f\n" params[ids.r1[2]] params[ids.r2[2]]
    @printf "Probability of star: %.2f; of galaxy: %.2f\n" params[ids.a[1]] params[ids.a[2]]
end

function main()
    #pixels, psf, wcs = read_fits(FILENAME)
    #band_images = make_band_images(fill(pixels, 5), fill(psf, 5), wcs)
    #catalog_entry = make_catalog_entry()

    band_pixels = []
    band_psfs = []
    wcs = 0
    for band in 1:5
        pixels, psf, wcs = read_fits(
            "output/stamp-$(Model.band_letters[band])-5.0073-0.0739_2kpsf.fits",
            read_sdss_psf=true,
        )
        push!(band_pixels, pixels)
        push!(band_psfs, psf)
    end
    band_images = make_band_images(band_pixels, band_psfs, wcs)
    catalog_entries = load_stamp_catalog("output", "s82-5.0073-0.0739_2kpsf", band_images)
    catalog_entry = catalog_entries[1]

    ea = make_elbo_args(band_images, [catalog_entry], fit_psf=false)
    iter_count, max_f, max_x, nm_result = OptimizeElbo.maximize_f(
        ElboDeriv.elbo_likelihood,
        ea,
        loc_width=1.0,
    )
    pretty_print_params(max_x)
    max_x
end

end # module GalsimBenchmark
