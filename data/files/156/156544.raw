module Graviton

import DataFrames
import JSON
import Requests
import Requests: get, post, put, delete, json
import ZipFile

const server_url = "https://genetrail2.bioinf.uni-sb.de";
const api_base = string(server_url,"/api/");

export GravitonException,
	Session,
	Organism,
	Resource,
	Pipeline,
	Identifier,
	delete,
	name,
	categories,
	identifiers,
	organisms,
	algorithms,
	parameters,
	job_start,
	job_stop,
	job_query,
	job_setup,
	job_wait,
	upload,
	upload_gmt,
	download,
	compute_scores,
	compute_enrichment,
	read_enrichments

type GravitonException <: Exception
	message::AbstractString
end

"""
A type representing a Graviton user.

### TODO
Due to limitations in the API this type is not really useful, yet.
"""
type User
	loggedin::Bool
	username::AbstractString
	email::AbstractString
end

"""
A type representing a Graviton session.

A session is identified by a UUID generated by the sever. It serves as a
container for jobs and resources.
"""
type Session
	id::Base.Random.UUID

	Session() = new(json(get(string(api_base, "session/")))["session"]);

	Session(id) = new(id);

	function Session(user::User)
		if !user.loggedin
			throw(GravitonException("User is not logged in."));
		end

		resp = json(get(string(api_base, "session/"), query=Dict("username" => user.username)));

		if haskey(resp, "status")
			throw(GravitonException(resp["message"]));
		end

		return new(resp["session"]);
	end
end

"""
Delete a Graviton session.

This deletes the session and all associated data.

### Arguments
 * `session` : The session that should be deleted.

### Returns
`true` if the session could successfully be deleted. `false` otherwise.
"""
function delete(session::Session)
	resp = json(delete(string(api_base, "/session/", session.id)));

	return resp["status"] == "success"
end

"""
A type representing an organism.

Graviton uses the `taxonId` field to refer to organisms in its API.
"""
type Organism
	taxonId::Integer
	fullName::AbstractString
	keggOrgCode::AbstractString
end

"""
A type representing a Graviton resource.

A resource is a handle that identifies some data on the server.

### TODO
`creationDate` and `modificationDate` should be `DateTime`
however the Julia implementation cannot deal with +0000
"""
type Resource
	id::Integer
	kind::AbstractString
	session::Session
	creationDate::AbstractString
	modificationDate::AbstractString
	metadata::Dict

	function Resource(session::Session, res::Dict)
		return new(
			res["id"],
			res["type"],
			session,
			res["creationDate"],
			res["modificationDate"],
			res["metadata"]
		);
	end
end

# /user
function loggedIn(user::User)
	return user.loggedin;
end

function logIn!(user::User, password::AbstractString)
	resp = json(post(string(api_base, "user/login"), data=Dict(
		"username" => user.username,
		"password" => password
	)));

	if resp["status"] == "success"
		user.loggedin = true;
		return true;
	end

	return false;
end

function logOut!(user::User)
	resp = json(post(string(api_base, "user/logout"), data=Dict("username" => user.username)));

	if resp["status"] == "success"
		user.loggedin = false;
		return true;
	end

	return false;
end

"""
Enum describing the available pipelines in Graviton.
A `Pipeline` describes which kind of biological entities such as genes,
proteins, miRNAs, or metabolites are contained in a given dataset. Also,
every database `Identifier` is assigned to a `Pipeline`. The `Pipeline`
`Unassigned` is used to decribe `Identifier`s that are not directly
associated with a given biological entity. An example for this are "KEGG
Disease" identifiers.

### Constructors
`Pipeline(name::AbstractString)` create a `Pipeline` from its name.
"""
@enum Pipeline Gene Protein Mirna Snp Metabolite Unassigned;

"""
Get the Graviton string representation of a `Pipeline`.
"""
function name(pipe::Pipeline)
	if pipe == Gene
		return "gene";
	elseif pipe == Protein
		return "protein";
	elseif pipe == Mirna
		return "mirna";
	elseif pipe == Snp
		return "snp";
	elseif pipe == Metabolite
		return "metabolite";
	elseif pipe == Unassigned
		return "none";
	end

	throw(ArgumentError("Unhandled pipeline enum value"));
end

function Pipeline(name::AbstractString)
	if name == "gene"
		return Gene;
	elseif name == "protein"
		return Protein;
	elseif name == "mirna"
		return Mirna;
	elseif name == "snp"
		return Snp;
	elseif name == "metabolite"
		return Metabolite;
	elseif name == "none"
		return Unassigned;
	end

	throw(ArgumentError(string("Unknown pipeline '", name, "'.")));
end

"""
A type representing a database identifier. Each identifier is assigned to a
`Pipeline`. The name property is used by the `Graviton` server to refer to this
identifier.
"""
type Identifier
	name::AbstractString
	fullName::AbstractString
	pipline::Pipeline
end

# Session-less methods
"""
Retrieves the ids of all available categories.

### Keyword arguments
 * `session` : Retrieve all user uploaded categories belonging to this session.
 * `pipeline` : Only retrieve the categories matching the provided pipeline.
 * `organism` : Only retrieve the categories for the specified organism.
"""
function categories(; session = nothing, pipeline = nothing, organism = nothing)
	params = Dict{AbstractString, Any}();

	if typeof(session) == Session
		params["session"] = session.id;
	end

	if typeof(pipeline) == Pipeline
		params["pipeline"] = name(pipeline);
	end

	if typeof(organism) == Organism
		params["organism"] = organism.taxonId;
	elseif organism != nothing
		params["organism"] = Integer(organism);
	end

	return json(get(string(api_base, "categories/"), query = params));
end

# Todo: Full categories

"""
Retrieves the list of known identifiers.

### Keyword arguments:

 * `pipeline` : Only retrieve identifiers associated with the given pipeline.
 * `contains` : The retrieved identifiers should contain the specified string
                in their name or description.
"""
function identifiers(; pipeline=nothing, contains=nothing)
	params = Dict{AbstractString, Any}();

	if(typeof(pipeline) == Pipeline)
		params["pipeline"] = name(pipeline);
	else
		throw(TypeError(:identifier, "pipeline", Pipeline, typeof(pipeline)));
	end

	if(typeof(contains) <: AbstractString)
		params["contains"] = contains;
	else
		throw(TypeError(:identifier, "contains", AbstractString, typeof(contains)));
	end

	identifiers = json(get(string(api_base, "identifier/"), query = params));

	return [Identifier(x["name"], x["fullName"], Pipeline(x["pipeline"])) for x in identifiers];
end

"""
Retrieves an array of all known organisms.
"""
function organisms()
	orgs = json(get(string(api_base, "organisms/")));

	return [Organism(x["taxonId"], x["fullName"], x["keggOrgCode"]) for x in orgs];
end

# /job

"""
Retrieves the list of valid job names.
"""
function algorithms()
	return json(get(string(api_base, "job/algorithms")));
end

"""
Retrieve the list of parameter names for a job.
"""
function parameters(name::AbstractString)
	return json(get(string(api_base, "job/parameters/", name)));
end


"""
Starts a previously setup job.

### Arguments
 * `session` : A Graviton `Session` for which the job should be started.
 * `contact` : (Optional) An email address to which a notification should be
			   sent once the computation has completed.

### Exceptions
 * `GravitonException` if the server returned an error.
"""
function job_start(session::Session, contact::AbstractString="")
	response = json(get(string(api_base, "job/start"), query=Dict(
		"session" => session.id,
		"contact" => contact
	)));

	if response["status"] == "error"
		throw(GravitonException(response["message"]));
	end
end

"""
Stop the currently running job.

### Arguments
 * `session` : The Graviton `Session` in which a job is currently running.

### Returns
The server response parsed into a `Dict`.
"""
function job_stop(session::Session)
	return json(get(string(api_base, "job/stop"), query=Dict(
		"session" => session.id,
	)));
end

"""
Query the status of a running job.

### Arguments
 * `session` : The Graviton `Session` in which a job is currently running.

### Returns
The server response parsed into a `Dict`.
"""
function job_query(session::Session)
	return json(get(string(api_base, "job/query"), query=Dict(
		"session" => session.id,
	)));
end

"""
Prepare a job for execution.

Calling the setup function schedules a job using algorithm `name` to run on the
server. The job is associated with the passed `Session`. The parameters of the
algorithm need to be specified as a `Dict` of (String,Value) pairs. Arrays of
objects should be passed as JSON encoded strings.

### Arguments
 * `session` : The Graviton `Session` for which the job should be created.
 * `name` : The name of the algorithm that should be used. Possible values can
   be obtained by calling `algorithms()`.
 * `params` : A Dict containing the parameters required for the algorithm. The
   needed values can be obtained by calling `parameters(name)`.
"""
function job_setup(session::Session, name::AbstractString, params::Dict)
	response = json(post(string(api_base, "job/setup/", name),
		query = Dict("session" => session.id),
		data = params
	));

	if response["status"] != "success"
		throw(GravitonException(response["message"]));
	end
end

# /upload
function add_params!(params::Dict{AbstractString, Any}, organism, identifier)
	if organism != nothing
		if typeof(organism) == Organism
			params["organism"] = organism.taxonId;
		else
			params["organism"] = Integer(organism);
		end
	end

	if identifier != nothing
		if(typeof(identifier) == Identifier)
			params["identifier"] = identifier.name;
		else
			params["identifier"] = Integer(identifier);
		end
	end
end

function upload_type(session::Session, file, filetype, fileparam, organism, identifier)
	params = Dict{AbstractString, Any}("session" => session.id);
	add_params!(params, organism, identifier);

	result = json(post(string(api_base, "upload", filetype), query=params, files=[
		Requests.FileParam(readall(file), "text/plain", fileparam, basename(file))
	]));

	if result["status"] == "success"
		res = result["results"]["result"];
		return Resource(session, result["results"]["result"]);
	elseif result["status"] == "error"
		throw(GravitonException(string("Error while uploading file '", file, "'. Reason: ", result["message"])));
	else
		throw(GravitonException(string("Error while uploading file '", file, "'.")));
	end
end

"""
Upload a file and use automatic filetype detection.

Automatic file detection works for score lists, identifier lists,
VCF files, BED files, and matrices.

Be aware, that file size restrictions may apply on the server side.

### Arguments
 * `session` : The Graviton session in which the file should be stored.
 * `file` : A path to the file that should be uploaded.

### Keyword Arguments
 * `organism` : If the organism from which the data in the file were obtained
   is known, then a taxonId can be provided here.
 * `identifier` : If the database iderntifiers used in the file are known,
   then, the corresponding identifier type can be specified here.

### Returns
A `Resource` representing the uploaded file on the server.

### Exceptions
 * `GravitonException` if an error occurred during file upload.
"""
function upload(session::Session, file; organism=nothing, identifier=nothing)
	return upload_type(session, file, "", "file", organism, identifier);
end

"""
Upload a GMT file.

For more details see `upload()`.
"""
function upload_gmt(session::Session, file; organism=nothing, identifier = nothing)
	return upload_type(session, file, "/gmt", "gmt_file", organism, identifier);
end

# /resource

"""
Create a `Resource` from a `Session` and its identifer.

### Arguments
 * `session` : The Graviton `Session` in which the resource is stored.
 * `id` : The integer identifier of the requested resource.

### Returns
The requested `Resource` instance.
"""
function Resource(session::Session, id::Integer)
	res = json(get(string(api_base, "resource", id), query=Dict("session" => session.id)));

	return Resource(session, res);
end

"""
Permanently deletes a resource on the server.

### Arguments
 * `res` : The `Resource` that should be deleted.
"""
function delete(res::Resource)
	delete(string(api_base, "resource/", res.id), query=res.session.id);
end

"""
Download a resource and store it in a file.

### Arguments
 * `res` : The `Resource` that should be downloaded.
 * `file` : A path to the location the data should be stored in.
"""
function download(res::Resource, file::AbstractString)
	response = get(string(api_base, "resource/", res.id, "/download"), query = Dict("session" => res.session.id));

	Requests.save(response, file);
end

# Convenience functions

"""
Convenience method that waits while a job is running and returns the
generated results vector.

### Arguments
 * `session` : The Graviton `Session` in which the job is running.

### Keyword Arguments
 * `sleepamount` : Specifies the interval in which the job status is polled.
 * `printstatus` : Print the current status of the job.

### Returns
A `Dict` of `Resources` generated by the job.
"""
function job_wait(session::Session; sleepamount = 1, printstatus::Bool = true)
	results = [];

	while true
	    response = job_query(session);

		status = response["status"];

		if status == "success"
			if printstatus
				print('\n');
			end
	        results = response["results"];
			break;
		elseif status == "error"
			throw(GravitonException(response["message"]))
		elseif status == "status" && printstatus
			print('\r');
			print(response["message"]);
		end

		sleep(sleepamount);
	end

	return [x[1] => Resource(session, x[2]) for x in results];
end

"""
Convenience method for computing scores from a sample matrix.

### Arguments
 * `matrix` : A `Resource` representing a matrix. The matrix must contain row names.
 * `samplegroup` : An `Array` of column names representing the sample group.
 * `referencegroup` : An `Array` of column names representing the reference group.

### Keyword Arguments
 * `printstatus` : Boolean switch that enables printing the status messages
   returned from the server.
"""
function compute_scores{S <: AbstractString}(
	matrix::Resource,
	samplegroup::Array{S,1},
	referencegroup::Array{S,1},
	method::AbstractString;
	printstatus::Bool=true
)
	params = Dict(
		"method" => method,
		"sg" => JSON.json(samplegroup),
		"rg" => JSON.json(referencegroup),
		"file1" => matrix.id,
	);

	job_setup(matrix.session, "scoring", params);
	job_start(matrix.session);

	return job_wait(matrix.session, printstatus=printstatus)["scores"];
end

"""
Convenience method for computing enrichments given a score resource.

### Arguments
 * `scores` : The scores on which the computation should be based.
 * `method` : The name of an enrichment algorithm that should be called.
 * `categories` : An `Array` of category collection identifiers. Available
   categories can be obtained using `categories()`. User generated categories
   should be encoded as "/user/{id}" where `id` is the corresponding resource
   identifier.

### Keyword Arguments
 * `minimum` : The minimum category size for which enrichments are computed.
 * `maximum` : The maximum category size for which enrichments are computed.
 * `significance` : The significance threshold used during computation.
 * `adjustment` : The method that should be used to correct for multiple
   hypothesis testing.
 * `adjustSeparately` : If multiple category collections are used, this
   determines if the computed p-values are adjusted across all collections or
   just within each collection individually.
 * `printstatus` : Boolean switch that enables printing the status messages
   returned from the server.
 * `args...` : Further arguments are passed to the server.

### Returns
A `Resource` representing an enrichment.
"""
function compute_enrichment{S <: AbstractString}(
	scores::Resource,
	method::AbstractString,
	categories::Array{S, 1};
	minimum::Integer=5,
	maximum::Integer=500,
	significance::Number=0.05,
	adjustment::AbstractString="benjamini_hochberg",
	adjustSeparately::Bool=false,
	printstatus::Bool=true,
	args...
)
	job_params = Dict(
		"minimum"          => minimum,
		"maximum"          => maximum,
		"categories"       => JSON.json(categories),
		"significance"     => significance,
		"adjustment"       => adjustment,
		"adjustSeparately" => adjustSeparately,
		"input"            => scores.id,
	);

	for (k,v) in args
		job_params[string(k)] = v;
	end

	job_setup(scores.session, method, job_params);
	job_start(scores.session);

	return job_wait(scores.session, printstatus=printstatus)["enrichment"];
end

"""
Convenience method for reading downloaded enrichments as `DataFrame`s.

### Arguments
 * `file` : The path to the enrichment file.

### Returns
For each category collection for that an enrichment was computed, a `DataFrame`
containing the p-values and other statistics is returned.
"""
function read_enrichments(file)
	zipfile = ZipFile.Reader(file);

	enrichments = [DataFrames.readtable(f, separator='\t', header=true) for f in zipfile.files];

	for enr in enrichments
		DataFrames.rename!(enr, :_Name, :Name);
	end

	return enrichments;
end

end # module

