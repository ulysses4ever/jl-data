module FPUtil

using Jules

export
@bounce,
append,
concat,
drop,
dropright,
dropwhile,
firstopt,
findwhere,
flatmap,
flatten,
fmap,
foreach,
indexwhere,
lastopt,
maxby,
minby,
prepend,
pairnext,
take,
takeright,
takewhile,
trampoline,
zipwithindex


#### Trampolines (from https://github.com/zachallaun/FunctionalUtils.jl)
immutable Continue
  thunk
end
macro bounce(ex)
  :(Continue(() -> $(esc(ex))))
end
function trampoline(c::Continue)
  while isa(c, Continue)
    c = c.thunk()
  end
  c
end
trampoline(f::Function, args...) = trampoline(f(args...))
trampoline(val) = val

#### Sequences
indexwhere = findfirst

prepend(xs::Vector, x) = vcat([x], xs)
append(xs::Vector, x) = vcat(xs,[x])
concat(xs::Vector,ys::Vector) = vcat(vec(xs), vec(ys))

firstopt(xs::Vector) = isempty(xs) ? nothing : first(xs)
lastopt(xs::Vector) = isempty(xs) ? nothing : last(xs)

Base.take(n::Integer, xs::Vector) = xs[1:n]
drop(n::Integer, xs::Vector) = xs[(n+1):end]

takeright(n::Integer, xs::Vector) = drop(length(xs) - n, xs)
dropright(n::Integer, xs::Vector) = take(length(xs) - n, xs)

takewhile(pred::Function, xs::Vector) = xs[1:(findfirst(negate(pred), xs) - 1)]
dropwhile(pred::Function, xs::Vector) = xs[(findfirst(negate(pred), xs) + 1 - 1):end]

minby(f::Function, xs::Vector) = reduce((x, y) -> (f(x) < f(y)) ? x : y, xs)
maxby(f::Function, xs::Vector) = reduce((x, y) -> (f(x) > f(y)) ? x : y, xs)

function findwhere(xs::Vector)
  i = indexwhere(xs)
  i == 0 ? nothing : xs(i)
end

flatmap(f::Function, xs::Vector) = foldl((y, x) -> concat(y,f(x)), [], xs)
flatten(xs::Vector) = flatmap(identity, xs)
function foreach(f::Function, xs::Vector)
  for x in xs
    f(x)
  end
end

pairnext(xs::Vector) = zip(xs, drop(1, xs))
zipwithindex(xs::Vector) = zip(xs, 1:length(xs))

getorelse(x, default) = isnothing(x) ? default : x

end ## end module
