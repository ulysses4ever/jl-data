module Streaming

using Jules
using FPUtil
using StatsBase
using Logging
setloglevel()

export
merge,
moments,
update,
nobs,
mean,
Moments,
var,
std,
kurtosis,
skewness,
streammse

############################
## Moments
############################

type Moments
  n :: Integer
  mean :: FloatingPoint
  m2 :: FloatingPoint
  m3 :: FloatingPoint
  m4 :: FloatingPoint
end

stabilityratio = 0.1

function merge(xa :: Moments, xb :: Moments)
  delta = xb.mean - xa.mean
  n = xa.n + xb.n

  xsmall, xlarge = (xa.n < xb.n) ? (xa, xb) : (xb, xa)

  ratio = xsmall.n / n
  mean = if ratio < stabilityratio
    xlarge.mean + (xsmall.mean - xlarge.mean) * ratio
  else
    (xa.n * xa.mean + xb.n * xb.mean) / n
  end

  m2 = xa.m2 + xb.m2 + ((delta * delta) * xa.n * xb.n / n)

  m3 = xa.m3 + xb.m3 +
  ((delta * delta * delta) * xa.n * xb.n * (xa.n - xb.n) / (n * n)) +
  (3 * delta * (xa.n * xb.m2 - xb.n * xa.m2) / n)

  m4 = xa.m4 + xb.m4 +
  ((delta * delta * delta * delta) * (xa.n * xb.n * ((xa.n * xa.n - xa.n * xb.n + xb.n * xb.n))) / (n * n * n)) +
  (6 * (delta * delta) * (xa.n * xa.n * xb.m2 + xb.n * xb.n * xa.m2) / (n * n)) +
  (4 * delta * (xa.n * xb.m3 - xb.n * xa.m3) / n)

  Moments(n, mean, m2, m3, m4)
end

moments() = Moments(0, 0, 0, 0, 0)
moments(x) = Moments(1, x, 0, 0, 0)
moments(xs :: Vector) = foldl((a,b) -> update(a,b), moments(), xs)
update(m :: Moments, x) = merge(m, moments(x))
update(m :: Moments, x, n) = merge(m, Moments(n, x * n))
nobs(m :: Moments) = m.n
Base.mean(m :: Moments) = m.mean
Base.var(m :: Moments) = m.m2 / m.n
Base.std(m :: Moments) = sqrt(var(m))
StatsBase.skewness(m :: Moments) = sqrt(m.n) * m.m3 / (m.m2 ^ 1.5)
StatsBase.kurtosis(m :: Moments) = (m.n * m.m4) / (m.m2 * m.m2) - 3

streammse() = (0.0, 0.0, 0.0, 0.0, 0)
function streammse(accumulated, y, add :: Bool = true)
  y2sum0, ysum0, twoxysum0, x0, n0 = accumulated

  if add
    if n0 == 0
      ((y^2, y, 2 * y * y, y, 1), 0)
    else
      y2sum1 = y2sum0 + y^2
      ysum1 = ysum0 + y
      n1 = n0 + 1
      x1 = ysum1 / n1
      twoxysum1 = (2 * y + twoxysum0 / x0) * x1

      mse = (y2sum1 + n1 * x1^2 - twoxysum1) / n1

      ((y2sum1, ysum1, twoxysum1, x1, n1), mse)
    end
  else
    @assert n0 > 0

    y2sum1 = y2sum0 - y^2
    ysum1 = ysum0 - y
    n1 = n0 - 1
    x1 = ysum1 / n1
    twoxysum1 = (twoxysum0 / x0 - 2 * y) * x1

    mse = (y2sum1 + n1 * x1^2 - twoxysum1) / n1

    ((y2sum1, ysum1, twoxysum1, x1, n1), mse)
  end
end

function streammse(ys :: Vector, accumulated = (0.0, 0.0, 0.0, 0.0, 0); add :: Bool = true)
    a = (accumulated, nothing)
    for i in 1:length(ys)
      a = streammse(a[1], ys[i], add)
    end
    a
end



end ## end module
