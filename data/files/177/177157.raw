module signalprocessing
export filterwav, dumpspectrograms, imgfeature, featurenormalise, subsampledata, convertclasses,
toint, confusmat, imgfeature_predict, reshapepred
using DSP, Images, DataFrames

#filter parameters
fc = 1250
npoles = 4

# half widths of feature box
boxwidth = 3
boxheight = 10

function filterwav(signal, fs)
  #filter the wav recording using a high pass Butterworth filter
  #with cutoff frequency 1250Hz
  responsetype = Highpass(fc/(fs/2))
  designmethod = Butterworth(npoles) # fourth order filter
  signal = filt(digitalfilter(responsetype,designmethod),signal)
  return  signal
end

function dumpspectrograms(signal,segments,path,nameprefix,specwidth)
  left = segments[1:end-1]
  right = segments[2:end]-1
  for (i,l) in enumerate(left)
    #compute a spectrogram with roughly equal time and freq information
    spec = spectrogram(signal[l:right[i]],specwidth,window=hanning)
    filename = string(path,nameprefix,"$i.png")
    imwrite(flipud(spec.power/maximum(spec.power)),filename)
  end
end

function imgfeature(img,imgmask,filename,recorderdata)
#construct feature histogram for each pixel in image and corresponding label

  sepmask = separate(imgmask).data; #separate layers in order to get layers
  nrows = height(img);
  ncols = width(img);
  npix = (2*boxheight+1)*(2*boxwidth+1); #number of pixels in a boxheight
  nbox = (ncols - 2*boxwidth)*(nrows - 2*boxheight); #number of boxes in an image
  boxmu = Array(Float64,nbox);
  boxvar = Array(Float64,nbox);
  freq = Array(Float64,nbox);
  pixels = Array(Float64,nbox,npix); #initialise the data array to correct dims
  label = zeros(nbox);
  pcount = 0;
  freqvector = getfreqvector(getrecorder(filename),recorderdata,nrows);

  #extract values from Gray image structure
  imgdata = getgrayval(img);
  for row in (boxheight+1):(nrows-boxheight)
    for col in (boxwidth+1):(ncols-boxwidth)
      pcount += 1
      box = imgdata[(col-boxwidth):(col+boxwidth),(row-boxheight):(row+boxheight)]
      boxmu[pcount] = mean(box);
      boxvar[pcount] = var(box);
      freq[pcount] = freqvector[row];
      pixels[pcount,:] = box[:]';
      #print("row = $row, shouldn't exceed $(nrows-boxheight), col = $col, pcount = $pcount\n")
      label[pcount] = getlabel(sepmask,row,col)
    end
  end
  return pixels,freq,boxmu,boxvar,label
end

function imgfeature_predict(img,filename,recorderdata)
#construct feature histogram for each pixel in image and corresponding label

  nrows = width(img);
  ncols = height(img);
  npix = (2*boxheight+1)*(2*boxwidth+1); #number of pixels in a boxheight
  nbox = (ncols - 2*boxwidth)*(nrows - 2*boxheight); #number of boxes in an image
  boxmu = Array(Float64,nbox);
  boxvar = Array(Float64,nbox);
  freq = Array(Float64,nbox);
  pixels = Array(Float64,nbox,npix); #initialise the data array to correct dims
  pcount = 0;
  freqvector = getfreqvector(getrecorder(filename),recorderdata,nrows);

  #extract values from Gray image structure
  imgdata = getgrayval(img);
  for row in (boxheight+1):(nrows-boxheight)
    for col in (boxwidth+1):(ncols-boxwidth)
      pcount += 1
      box = imgdata[ (row-boxheight):(row+boxheight) , (col-boxwidth):(col+boxwidth)]
      boxmu[pcount] = mean(box);
      boxvar[pcount] = var(box);
      freq[pcount] = freqvector[row];
      pixels[pcount,:] = box[:]';
      #print("row = $row, shouldn't exceed $(nrows-boxheight), col = $col, pcount = $pcount\n")
    end
  end
  return pixels,freq,boxmu,boxvar
end

function getlabel(imgmask,r,c)

  if imgmask[r,c,1] == 1
    label = 1 # pixel labelled as a non-target
  elseif imgmask[r,c,3] == 1
    label = 2 # pixel labelled as a target syllable
  else
    label = 0 # pixel unlabelled
  end

  return label

end

function getgrayval(img)
  #extract the floating point value for the grayscale image.
  m = width(img)
  n = height(img)
  A = Array(Float64,m,n)  #array of values
  for i in 1:m
    for j in 1:n
      A[i,j] = convert(Float64,img[i,j].val); #convert to floats
    end
  end
  return A
end

function featurenormalise(data)
#normailse given data by (data - mu)/sigma and return mu and sigma

  mu = mean(data,1) # find mean and std of columns
  sigma = std(data,1)
  (m,n) = size(data)
  X = (data - ones(m)*mu) ./ (ones(m)*sigma)
  return X,mu,sigma
end

function featurenormalise_predict(data,mu,sigma)
#normailse given data by (data - mu)/sigma and return mu and sigma

  X = (data - ones(m)*mu) ./ (ones(m)*sigma)
  return X
end

function getrecorder(filename)
# parse the filename and extract the filename and return the recorder
  recorder = filename[1:search(filename,'_')-1];
  return recorder
end

function getfreqvector(recorder,recorderdata,n)
  fs=0
  count = 0;
  for name in recorderdata[:recorders]
    count += 1;
    if (name == recorder)
      fs = recorderdata[:fsample][count];
    end
  end
  if fs == 0
    error("Sampling frequency must be nonzero. Recorder $recorder not found in data.")
  end
  freq = linspace(0,fs,n+1)[2:end];
  return freq
end

function subsampledata(featuredata,labeldata,ratio)

  #find the indices of each the three different labels
  nzind = find(labeldata);
  ind0 = setdiff(1:length(labeldata),nzind);
  ind1 = nzind[setdiff(1:length(nzind), find(labeldata[nzind]-1))]
  ind2 = setdiff(nzind,ind1)

  M2 = length(ind2);

  # M is the number of each type we will subsample. we should always have more
  # noise than bird calls but the min is there for robustness
  M0 = Int(min(length(ind0),floor(M2*ratio)))
  M1 = Int(min(length(ind1),floor(M2*ratio)))

  subind0 = ind0[randperm(length(ind0))[1:M0]]
  subind1 = ind1[randperm(length(ind1))[1:M1]]

  ind = vcat(subind0,subind1,ind2)
  ind = ind[randperm(length(ind))] #randomise the indices up so they arent ordered
  featuredata = featuredata[ind,:]
  labeldata = labeldata[ind]

  return featuredata, labeldata

end

function convertclasses(labels)
  labels = labels - 1
  for i in 1:length(labels)
    if labels[i] < 0
      labels[i] = 0
    end
  end
  return labels
end

function toint(x)
  cx = Array(Int,size(x))
  for i in 1:length(x)
    cx[i] = convert(Int,x[i]);
  end
  return cx
end

function confusmat(gt,pred)
# create a 2 class confusion matrix
  N = length(gt)
  C = zeros(2,2)
  nn,np,pn,pp = 0,0,0,0;
  length(pred) == N || throw(error("Inconsistent lengths."))
  for i in 1:N
    if gt[i] == 0
      if pred[i] == 0
        nn += 1
      else
        np += 1
      end
    else
      if pred[i] == 0
        pn += 1
      else
        pp += 1
      end
  C = hcat([nn,np],[pn,pp]);
    end
  end
  return C
end

function reshapepred(y,m,n)
  cols = m - 2*boxwidth;
  rows = n - 2*boxheight;
  return reshape(y,cols,rows)
end

function segmentimage()

end


end
