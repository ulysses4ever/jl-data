module SpimRegXML

using LightXML, AffineTransforms


type ViewSetup
	id::Int
	name::AbstractString
	template_filepath::AbstractString
	size::Vector{Int}
	sampling::Vector{Real}
	illumination::Int
	channel::Int
	angle::Int
end

ViewSetup() = ViewSetup(-1, "", "", [], [], -1, -1, -1)


type NamedAffine
	name::AbstractString
	affine::AffineTransform
end


function viewsetups( filepath::AbstractString )
	out = Dict{Int, ViewSetup}()
	xdoc = parse_file(filepath)
	xseq = find_element(root(xdoc), "SequenceDescription")

	for xsetup in child_elements( find_element(xseq, "ViewSetups") )
		if name(xsetup) != "ViewSetup"
			continue
		end

		setup = ViewSetup()
		setup.id = parse(Int, content( find_element(xsetup, "id") ) )

		size = split( strip( content( find_element(xsetup, "size") ) ), r"\s+" )
		setup.size = [ parse(Int, s) for s in size ]

		xsampling = find_element(xsetup, "voxelSize")
		sampling = split( strip( content( find_element(xsampling, "size") ) ), r"\s+" )
		setup.sampling = [ float(s) for s in sampling ]

		xattrs = find_element(xsetup, "attributes")
		setup.illumination = parse(Int, content( find_element(xattrs, "illumination") ) )
		setup.channel = parse(Int, content( find_element(xattrs, "channel") ) )
		setup.angle = parse(Int, content( find_element(xattrs, "angle") ) )

		out[setup.id] = setup
	end

	xresolver = find_element( find_element(xseq, "ImageLoader"), "Resolver" )
	if xresolver != Void
		id = -1
		for xelem_outer in child_elements(xresolver)
			if name(xelem_outer) == "ViewSetupTemplate"
				for xelem_inner in child_elements(xelem_outer)
					if name(xelem_inner) == "template"
						id += 1
						out[id].template_filepath = strip( content(xelem_inner) )
					end
				end
			end
		end
	end

	return out
end


function transforms( filepath::AbstractString )
	out = Dict{ Int, Dict{Int, Vector{NamedAffine}} }()
	xdoc = parse_file(filepath)
	registrations = find_element(root(xdoc), "ViewRegistrations")
	for registration in child_elements(registrations)
		t = int( attribute(registration, "timepoint") )
		setup = int( attribute(registration, "setup") )
		if !haskey(out, t)
			out[t] = Dict{Int, Vector{NamedAffine}}()
		end
		out[t][setup] = affine_list(registration)
	end
	return out
end


function affine_list( xml::XMLElement )
	@assert name(xml) == "ViewRegistration"
	return [ affine(e) for e in get_elements_by_tagname(xml, "ViewTransform") ]
end


function affine( xml::XMLElement )
	@assert name(xml) == "ViewTransform" && attribute(xml, "type") == "affine"

	nam = ""
	xelem = find_element(xml, "Name")
	if typeof(xelem) == XMLElement
		nam = strip( content(xelem) )
	end

	parts = split( strip( content( find_element(xml, "affine"))), r"\s+" )
	values = Array(Real, 4, 3)
	for (i, s) in enumerate(parts)
		values[i] = float(s)
	end
	values = transpose(values)

	return NamedAffine(nam, AffineTransform(values[:, 1:3], values[:, 4]))
end


function xml(
		affines::Dict{ Int, Dict{Int, Vector{NamedAffine}} },
		filepath_in::AbstractString,
		filepath_out::AbstractString
		)
	xdoc = parse_file(filepath_in)
	xroot = root(xdoc)

	trafos_old = find_element(xroot, "ViewRegistrations")
	unlink(trafos_old)
	free(trafos_old)

	trafos_new = xml(affines)
	add_child(xroot, trafos_new)

	save_file(xdoc, filepath_out)
end


function xml( affines::Dict{ Int, Dict{Int, Vector{NamedAffine}} } )
	out = new_element("ViewRegistrations")
	for t in sort!( [ t for t in keys(affines) ] )
		setups = affines[t]
		for s in sort!( [ s for s in keys(setups) ] )
			trafos = setups[s]
			xtrafos = xml(trafos)
			set_attribute(xtrafos, "timepoint", string(t))
			set_attribute(xtrafos, "setup", string(s))
			add_child(out, xtrafos)
		end
	end
	return out
end


function xml( affines::Vector{NamedAffine} )
	out = new_element("ViewRegistration")
	for a in affines
		add_child(out, xml(a))
	end
	return out
end


function xml( affine::NamedAffine )
	out = new_element("ViewTransform")
	set_attribute(out, "type", "affine")

	if length(affine.name) > 0
		e = new_child(out, "Name")
		add_text(e, affine.name)
	end

	values = Array(Real, 12)
	trafo = affine.affine
	values[ 1: 3] = trafo.scalefwd[1, :]
	values[ 5: 7] = trafo.scalefwd[2, :]
	values[ 9:11] = trafo.scalefwd[3, :]
	values[ 4] = trafo.offset[1]
	values[ 8] = trafo.offset[2]
	values[12] = trafo.offset[3]

	e = new_child(out, "affine")
	add_text(e, join(values, " "))
	return out
end

end # module
