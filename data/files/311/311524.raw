module SpimRegXML

using LightXML, AffineTransforms


type ViewSetup
  id::Int
  name::String
  template_filepath::String
  size::Vector{Int}
  sampling::Vector{Real}
  illumination::Int
  channel::Int
  angle::Int
end

ViewSetup() = ViewSetup(-1, "", "", [], [], -1, -1, -1)


type NamedAffine
  name::String
  affine::AffineTransform
end


function viewsetups(
    filepath::String
    )
  out = Dict{Int, ViewSetup}()
  xdoc = parse_file(filepath)
  xseq = find_element(root(xdoc), "SequenceDescription")

  for xsetup in child_elements( find_element(xseq, "ViewSetups") )
    if name(xsetup) != "ViewSetup"
      continue
    end

    setup = ViewSetup()
    setup.id = int( content( find_element(xsetup, "id") ) )

    size = split( strip( content( find_element(xsetup, "size") ) ), r"\s+" )
    setup.size = [ int(s) for s in size ]

    xsampling = find_element(xsetup, "voxelSize")
    sampling = split( strip( content( find_element(xsampling, "size") ) ), r"\s+" )
    setup.sampling = [ float(s) for s in sampling ]

    xattrs = find_element(xsetup, "attributes")
    setup.illumination = int( content( find_element(xattrs, "illumination") ) )
    setup.channel = int( content( find_element(xattrs, "channel") ) )
    setup.angle = int( content( find_element(xattrs, "angle") ) )

    out[setup.id] = setup
  end

  xresolver = find_element( find_element(xseq, "ImageLoader"), "Resolver" )
  if xresolver != Nothing
    id = -1
    for xelem_outer in child_elements(xresolver)
      if name(xelem_outer) == "ViewSetupTemplate"
        for xelem_inner in child_elements(xelem_outer)
          if name(xelem_inner) == "template"
            id += 1
            out[id].template_filepath = strip( content(xelem_inner) )
          end
        end
      end
    end
  end

  return out
end


function transforms(
    filepath::String
    )
  out = Dict{ Int, Dict{Int, Vector{NamedAffine}} }()
  xdoc = parse_file(filepath)
  registrations = find_element(root(xdoc), "ViewRegistrations")
  for registration in child_elements(registrations)
    t = int( attribute(registration, "timepoint") )
    setup = int( attribute(registration, "setup") )
    if !haskey(out, t)
      out[t] = Dict{Int, Vector{NamedAffine}}()
    end
    out[t][setup] = affine_list(registration)
  end
  return out
end


function affine_list(
    xml::XMLElement
    )
  @assert name(xml) == "ViewRegistration"
  return [ affine(e) for e in get_elements_by_tagname(xml, "ViewTransform") ]
end


function affine(
    xml::XMLElement
    )
  @assert name(xml) == "ViewTransform" && attribute(xml, "type") == "affine"

  nam = ""
  xelem = find_element(xml, "Name")
  if typeof(xelem) == XMLElement
    nam = strip( content(xelem) )
  end

  strings = split( strip( content( find_element(xml, "affine"))), r"\s+" )
  values = Array(Real, 4, 3)
  for (i, s) in enumerate(strings)
    values[i] = float(s)
  end
  values = transpose(values)

  return NamedAffine(nam, AffineTransform(values[:, 1:3], values[:, 4]))
end


function xml(
    affines::Vector{NamedAffine}
    )
  out = new_element("ViewRegistration")
  for a in affines
    add_child(out, xml(a))
  end
  return out
end


function xml(
    affine::NamedAffine
    )
  out = new_element("ViewTransform")
  set_attribute(out, "type", "affine")

  if length(affine.name) > 0
    e = new_child(out, "Name")
    add_text(e, affine.name)
  end

  values = Array(Real, 12)
  trafo = affine.affine
  values[ 1: 3] = trafo.scalefwd[1, :]
  values[ 5: 7] = trafo.scalefwd[2, :]
  values[ 9:11] = trafo.scalefwd[3, :]
  values[ 4] = trafo.offset[1]
  values[ 8] = trafo.offset[2]
  values[12] = trafo.offset[3]

  e = new_child(out, "affine")
  add_text(e, join(values, " "))
  return out
end

end # module
