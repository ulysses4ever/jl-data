module FPUtil

using Jules

export
@bounce,
append,
concat,
drop,
dropright,
dropwhile,
firstopt,
findwhere,
flatmap,
flatten,
fmap,
foreach,
indexwhere,
lastopt,
maxby,
mapnonempty,
minby,
prepend,
pairnext,
take,
takeright,
takewhile,
trampoline,
zipwithindex


#### Trampolines (from https://github.com/zachallaun/FunctionalUtils.jl)
immutable Continue
  thunk
end
macro bounce(ex)
  :(Continue(() -> $(esc(ex))))
end
function trampoline(c :: Continue)
  while isa(c, Continue)
    c = c.thunk()
  end
  c
end
trampoline(f :: Function, args...) = trampoline(f(args...))
trampoline(val) = val

#### Sequences
indexwhere = findfirst

prepend(xs :: Vector, x) = vcat([x], xs)
append(xs :: Vector, x) = vcat(xs, [x])
concat(xs :: Vector, ys :: Vector) = vcat(vec(xs), vec(ys))

firstopt(xs :: Vector) = isempty(xs) ? nothing : first(xs)
lastopt(xs :: Vector) = isempty(xs) ? nothing : last(xs)

Base.take(n :: Integer, xs :: Vector) = xs[1:n]
drop(n :: Integer, xs :: Vector) = xs[(n+1):end]

takeright(n :: Integer, xs :: Vector) = drop(length(xs) - n, xs)
dropright(n :: Integer, xs :: Vector) = take(length(xs) - n, xs)

takewhile(pred :: Function, xs :: Vector) = xs[1:(findfirst(negate(pred), xs) - 1)]
dropwhile(pred :: Function, xs :: Vector) = xs[(findfirst(negate(pred), xs) + 1 - 1):end]

function minby(f :: Function, xs :: Vector)
  function f(x, y)
    (f(x) < f(y)) ? x : y
  end
  reduce(f, xs)
end
function maxby(f :: Function, xs :: Vector)
  function f(x, y)
    (f(x) > f(y)) ? x : y
  end
  reduce(f, xs)
end

function findwhere(xs :: Vector)
  i = indexwhere(xs)
  i == 0 ? nothing : xs(i)
end

flatmap(f :: Function, xs :: Vector) = vcat(map(f,xs))
flatten(xs :: Vector) = vcat(xs)
function foreach(f :: Function, xs :: Vector)
  for x in xs
    f(x)
  end
end

pairnext(xs :: Vector) = zip(xs, drop(1, xs))
zipwithindex(xs :: Vector) = zip(xs, 1:length(xs))

getorelse(x, default) = isnothing(x) ? default : x
whensomething(f, x) = isnothing(x) ? nothing : f(x)

Base.map(usepar :: Bool = false) =
  usepar ? pmap : map

fmap{T}(f :: Function, x :: Nullable{T}; emptyDt :: DataType = T) =
  isempty(x) ? Nullable{emptyDt}() : Nullable(f(get(x)))

flatten{T}(x :: Nullable{Nullable{T}}; emptyDt :: DataType = T) =
  isempty(x) ? Nullable{emptyDt}() : get(x)

flatmap{T}(f :: Function, x :: Nullable{T}; emptyDt :: DataType = T) = flatten(fmap(f, x, emptyDt = emptyDt), emptyDt = emptyDt)


function mapnonempty{T}(f :: Function, xs :: Vector{Nullable{T}}; emptyDt :: DataType = T)
  function g (x)
    fmap(f, x, emptyDt = emptyDt)
  end

  map(g, xs)
end


end ## end module
