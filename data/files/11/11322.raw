#unum-unum.jl

#contains information about the unum type and helper functions directly related to constructor.

#the unum type is an abstract type.  We'll be overloading the call function later
#so we can do "pseudo-constructions" on this type.
doc"""
`Unum{ESS,FSS}` creates a Unum with esizesize ESS and fsizesize FSS.

NB:  Internally this may cast to a different Unum type (UnumLarge or UnumSmall)
for performance purposes.  The `Unum{ESS,FSS}(...)` constructor is always safe
and purposes where computational performance is an issue, use of the internal
types is recommended.
"""
abstract Unum{ESS, FSS} <: Real
export Unum

#general parameter checking for unums.
function __general_unum_check(ESS, FSS, exponent::UInt64, esize::UInt16, fsize::UInt16)
  (ESS > 6) && throw(ArgumentError("ESS == $ESS > 6 disallowed in current implementation"))
  (FSS > 11) && throw(ArgumentError("FSS == $FSS > 11 disallowed in current implementation"))
  _mfs = max_fsize(FSS)
  (fsize > _mfs) && throw(ArgumentError("fsize == $fsize > $_mfs maximum for FSS == $FSS."))
  _mes = max_esize(ESS)
  (esize > _mes) && throw(ArgumentError("esize == $esize > $_mes maximum for ESS == $ESS."))
  _mbe = max_biased_exponent(esize)
  (exponent > _mbe) && throw(ArgumentError("exponent == $exponent > $_mbe maximum for esize == $esize."))
  nothing
end

doc"""
`Unums.UnumSmall{ESS,FSS}` is the internal type for Unums with FSS < 7.  These
numbers require a single unsigned 64-bit integer to store their fractions.
"""
@dev_check type UnumSmall{ESS, FSS} <: Unum{ESS, FSS}
  exponent::UInt64
  fraction::UInt64
  esize::UInt16
  fsize::UInt16
  flags::UInt16
end

#parameter checking.  The call to this check is autogenerated by the @dev_check macro
function __check_UnumSmall(ESS, FSS, exponent::UInt64, fraction::UInt64, esize::UInt16, fsize::UInt16, flags::UInt16)
  (FSS > 6) && throw(ArgumentError("UnumSmall internal class is inappropriate for FSS == $FSS > 6."))
  __general_unum_check(ESS, FSS, exponent, esize, fsize)
  nothing
end

doc"""
`Unums.UnumLarge{ESS,FSS}` is the internal type for Unums with FSS > 6.  These
numbers require an array of 64-bit integers to store their fractions.
"""
@dev_check type UnumLarge{ESS, FSS} <: Unum{ESS, FSS}
  exponent::UInt64
  fraction::ArrayNum{FSS}
  esize::UInt16
  fsize::UInt16
  flags::UInt16
end

#parameter checking.  The call to this check is autogenerated by the @dev_check macro
function __check_UnumLarge{FSS}(_ESS, _FSS, exponent::UInt64, fraction::ArrayNum{FSS}, esize::UInt16, fsize::UInt16, flags::UInt16)
  _FSS != FSS && throw(ArgumentError("ArrayNum FSS must match Unum FSS"))
  (FSS < 7) && throw(ArgumentError("UnumLarge internal class is inappropriate for FSS == $FSS < 7."))
  __general_unum_check(_ESS, _FSS, exponent, esize, fsize)
  nothing
end

#override call for copy constructor
@gen_code function Base.call{ESS, FSS}(::Type{Unum{ESS,FSS}}, x::Unum{ESS,FSS})
  @code :(__general_unum_check(ESS, FSS, x.exponent, x.esize, x.fsize))
  @code (FSS < 7) ? (:(UnumSmall(x))) : (:((__check_ArrayNum(FSS, x.fraction.a); UnumLarge(x))))
end

#override call to allow direct instantiation using the Unum{ESS,FSS} pseudo-constructor.
#because this call function is intended to be used strictly for human-interaction purposes.
@generated function Base.call{ESS, FSS}(::Type{Unum{ESS,FSS}}, exponent::UInt64, fraction, esize::UInt16, fsize::UInt16, flags::UInt16)
  arrayconversion = :(fraction)
  if (fraction == UInt64)
    utype = UnumSmall
  elseif (fraction == Array{UInt64, 1})
    utype = UnumLarge
    arrayconversion = :(ArrayNum{FSS}(fraction))
  elseif (fraction == ArrayNum{FSS})
    utype = UnumLarge
  else
    throw(ArgumentError("fraction must be UInt64, ArrayNum, or Array{UInt64,1} "))
  end

  quote
     __general_unum_check(ESS, FSS, exponent, esize, fsize)
     #mask out values outside of the flag range.
     flags &= UNUM_FLAG_MASK
     x = $utype{ESS,FSS}(exponent, $arrayconversion, esize, fsize, flags)
     trim_and_set_ubit!(x, fsize)
     x
  end
end

#masks for the unum flags variable.
const UNUM_SIGN_MASK = UInt16(0x0002)
const UNUM_UBIT_MASK = UInt16(0x0001)
const UNUM_FLAG_MASK = UInt16(0x0003)
