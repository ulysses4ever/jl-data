#= Clustering and Community Structure =#

#= NOTES:

Matlab BCT has 5 clustering coefficient files, 4 corresponding to combinations of binary vs weighted and directed vs undirected and a 5th for signed, weighted graphs. Weights are assumed to be <= 1 in absolute value.

1. clustering_coef_bu by Mika Rubinov is the original cc from Reference: Watts and Strogatz (1998) Nature 393:440-442.

2. clustering_coef_wu by Mika Rubinov generalizes 1 via Reference: Onnela et al. (2005) Phys Rev E 71:065103. It reduces to 1 in the case of a binary, undirected graph.

3. clustering_coef_bd by Mika Rubinov is the generalization to directed graphs from Reference: Fagiolo (2007) Phys Rev E 76:026107. It reduces to 1 in the case of an undirected graph.

4. clustering_coef_wd by Mika Rubinov extends 3 to weighted graphs. Reference is the same and 4 reduces to 3 when weights are binary. In other words, this implementation subsumes the previous 3.

5. clustering_coef_wu_sign by Jeff Spielberg extends 2 to signed, weighted, undirected graphs in 3 different ways.
..a. Onnela et al. formula, used in 2 but computed separately for positive & negative weights.
..b. Zhang & Horvath formula, similar to Onnela formula except denominator of Onnela formula relies on binarizing the network whereas this denominator is based on weight value. Also computed separately for + and - weights.
..c. Constantini & Perugini's generalization of the Zhang & Horvath formula. This formula takes both positive & negative weights into account simultaneously. It reduces to 2 for positive.

Definition of triangle.  By definition, triangles in a directed graph need not be unidirectional. E.g., u->v->w<-u is a valid triangle. Thus there are potentially 8 triangles for every 3 vertices, u, v, w. In an undirected graph there is just 1 for every 3 vertices.

=#

import Graphs

function clustering_coefficient{G <: Graphs.GenericGraph}(g::G)
    W = Graphs.weight_matrix(g, fill(1,Graphs.num_edges(g)));
    return ccoef_common(g,W);
end

function clustering_coefficent{G <: Graphs.GenericGraph}(g::G, key::AbstractString="weight")
    if !has_edge_attribute(g, key)
        error("Graph has no edge attribute named, ", key);
    end
    W = Graphs.weight_matrix(g, map((edge)->edge.attribues["weight"], g.edges)).^(1/3);
    return ccoef_common(g,W);
end

function ccoef_common{G <: Graphs.GenericGraph, T <: Real}(g::G, W::Array{T,2})
    # total degree, in + out
    K = map((v) -> Graphs.in_degree(v,g) + Graphs.out_degree(v,g), g.vertices);
    # 2 cycles
    c2 =map((v) -> length(intersect(Graphs.in_neighbors(v,g),
                                    Graphs.out_neighbors(v,g))), g.vertices);
    # number of possible triangles
    c3 = K.*(K-1) - 2*c2;
    # if no triangles ensure clustering coefficient of 0, a convention
    c3[c3 .== 0] = Inf;
    return diag((W+W')^3)./c3./2;
end


#=
A=W~=0;                     %adjacency matrix
S=W.^(1/3)+(W.').^(1/3);	%symmetrized weights matrix ^1/3
K=sum(A+A.',2);            	%total degree (in + out)
cyc3=diag(S^3)/2;           %number of 3-cycles (ie. directed triangles)
K(cyc3==0)=inf;             %if no 3-cycles exist, make C=0 (via K=inf)
CYC3=K.*(K-1)-2*diag(A^2);	%number of all possible 3-cycles
C=cyc3./CYC3;               %clustering coefficient
=#
