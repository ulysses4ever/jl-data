import Graphs;
import Distributions;

#= NOTE: The BCT's `density` function is omitted since it is just the number of edges over the number of possible edges. For a graph, `g`, this is just the ratio of `Graphs.num_edges(g)` and `Graphs.num_vertices(g)^2`.=#

#= pseudocode for BCT's `rentian_scaling` function:

Find the minimum cube bounding the physical coordinates of the graph.

For a specified number of random cubes within the bounding cube, count the number of vertices within the random cube, N,  and the number of edges which cross it, E. Retrun arrays of N,E.


=#

function has_vertex_attribute{G<:Graphs.GenericGraph}(g::G, key::AbstractString)
    if Graphs.num_vertices(g) == 0 return false end
    if findfirst(fieldnames(g.vertices[1]),:attributes) == 0 return false end
    for v in Graphs.vertices(g)
        if findfirst(collect(keys(v.attributes)),key) == 0 return false end
    end
    return true;
end

function rentian_scaling{G <: Graphs.GenericGraph}(g::G, n::Int, key::AbstractString="coordinates")
    if !has_vertex_attribute(g,key)
        error("Graph's vertices do not have ,", key," attributes.");
    end
    # Extract coordinates as an array
    coords = fill(0.0, (num_vertices(g),3));
    for i in size(coords,1) coords[i,:] = g.vertices[i].attributes[key] end
    # Uniform distribution on upper and lower limits of minimum bounding cube
    U = Distributions.Uniform(minimum(coords), maximum(coords));
    # Sample random subcubes:
    samples = fill(0,(n,2));
    for i in 1:n
        # Lower and upper bounds of a random cube
        cube = sort(rand(U,2));
        # Which individual coordinates are inside?
        temp = cube[1] .<= coords .<= cube[2];
        # Which vertices have all coordinates inside?
        inside = temp[1].*temp[2].*temp[3];
        # Record their number
        samples[i,1] = sum(inside);
        # Count the edges which cross subcube's boundary, i.e., edges
        # for which one, but not both, vertices are inside.
        for edge in g.edges
            samples[i,2] += (inside[edge.source.index] +
                             inside[edge.target.index]) % 2.
        end
    end
end
