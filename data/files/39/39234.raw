#= Clustering and Community Structure =#

#= NOTES:

Matlab BCT has 5 clustering coefficient files, 4 corresponding to combinations of binary vs weighted and directed vs undirected and a 5th for signed, weighted graphs. Weights are assumed to be <= 1 in absolute value.

1. clustering_coef_bu by Mika Rubinov is the original cc from Reference: Watts and Strogatz (1998) Nature 393:440-442.

2. clustering_coef_wu by Mika Rubinov generalizes 1 via Reference: Onnela et al. (2005) Phys Rev E 71:065103. It reduces to 1 in the case of a binary, undirected graph.

3. clustering_coef_bd by Mika Rubinov is the generalization to directed graphs from Reference: Fagiolo (2007) Phys Rev E 76:026107. It reduces to 1 in the case of an undirected graph.

4. clustering_coef_wd by Mika Rubinov extends 3 to weighted graphs. Reference is the same and 4 reduces to 3 when weights are binary. In other words, disregarding perfomance, this implementation subsumes the previous 3.

5. clustering_coef_wu_sign by Jeff Spielberg extends 2 to signed, weighted, undirected graphs in 3 different ways.
..a. Onnela et al. formula, used in 2 but computed separately for positive & negative weights.
..b. Zhang & Horvath formula, similar to Onnela formula except denominator of Onnela formula relies on binarizing the network whereas this denominator is based on weight value. Also computed separately for + and - weights.
..c. Constantini & Perugini's generalization of the Zhang & Horvath formula. This formula takes both positive & negative weights into account simultaneously. It reduces to 2 for positive.

Definition of triangle.  By definition, triangles in a directed graph need not be unidirectional. E.g., u->v->w<-u is a valid triangle. Thus there are potentially 8 triangles for every 3 vertices, u, v, w. In an undirected graph there is just 1 for every 3 vertices.

=#

import Graphs

""" clustering_coefficient{G <: Graphs.GenericGraph}(g::G)

Returns an array of clustering coefficients, one per vertex of `g`. Implements the same functionality as the Matlab routine `clustering_coeff_wd` by Mike Rubinov. Applies to directed or undirected graphs, using weights of 1 for each edge.

"""
function clustering_coefficient{G <: Graphs.GenericGraph}(g::G)
    W = Graphs.weight_matrix(g, fill(1,Graphs.num_edges(g)));
    return ccoef_common(g,W);
end

""" clustering_coefficient{G <: Graphs.GenericGraph}(g::G, key::AbstractString)

When called with `key`, it uses that keyword to look up weights as edge attributes. Weights must be between 0.0 and 1.0 for a valid result.

"""
function clustering_coefficient{G <: Graphs.GenericGraph}(g::G, key::AbstractString)
    if !has_edge_attribute(g, key)
        error("Graph has no edge attribute named, ", key);
    end
    W = Graphs.weight_matrix(g, map((edge)->edge.attributes["weight"], g.edges)).^(1/3);
    if !all(0.0 .<= W .<=1.0)
        warn("Not all weights are between 0 and 1");
    end
    return ccoef_common(g,W);
end

""" clustering_coefficient{G <: Graphs.GenericGraph}(g::G, key::AbstractString, option_for_signed::AbstractString)

Generalizations for signed weights are unimplemented.
    
"""
function clustering_coefficient{G <: Graphs.GenericGraph}(g::G, key::AbstractString, option_for_signed::AbstractString)
    error("unimplemented");
end

function ccoef_common{G <: Graphs.GenericGraph, T <: Real}(g::G, W::Array{T,2})
    # total degree, in + out
    K = map((v) -> Graphs.in_degree(v,g) + Graphs.out_degree(v,g), g.vertices);
    # 2 cycles
    c2 =map((v) -> length(intersect(Graphs.in_neighbors(v,g),
                                    Graphs.out_neighbors(v,g))), g.vertices);
    # number of possible triangles
    c3 = K.*(K-1) - 2*c2;
    # clustering coefficient
    cc = diag((W+W')^3)./c3./2;
    # replace NaN's and Inf's by 0.0's for consistency with Matlab
    cc[!isfinite(cc)] = 0.0;
    return cc;
end

function community_louvain_B(W::Array{Float64,2}, objective_type::AbstractString, gamma::Real=1.0, B0::Array{Float64,2})
    s = sum(W);
    if startswith(objective_type, "mod")
    elseif startswith(objective_type,"pot")
    elseif endswith(objective_type, "asym")
    elseif endswith(objective_type, "sym")
    else
        error("!");
    end
end
#=        case 'modularity';      B = (W-gamma*(sum(W,2)*sum(W,1))/s)/s;
        case 'potts';           B =  W-gamma*(~W);
        case 'negative_sym';    B = B0/(s0+s1) - B1/(s0+s1);
        case 'negative_asym';   B = B0/s0      - B1/(s0+s1);
=#
