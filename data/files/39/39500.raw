#=
    Generate CACodes for GPS by emulating the shift register specification:
	
	IS-GPS-200G.pdf (5-Sept-2012)

	3.2.1.3 C/A-Code. The PRN C/A-Code for SV ID number i is a Gold code, G i (t), of 1
		millisecond in length at a chipping rate of 1023 Kbps. The G i (t) sequence is a linear pattern
		generated by the modulo-2 addition of two sub-sequences, G1 and G2 i , each of which is a 1023
		chip long linear pattern. The epochs of the Gold code are synchronized with the X1 epochs of
		the P-code. As shown in Table 3-Ia, the G2 i sequence is a G2 sequence selectively delayed by
		pre-assigned number of chips, thereby generating a set of different C/A-codes. Assignment of
		these by GPS PRN signal number are given in Table 3-Ia and Table 3-Ib.
		An initial almanac collected from C/A Code in the upper PRNs must be obtained from PRNs 35,
		36, or 38 through 63.
		CS will prevent the simultaneous transmission of PRNs 34 and 37 of C/A code.
	3.2.1.3.1 Expanded C/A Code (GPS III). An expanded set of 26 C/A-code PRN sequences


	3.3.2.3 C/A-Code Generation. Each G i (t) sequence is a 1023-bit Gold-code which is itself the
		modulo-2 sum of two 1023-bit linear patterns, G1 and G2 i . The G2 i sequence is formed by
		effectively delaying the G2 sequence by an integer number of chips. The G1 and G2 sequences
		are generated by 10-stage shift registers having the following polynomials as referred to in the
		shift register input (see Figures 3-8 and 3-9).

		G1 = X 10 + X 3 + 1, and
		G2 = X 10 + X 9 + X 8 + X 6 + X 3 + X 2 + 1.

		The initialization vector for the G1 and G2 sequences is 1111111111. The G1 and G2 shift
		registers are initialized at the P-coder X1 epoch. The G1 and G2 registers are clocked at 1.023
		MHz derived from the 10.23 MHz P-coder clock. The initialization by the X1 epoch phases the
		1.023 MHz clock to insure that the first chip of the C/A code begins at the same time as the first
		chip of the P-code.
		The effective delay of the G2 sequence to form the G2 i sequence may be accomplished by
		combining the output of two stages of the G2 shift register by modulo-2 addition (see Figure 3-
		10). However, this two-tap coder implementation generates only a limited set of valid C/A
		codes. Table 3-I contains a tabulation of the G2 shift register taps selected and their
		corresponding P-code X2 i and PRN signal numbers together with the first several chips of each
		resultant PRN code. Timing relationships related to the C/A code are shown in Figure 3-11.
=#

module gps_cacode

# published types and methods
export cacode
export cacode_word
export gx_mls
export base_two_reg_to_num
#=
  G2 shift register delay for each PRN is specified in IS-GPS-200.

  1023 is the 1st bit to shift out, so to delay we need to subtract from 
  that index
=#

# Use a dictionary to look up advance indices 
svdelay = {
	  1=>1023 -   5,
	  2=>1023 -   6,
	  3=>1023 -   7,
	  4=>1023 -   8,
	  5=>1023 -  17,
	  6=>1023 -  18,
	  7=>1023 - 139,
	  8=>1023 - 140,
	  9=>1023 - 141,
	 10=>1023 - 251,
	 11=>1023 - 252,
	 12=>1023 - 254,
	 13=>1023 - 255,
	 14=>1023 - 256,
	 15=>1023 - 257,
	 16=>1023 - 258,
	 17=>1023 - 469,
	 18=>1023 - 470,
	 19=>1023 - 471,
	 20=>1023 - 472,
	 21=>1023 - 473,
	 22=>1023 - 474,
	 23=>1023 - 509,
	 24=>1023 - 512,
	 25=>1023 - 513,
	 26=>1023 - 514,
	 27=>1023 - 515,
	 28=>1023 - 516,
	 29=>1023 - 859,
	 30=>1023 - 860,
	 31=>1023 - 861,
	 32=>1023 - 862,    #  PRN
	 65=>1023 - 863,    # 33
	 66=>1023 - 950,    # 34
	 67=>1023 - 947,    # 35
	 68=>1023 - 948,    # 36
	 69=>1023 - 950     # 37
}

# Precompute the undelayed MLS for one chip
# Index into this with delays 
mls_chips = [
 (1,1),(1,1),(1,1),(1,1),(1,1),(1,1),(1,1),(1,1),(1,1),(1,1),
 (0,0),(0,0),(0,1),(1,0),(1,1),(1,1),(0,0),(0,1),(0,0),(1,0),
 (0,1),(0,0),(1,1),(1,0),(1,1),(0,1),(1,1),(1,1),(0,0),(0,1),
 (1,0),(0,1),(1,0),(0,0),(1,0),(1,0),(1,0),(0,1),(1,1),(1,1),
 (1,1),(1,1),(0,0),(1,1),(0,0),(1,1),(0,0),(0,1),(0,0),(1,1),
 (1,1),(1,0),(1,1),(0,0),(1,0),(0,0),(0,0),(1,0),(0,1),(1,0),
 (0,1),(1,0),(0,0),(0,1),(0,1),(0,1),(0,0),(1,1),(0,1),(1,1),
 (1,0),(1,0),(1,1),(1,0),(1,0),(1,0),(1,0),(0,1),(1,1),(0,0),
 (1,1),(0,0),(1,0),(0,0),(1,1),(0,1),(1,0),(1,0),(1,1),(1,1),
 (0,1),(1,1),(0,1),(0,0),(0,1),(0,1),(1,1),(1,1),(1,0),(0,1),
 (1,1),(0,0),(0,1),(1,0),(0,0),(0,1),(0,1),(1,1),(1,1),(0,0),
 (0,0),(1,1),(0,0),(1,1),(1,0),(0,0),(1,0),(0,1),(1,1),(1,1),
 (0,1),(0,0),(1,1),(1,1),(1,0),(1,0),(0,0),(1,1),(0,0),(1,0),
 (1,1),(0,0),(0,1),(0,1),(1,1),(1,1),(0,0),(0,1),(1,1),(1,1),
 (1,1),(1,1),(1,1),(1,0),(0,1),(0,0),(1,0),(0,1),(1,0),(0,0),
 (1,1),(0,0),(1,1),(0,1),(0,0),(1,1),(1,1),(0,0),(0,0),(1,1),
 (1,0),(0,0),(0,0),(1,0),(0,0),(1,1),(0,1),(0,0),(1,1),(1,0),
 (1,1),(1,0),(1,0),(0,0),(1,1),(0,0),(0,0),(1,0),(1,0),(1,1),
 (0,0),(0,1),(0,0),(0,0),(1,0),(0,1),(0,0),(0,1),(1,0),(1,1),
 (0,0),(1,1),(1,1),(0,1),(0,1),(1,1),(0,1),(0,1),(0,0),(1,1),
 (0,0),(1,1),(0,1),(0,1),(1,1),(1,0),(0,0),(1,0),(1,0),(1,1),
 (1,1),(0,0),(1,1),(1,1),(1,0),(0,1),(1,0),(0,0),(1,0),(0,1),
 (1,0),(1,0),(1,1),(0,0),(0,0),(1,1),(1,0),(0,0),(0,1),(1,1),
 (1,0),(1,0),(0,0),(1,1),(1,0),(1,1),(0,0),(1,1),(1,1),(1,1),
 (0,0),(0,0),(1,0),(1,1),(1,0),(0,0),(1,1),(0,1),(1,1),(0,0),
 (0,0),(1,0),(1,0),(1,0),(0,0),(1,0),(0,1),(0,0),(0,0),(0,1),
 (0,0),(1,1),(1,0),(1,1),(1,0),(0,1),(1,0),(1,1),(0,0),(1,0),
 (1,0),(1,1),(0,1),(0,0),(0,1),(0,1),(1,0),(1,0),(0,0),(0,1),
 (0,1),(1,0),(0,0),(0,1),(1,0),(0,1),(1,0),(0,0),(0,1),(1,1),
 (0,0),(1,0),(1,0),(0,0),(0,0),(1,0),(1,1),(0,0),(1,1),(0,0),
 (0,1),(0,1),(1,0),(0,0),(0,1),(0,1),(1,0),(0,0),(1,1),(1,0),
 (0,0),(1,1),(0,1),(0,1),(1,1),(0,1),(1,1),(1,0),(1,0),(0,1),
 (1,1),(0,1),(0,0),(1,1),(1,0),(0,0),(0,1),(0,0),(1,1),(0,1),
 (1,1),(1,0),(0,0),(0,0),(0,0),(0,0),(0,1),(0,0),(1,0),(0,1),
 (1,1),(0,1),(0,1),(1,0),(0,1),(0,1),(1,1),(0,0),(1,1),(1,0),
 (1,1),(1,0),(1,0),(0,1),(1,0),(1,1),(1,0),(1,0),(0,1),(0,0),
 (0,0),(1,1),(1,1),(0,1),(0,0),(0,1),(1,0),(1,1),(0,1),(1,1),
 (1,0),(1,0),(0,1),(1,1),(1,1),(0,1),(0,0),(0,1),(0,0),(1,1),
 (1,1),(1,0),(1,1),(0,1),(0,1),(1,1),(0,0),(0,0),(1,0),(1,1),
 (1,1),(0,0),(0,1),(1,0),(0,1),(1,1),(1,0),(0,1),(0,0),(0,1),
 (1,0),(0,1),(0,1),(0,0),(0,0),(1,0),(1,1),(0,1),(1,1),(1,0),
 (1,0),(1,1),(1,0),(1,0),(1,1),(0,0),(0,0),(1,0),(1,1),(1,1),
 (0,1),(0,1),(0,1),(1,1),(1,0),(0,1),(1,1),(0,0),(1,0),(0,1),
 (0,1),(1,1),(0,1),(1,0),(0,0),(0,0),(0,0),(0,0),(1,1),(0,1),
 (0,0),(0,0),(0,0),(1,0),(0,1),(0,1),(1,0),(0,0),(1,1),(1,1),
 (0,0),(1,1),(1,0),(1,1),(1,0),(1,1),(0,0),(1,0),(0,1),(1,1),
 (1,0),(1,1),(0,0),(0,1),(0,1),(1,1),(0,1),(1,1),(1,0),(1,1),
 (0,1),(0,0),(1,1),(0,1),(0,0),(0,0),(0,0),(1,0),(1,1),(1,1),
 (1,1),(1,0),(0,0),(1,0),(1,1),(0,1),(1,1),(0,0),(1,1),(0,1),
 (1,1),(0,1),(0,0),(0,0),(1,1),(0,1),(1,0),(1,1),(1,0),(1,0),
 (0,0),(1,0),(1,1),(0,1),(0,1),(1,0),(1,1),(1,0),(0,0),(0,0),
 (1,0),(1,0),(1,0),(1,0),(1,0),(0,1),(0,1),(0,1),(0,0),(0,0),
 (1,1),(1,1),(1,0),(0,0),(0,1),(1,1),(0,0),(0,0),(1,0),(0,0),
 (1,1),(0,0),(1,0),(1,1),(0,0),(0,0),(1,0),(0,0),(1,1),(1,0),
 (1,0),(1,0),(0,1),(0,1),(1,0),(0,0),(1,0),(1,1),(1,0),(0,0),
 (0,0),(0,0),(0,0),(0,0),(1,0),(0,1),(1,1),(0,0),(1,0),(1,1),
 (0,0),(1,0),(1,0),(0,1),(0,0),(1,0),(1,0),(0,1),(0,1),(0,1),
 (0,0),(1,1),(1,0),(0,1),(1,0),(0,1),(1,1),(1,1),(0,0),(1,1),
 (1,0),(1,0),(0,1),(1,1),(0,1),(0,0),(0,0),(1,1),(0,0),(1,1),
 (0,1),(1,1),(1,1),(1,1),(1,1),(1,0),(1,0),(0,0),(1,1),(0,0),
 (0,1),(0,0),(1,0),(1,1),(1,0),(0,1),(0,1),(1,0),(1,0),(0,1),
 (1,1),(1,1),(1,0),(0,0),(0,1),(1,1),(0,1),(1,0),(0,0),(0,0),
 (0,1),(1,0),(1,1),(0,1),(1,0),(0,0),(0,1),(0,0),(0,1),(0,1),
 (0,1),(1,0),(1,1),(0,0),(0,1),(1,1),(0,0),(0,0),(1,1),(0,0),
 (0,0),(0,1),(1,0),(0,1),(0,0),(0,0),(0,0),(0,0),(1,1),(0,0),
 (0,0),(1,1),(1,1),(0,0),(1,1),(1,1),(0,0),(1,0),(0,1),(0,1),
 (1,0),(1,1),(1,1),(1,1),(0,1),(0,0),(1,1),(1,0),(0,0),(1,0),
 (0,1),(1,1),(0,1),(1,0),(1,0),(0,0),(0,0),(0,1),(0,0),(1,1),
 (0,0),(1,1),(1,0),(1,0),(0,1),(1,0),(1,0),(0,0),(1,1),(0,0),
 (0,1),(0,0),(1,0),(1,0),(0,0),(0,0),(0,0),(0,1),(1,0),(0,0),
 (0,0),(1,0),(1,0),(1,1),(1,0),(1,0),(1,0),(1,1),(0,0),(1,0),
 (1,1),(1,1),(0,0),(0,0),(0,1),(1,1),(1,1),(1,0),(1,1),(0,1),
 (0,0),(0,0),(0,1),(0,0),(0,1),(1,0),(1,1),(1,1),(0,0),(1,1),
 (1,1),(0,0),(1,1),(1,1),(0,1),(0,1),(0,1),(1,0),(0,1),(1,0),
 (0,0),(0,0),(0,0),(1,1),(0,0),(0,1),(1,1),(1,0),(0,1),(0,0),
 (1,1),(0,1),(0,1),(0,0),(0,1),(0,1),(1,0),(1,0),(0,0),(1,0),
 (0,0),(0,1),(1,0),(0,1),(0,1),(1,0),(1,0),(1,0),(1,0),(0,0),
 (1,0),(1,0),(1,0),(1,0),(1,1),(0,0),(0,1),(0,1),(1,1),(0,0),
 (1,1),(0,1),(1,1),(0,0),(1,1),(1,1),(0,1),(1,1),(0,1),(0,0),
 (0,0),(0,0),(1,1),(0,1),(1,1),(0,1),(0,1),(0,0),(0,0),(0,0),
 (0,0),(0,1),(1,0),(0,0),(1,0),(1,0),(0,1),(1,1),(1,1),(0,1),
 (1,1),(1,1),(1,1),(1,1),(0,0),(0,1),(1,1),(1,1),(1,0),(1,0),
 (0,0),(0,0),(0,1),(1,1),(0,1),(0,1),(0,0),(1,1),(1,0),(1,0),
 (1,1),(1,1),(1,0),(0,0),(1,1),(1,0),(0,1),(0,1),(0,0),(1,0),
 (1,0),(1,1),(0,0),(1,1),(0,1),(1,1),(1,0),(0,0),(1,1),(0,0),
 (1,1),(0,0),(0,1),(0,0),(0,0),(1,0),(1,0),(0,1),(0,1),(1,0),
 (1,0),(0,0),(1,1),(1,1),(0,0),(0,1),(0,1),(0,1),(0,0),(1,1),
 (1,0),(0,0),(0,0),(0,1),(0,0),(0,1),(0,1),(0,1),(0,1),(1,0),
 (1,0),(0,1),(1,0),(1,0),(0,0),(1,1),(1,1),(0,0),(1,1),(0,0),
 (1,0),(1,1),(1,1),(0,0),(1,1),(0,1),(1,1),(1,0),(1,0),(1,0),
 (0,1),(0,1),(0,0),(0,0),(1,0),(0,0),(1,0),(0,1),(1,1),(0,1),
 (0,0),(1,1),(0,1),(0,0),(0,1),(0,1),(1,1),(0,0),(1,1),(1,1),
 (0,0),(0,1),(1,0),(0,1),(0,1),(1,0),(1,0),(0,0),(0,0),(0,1),
 (0,0),(0,1),(1,1),(0,1),(0,1),(0,1),(1,0),(0,0),(0,1),(1,1),
 (0,0),(0,0),(0,0),(0,1),(0,1),(0,1),(1,1),(0,0),(0,0),(0,1),
 (0,1),(0,1),(0,1),(0,1),(0,1),(0,1),(1,0),(0,0),(0,0),(1,0),
 (0,0),(0,0),(1,1),(0,1),(0,1),(1,1),(1,0),(0,0),(1,0),(0,1),
 (0,0),(1,0),(1,0),(0,1),(1,0),(0,1),(1,1),(1,0),(1,1),(1,1),
 (1,1),(0,0),(0,0),(1,1),(1,1),(0,0),(0,1),(0,1),(1,0),(1,1),
 (1,1),(1,0),(1,1),(0,0),(0,1),(1,0),(0,0),(0,1),(0,1),(1,1),
 (1,1),(1,1),(0,0),(1,0),(1,1),(1,0),(1,0),(1,1),(1,1),(0,0),
 (0,1),(0,0),(0,0),(1,1),(1,0),(1,0),(0,0),(0,0),(0,0),(0,0),
 (0,1),(0,1),(0,0)]

type CA_MLS
	G1::Uint8
	G2::Uint8
end

# \todo There must be a better way to make an array of composite types in Julia....
ca_mls_chips = [CA_MLS(i[1],i[2]) for i in mls_chips]

# Use bigints to explore what the CACODE looks like and to test
function base_two_reg_to_num(arr)
	#=
	  arr:    array representing a number
	  return: Arbitrary precision integer
	=#
	n      = BigInt(0)
	bigtwo = BigInt(2)
	up     = 1:length(arr)
	down   = reverse(up)
	tups   = zip(up, down)
	for i in tups
	    n = n + arr[i[2]] * (bigtwo^(i[1]-1))	
	end
	return n
end

function shift_reg(reg, feedback, taps)
	#=
	reg:             Array representing a register, initialization is done outside this function 
	feedback:        The bits to modulo 2 feedback to the register low bit
	taps:            The output is composed of the modulo 2 sum of these bits

	returns a tuple: (out, reg, mls)
	out is the delayed output of LFSR
	reg is the new register state
	mls is the output of the maximum-length sequence
	=#

	# Check for valid inputs
	@assert(length(reg)>0,      "Reg is zero length")
	@assert(length(feedback)>0, "No Feedback selected")
	@assert(length(taps)>0,     "No taps selected")

	try
		# Calculate the output
		out = [reg[i] for i in taps]
		if length(out) > 1
			out = sum(out) % 2
		else
			out = out[1]
		end

		# Feedback
		fb = sum([reg[i] for i in feedback]) %2

		# This will be the output bit of the mls
		mls = reg[10]

		# put the fb at the beginning of the reg
		unshift!(reg,fb)

		# remove the last element of the reg (which is length==11 now due to the unshift!)
		pop!(reg)

		return (out, reg, mls)
	catch
		x
	end
end

function gx_mls(reg, feedback, chips)
	#=
	reg:             Array representing a register 
	feedback:        modulo2 feedback taps

	Generate the MLS (Maximum-Length Shift) for a register reg of length(reg)
		This is the 'undelayed' output of a LFSR with feedback taps feedback
	=#

	gx     = ones(Uint8, chips)
	mls    = zeros(Uint8, chips)
	for i = 1:chips
		(X, gx, mls[i]) = shift_reg(gx, feedback, [10])
	end
	return mls
end
 
function cacode(chip, sv)
	g2chip = chip + svdelay[sv]

	if(g2chip > 1023)
		g2chip -= 1023
	end
	return ca_mls_chips[chip].G1 $ ca_mls_chips[g2chip].G2
end
 
function cacode_word(sv)
	cacode_w = zeros(Uint8, 1023)
	for i = 1:1023
		cacode_w[i] = cacode(i,sv)
	end
	return cacode_w
end

end

