module KMeansJulia

using Images
using Colors
using FixedPointNumbers

# Run non-interactively, accept either an image or a directory
# If directory, iterate through image filetypes
# Note that older versions of ImageMagick have both a critical vulnerabilities and slower support for multiple large .tiff files

# Enter filepath and number of dominant colors wanted, k.
function dominant_colors(filename, k)
	if isfile(filename)
		image = load(filename)
		init(image, filename, k)
	elseif isdir(filename)
		files = filter!(abspath(r"\.(?:jpe?g|gif|png|tiff)$")), readdir()) #creates an array of filenames by filtering out only files that in file extensions.
		for i in files
			dominant_colors(i, k)
		end
	else
		error("No image found.")
	end
end

type Cluster
	points::Array{Array{Float32,1},1} # Points associated with cluster, C_k.
	centroid::Point # Center of cluster, assumed mean of pt values
	k::Int # Cluster count
end

function init(image, filename, k::Integer)
	# run(`convert $filename -thumbnail 200x200 $filename`) # convert to thumbnail via ImageMagick CLI
	imagec = convert(Image{LAB}, float32(image)) # convert from sRGB to L*A*B* colorspace
	raw_image = raw(imagec) # Image Array of Lab{Float32}. 1st field encodes luminance, color the last two. See ColorTypes.jl for more info
	width = size(raw_image,1)
	height = size(raw_image, 2)
	points = getpoints(raw_image, width, height)
	initialclusters(points, width*height, k)
	kmeans(points, k)
end

function getpoints(raw_image::Array, width::Integer, height::Integer)
	points = Array{Float32}[]
	for m=1:width, n=1:height
		 push!(points, [raw_image[m,n].a, raw_image[m,n].b]) # Adds color information a*b* of each pixel to an array
	end
	return points
end

# Sq. euclidean (2 norm) distance
function distance(pt1::AbstractArray, pt2::AbstractArray)
	return sum((abs2(pt1-pt2))
end

# Pick initial centroids using Bahmani et. al. Scalable k-means++ method
function initialclusters(points::Array, totalpoints::Integer, k::Integer)
	pointspercluster = (totalpoints)/k
	centroids = Array{Float32}[]
	push!(centroids, rand(points))
	psi =

function min_distance(points::Array, centroids::AbstractArray)
		min_dist = Vector(length(points))
		fill!(min_dist, 0)
		for p in points
			for c in centroids
				dist = []
				push(dist, distance(points[p],centroids[c]))
			 	min_dist[p] > dist[p] &&  min_dist[p] = dist[p]
			end
		end 	

#function randclusters(points::Array, k::Int)
#	kclusters = []
#	for n = 1:k
#		kclusters.append(Cluster(points, points[rand(1:end)], n))
#	return kclusters
#end
#

# Alternatively pick a random point, then perform first centroid calculation

# Recalculate Centroid
function center(cluster)
	centroid = []
	points = cluster.points
	for n = 1:length(points)
		points.coords[n]


# K-Means Algorithm (alternate between resigning points to a cluster based on similarity and cluster centroid based on the points assigned)
function kmeans()

# Repeat n number of times

# Convert returned clusters back to sRGB
