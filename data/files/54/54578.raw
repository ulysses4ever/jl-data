module KMeansJulia

using DataFrames
using Images
using Colors
using FixedPointNumbers

# Run non-interactively, accept either an image or a directory
# If directory, iterate through image filetypes
# Note that older versions of ImageMagick have both a critical vulnerabilities and slower support for multiple large .tiff files

# Enter filepath and number of dominant colors wanted, k.
function dominant_colors(filename, k)
	if isfile(filename)
		image = load(filename)
		init(image, filename, k)
	elseif isdir(filename)
		files = filter!(abspath(r"\.(?:jpe?g|gif|png|tiff)$")), readdir()) #creates an array of filenames by filtering out only files that in file extensions.
		for i in files
			dominant_colors(i, k)
		end
	else
		error("No image found.")
	end
end

immutable Pixel
	coords::Vector{AbstractFloat}
	id::Integer

	Pixel() = new([],0)
end

immutable Cluster
	pixels::Vector{Pixel} # pixels associated with cluster, C_k.
	centroid::Pixel # Center of cluster, assumed mean of px values
	k::Integer # Cluster count

	Cluster() = new(Vector{Pixel}(),Pixel(),0)
end

function init(image, filename, k::Integer)
	# run(`convert $filename -thumbnail 200x200 $filename`) # convert to thumbnail via ImageMagick CLI
	imagec = convert(Image{LAB}, float32(image)) # convert from sRGB to L*A*B* colorspace
	raw_image = raw(imagec) # Image Array of Lab{Float32}. 1st field encodes luminance, color the last two. See ColorTypes.jl for more info
	width = size(raw_image,1)
	height = size(raw_image, 2)
	pixels = getpixels(raw_image, width, height)
	initialclusters(pixels, width*height, k)
	kmeans(pixels, k)
end

function getpixels(raw_image::Array, width::Integer, height::Integer)
	pixels = Vector{Pixel}()
	count = 0
 	for m=1:height, n=1:width
			@inbounds newpixel = Pixel()
		  push!(newpixel.coords, raw_image[m,n].a, raw_image[m,n].b) # Adds color information a*b* of each pixel to an array
			count += 1
			newpixel.id = count
			push!(pixels, newpixel)
	end
	return pixels
end

# Sq. euclidean (2 norm) distance
function distance(px1::AbstractArray, px2::AbstractArray)
	return sum((abs2(px1-px2))
end

# Pick initial centroids using Bahmani et. al. Scalable k-means++ (kmeans||) method with l=2k, r=8
function initialclusters(pixels::Array, totalpixels::Integer, k::Integer)
	x_c = (totalpixels)/k # pixels per cluster
	centroids = Vector{Pixel}()
	clusters = Vector{Cluster}()
	push!(centroids, rand(pixels))
	phi = min_distance(pixels, clusters, centroids)
	psi = log(sum(sum(values(phi))) # log of psi, initial cost of clustering
	for psi

function min_distance(pixels::AbstractArray, clusters::AbstractArray, centroids::AbstractArray)
	min_dist = Vector{Integer}()
	phi = Dict{Integer,Vector{Integer}}() # distances from pixel x, to the closest centroid, C
	if isempty(clusters) # for kmeans|| initilization
		for (cluster, c) in enumerate(centroids), (px, p) in enumerate(pixels)
			@inbounds dist = []
			push!(dist, distance(pixels[p].coords,centroids[c].coords))
			#isempty(min_dist) ? min_dist = dist : (min_dist[px] > dist[px] &&  min_dist[px] = dist[px])
			if isempty(min_dist)
				min_dist = dist
			end
			else
				 min_dist[px] > dist[px] &&  min_dist[px] = dist[px]
			end
			phi[cluster] = min_dist
		end
		return phi
	end
	else
		break # TODO implement portion of this function to apply to Lloyd's algorithm
	end
end 	


# Recalculate Centroid
function center(cluster)
	centroid = []
	pixels = cluster.pixels
	for n = 1:length(pixels)
		pixels.coords[n]


# K-Means Algorithm (alternate between resigning pixels to a cluster based on similarity and cluster centroid based on the pixels assigned)
function kmeans()

# Repeat n number of times

# Convert returned clusters back to sRGB
