# Controls whether tuples and non-pointerfree immutables, which Julia
# stores as references, are stored inline in compound types when
# possible. Currently this is problematic because Julia fields of these
# types may be undefined.
const INLINE_TUPLE = false
const INLINE_POINTER_IMMUTABLE = false

const JLD_REF_TYPE = JldDatatype(HDF5Datatype(HDF5.H5T_STD_REF_OBJ, false), 0)
const BUILTIN_TYPES = Set([Symbol, Type, UTF16String])

# Holds information about the mapping between a Julia and HDF5 type
immutable JldTypeInfo
    dtypes::Vector{JldDatatype}
    offsets::Vector{Int}
    size::Int
end

# Get information about the HDF5 type corresponding to a Julia type
function JldTypeInfo(parent::JldFile, types::(Type...), commit::Bool)
    dtypes = Array(JldDatatype, length(types))
    offsets = Array(Int, length(types))
    offset = 0
    for i = 1:length(types)
        dtype = dtypes[i] = h5fieldtype(parent, types[i], commit)
        offsets[i] = offset
        offset += HDF5.h5t_get_size(dtype)
    end
    JldTypeInfo(dtypes, offsets, offset)
end
JldTypeInfo(parent::JldFile, T::ANY, commit::Bool) =
    JldTypeInfo(parent, T.types, commit)

## h5convert! converts data from Julia to HDF5, and jlconvert converts
## data from HDF5 to Julia. Most methods are dynamically generated by
## gen_jlconvert/gen_h5convert below, but these (for special built-in
## types) are predefined.
##
## To create a special serialization of a datatype, one should:
##
## - Define h5convert! and jlconvert
## - If the type is an immutable, define jlconvert!
## - Add the type to BUILTIN_TYPES
## - Define a no-op method for gen_h5convert
## - Define a method of h5type that constructs the type in the file
## - Define a method of h5fieldtype that dispatches to h5type

# Definitions for basic types

# HDF5 bits kinds
h5convert!{T<:HDF5.HDF5BitsKind}(out::Ptr, ::JldFile, x::T, ::JldWriteSession) =
    unsafe_store!(convert(Ptr{T}, out), x)

_jlconvert_bits{T}(::Type{T}, ptr::Ptr) = unsafe_load(convert(Ptr{T}, ptr))
_jlconvert_bits!{T}(out::Ptr, ::Type{T}, ptr::Ptr) =
    (unsafe_store!(convert(Ptr{T}, out), unsafe_load(convert(Ptr{T}, ptr))); nothing)

jlconvert{T<:HDF5.HDF5BitsKind}(::Type{T}, ::JldFile, ptr::Ptr) = _jlconvert_bits(T, ptr)
jlconvert!{T<:HDF5.HDF5BitsKind}(out::Ptr, ::Type{T}, ::JldFile, ptr::Ptr) = _jlconvert_bits!(out, T, ptr)

# ByteStrings
h5convert!(out::Ptr, ::JldFile, x::ByteString, ::JldWriteSession) =
    unsafe_store!(convert(Ptr{Ptr{Uint8}}, out), pointer(x))
function jlconvert{T<:ByteString}(::Type{T}, ::JldFile, ptr::Ptr)
    strptr = unsafe_load(convert(Ptr{Ptr{Uint8}}, ptr))
    n = int(ccall(:strlen, Csize_t, (Ptr{Uint8},), strptr))
    T(pointer_to_array(strptr, (n,), true))
end

# UTF16Strings
h5convert!(out::Ptr, ::JldFile, x::UTF16String, ::JldWriteSession) =
    unsafe_store!(convert(Ptr{HDF5.Hvl_t}, out), HDF5.Hvl_t(length(x.data), pointer(x.data)))
function jlconvert(::Type{UTF16String}, ::JldFile, ptr::Ptr)
    hvl = unsafe_load(convert(Ptr{HDF5.Hvl_t}, ptr))
    UTF16String(pointer_to_array(convert(Ptr{Uint16}, hvl.p), hvl.len, true))
end

# Symbols
function h5convert!(out::Ptr, file::JldFile, x::Symbol, wsession::JldWriteSession)
    str = string(x)
    push!(wsession.persist, str)
    h5convert!(out, file, str, wsession)
end
jlconvert(::Type{Symbol}, file::JldFile, ptr::Ptr) = symbol(jlconvert(UTF8String, file, ptr))

# Types
function h5convert!(out::Ptr, file::JldFile, x::Type, wsession::JldWriteSession)
    str = full_typename(file, x)
    push!(wsession.persist, str)
    h5convert!(out, file, str, wsession)
end
jlconvert(::Type{Type}, file::JldFile, ptr::Ptr) = julia_type(jlconvert(UTF8String, file, ptr))

## Get corresponding HDF5Datatype for a specific type

# HDF5BitsKinds are also HDF5BitsKind
h5fieldtype{T<:HDF5.HDF5BitsKind}(::JldFile, ::Type{T}, ::Bool) =
    JldDatatype(HDF5Datatype(HDF5.hdf5_type_id(T), false), 0)

# ByteString types are variable length strings
function h5fieldtype{T<:ByteString}(::JldFile, ::Type{T}, ::Bool)
    type_id = HDF5.h5t_copy(HDF5.hdf5_type_id(T))
    HDF5.h5t_set_size(type_id, HDF5.H5T_VARIABLE)
    HDF5.h5t_set_cset(type_id, HDF5.cset(T))
    JldDatatype(HDF5Datatype(type_id, false), 0)
end

# UTF16Strings are stored as compound types that contain a vlen
h5fieldtype(parent::JldFile, ::Type{UTF16String}, commit::Bool) =
    h5type(parent, UTF16String, commit)

# Symbols and types are stored as compound types that contain a
# variable length string
h5fieldtype(parent::JldFile, ::Type{Symbol}, commit::Bool) =
    h5type(parent, Symbol, commit)
h5fieldtype{T<:Type}(parent::JldFile, ::Type{T}, commit::Bool) =
    h5type(parent, Type, commit)

# Arrays are references
# These show up as having T.size == 0, hence the need for specialization
h5fieldtype{T,N}(parent::JldFile, ::Type{Array{T,N}}, ::Bool) = JLD_REF_TYPE

if INLINE_TUPLE
    h5fieldtype(parent::JldFile, T::(Type...), commit::Bool) =
        isleaftype(T) ? h5type(parent, T, commit) : JLD_REF_TYPE
    h5fieldtype(parent::JldFile, T::Tuple, commit::Bool) =
        isleaftype(T) ? h5type(parent, T, commit) : JLD_REF_TYPE
else
    h5fieldtype(parent::JldFile, T::(Type...), ::Bool) = JLD_REF_TYPE
    h5fieldtype(parent::JldFile, T::Tuple, ::Bool) = JLD_REF_TYPE
end

# For cases not defined above: If the type is mutable and non-empty,
# this is a reference. If the type is immutable, this is a type itself.
if INLINE_POINTER_IMMUTABLE
    h5fieldtype(parent::JldFile, T::ANY, commit::Bool) =
        isleaftype(T) && (!T.mutable || T.size == 0) ? h5type(parent, T, commit) : JLD_REF_TYPE
else
    h5fieldtype(parent::JldFile, T::ANY, commit::Bool) =
        isleaftype(T) && (!T.mutable || T.size == 0) && T.pointerfree ? h5type(parent, T, commit) : JLD_REF_TYPE
end

h5fieldtype(parent::JldGroup, x, commit::Bool) = h5fieldtype(file(parent), x)

# Write an HDF5 datatype to the file
function commit_datatype(parent::JldFile, dtype::HDF5Datatype, T::ANY)
    # Write to HDF5 file
    pparent = parent.plain
    if !exists(pparent, pathtypes)
        gtypes = g_create(pparent, pathtypes)
    else
        gtypes = pparent[pathtypes]
    end

    id = length(gtypes)+1
    try
        HDF5.t_commit(gtypes, @sprintf("%08d", id), dtype)
    finally
        close(gtypes)
    end
    a_write(dtype, name_type_attr, full_typename(parent, T))

    # Store in map
    parent.jlh5type[T] = JldDatatype(dtype, id)
end

# If parent is nothing, we are creating the datatype in memory for
# validation, so don't commit it
commit_datatype(parent::Nothing, dtype::HDF5Datatype, T::ANY) =
    JldDatatype(dtype, -1)

# The HDF5 library loses track of relationships among committed types
# after the file is saved. We mangle the names by appending a
# sequential identifier so that we can recover these relationships
# later.
mangle_name(jtype::JldDatatype, jlname) =
    jtype.index <= 0 ? string(jlname, "_") : string(jlname, "_", jtype.index)
Base.convert(::Type{HDF5.Hid}, x::JldDatatype) = x.dtype.id

## Define h5convert! to convert from Julia to HDF5 representation for
## a given JldTypeInfo and Julia type. Assumes h5datatype has already been
## called for this type.

# For types that have h5convert! predefined
gen_h5convert{T<:HDF5.HDF5BitsKind}(::JldFile, ::Type{T}) = nothing
gen_h5convert{T<:ByteString}(::JldFile, ::Type{T}) = nothing
gen_h5convert{T<:UTF16String}(::JldFile, ::Type{T}) = nothing
gen_h5convert{T<:Symbol}(::JldFile, ::Type{T}) = nothing
gen_h5convert{T<:Type}(::JldFile, ::Type{T}) = nothing

# For other types
const H5CONVERT_DEFINED = ObjectIdDict()
gen_h5convert(parent::JldFile, T) =
    haskey(H5CONVERT_DEFINED, T) || _gen_h5convert(parent, T)

# There is no point in specializing this
function _gen_h5convert(parent::JldFile, T::ANY)
    dtype = parent.jlh5type[T].dtype
    istuple = isa(T, Tuple)
    if istuple
        types = T
    else
        if isopaque(T::DataType)
            if (T::DataType).size == 0
                @eval h5convert!(out::Ptr, ::JldFile, x::$T, ::JldWriteSession) = nothing
            else
                @eval h5convert!(out::Ptr, ::JldFile, x::$T, ::JldWriteSession) =
                    unsafe_store!(convert(Ptr{$T}, out), x)
            end
            return
        end
        types = (T::DataType).types
    end

    getindex_fn = istuple ? (:getindex) : (:getfield)
    ex = Expr(:block)
    args = ex.args
    n = HDF5.h5t_get_nmembers(dtype.id)
    for i = 1:n
        offset = HDF5.h5t_get_member_offset(dtype.id, i-1)
        if HDF5.h5t_get_member_class(dtype.id, i-1) == HDF5.H5T_REFERENCE
            if istuple
                push!(args, :(unsafe_store!(convert(Ptr{HDF5ReferenceObj}, out)+$offset,
                                            write_ref(file, $getindex_fn(x, $i), wsession))))
            else
                push!(args, quote
                    if isdefined(x, $i)
                        ref = write_ref(file, $getindex_fn(x, $i), wsession)
                    else
                        ref = HDF5.HDF5ReferenceObj_NULL
                    end
                    unsafe_store!(convert(Ptr{HDF5ReferenceObj}, out)+$offset, ref)
                end)
            end
        else
            gen_h5convert(parent, types[i])
            push!(args, :(h5convert!(out+$offset, file, $getindex_fn(x, $i), wsession)))
        end
    end
    @eval h5convert!(out::Ptr, file::JldFile, x::$T, wsession::JldWriteSession) = ($ex; nothing)
    H5CONVERT_DEFINED[T] = true
    nothing
end

## Define jlconvert/jlconvert! to convert from HDF5 to Julia
## representation for a given JldTypeInfo and Julia type. The
## mutating version is only available for bits types.

uses_reference(T::DataType) = !T.pointerfree
uses_reference(::Tuple) = true

# Tuples
function gen_jlconvert(typeinfo::JldTypeInfo, T::(Type...))
    method_exists(jlconvert, (Type{T}, JldFile, Ptr)) && return

    ex = Expr(:block)
    args = ex.args
    tup = Expr(:tuple)
    tupargs = tup.args
    for i = 1:length(typeinfo.dtypes)
        h5offset = typeinfo.offsets[i]
        field = symbol(string("field", i))

        if HDF5.h5t_get_class(typeinfo.dtypes[i]) == HDF5.H5T_REFERENCE
            push!(args, :($field = read_ref(file, unsafe_load(convert(Ptr{HDF5ReferenceObj}, ptr)+$h5offset))))
        else
            push!(args, :($field = jlconvert($(T[i]), file, ptr+$h5offset)))
        end
        push!(tupargs, field)
    end
    @eval jlconvert(::Type{$T}, file::JldFile, ptr::Ptr) = ($ex; $tup)
    nothing
end

# Normal objects
function _gen_jlconvert_type(typeinfo::JldTypeInfo, T::ANY)
    ex = Expr(:block)
    args = ex.args
    for i = 1:length(typeinfo.dtypes)
        h5offset = typeinfo.offsets[i]

        if HDF5.h5t_get_class(typeinfo.dtypes[i]) == HDF5.H5T_REFERENCE
            push!(args, quote
                ref = unsafe_load(convert(Ptr{HDF5ReferenceObj}, ptr)+$h5offset)
                if ref != HDF5.HDF5ReferenceObj_NULL
                    out.$(T.names[i]) = read_ref(file, ref)::$(T.types[i])
                end
            end)
        else
            push!(args, :(out.$(T.names[i]) = jlconvert($(T.types[i]), file, ptr+$h5offset)))
        end
    end
    @eval function jlconvert(::Type{$T}, file::JldFile, ptr::Ptr)
        out = ccall(:jl_new_struct_uninit, Any, (Any,), $T)::$T
        $ex
        out
    end
    nothing
end

# Immutables
function _gen_jlconvert_immutable(typeinfo::JldTypeInfo, T::ANY)
    ex = Expr(:block)
    args = ex.args
    jloffsets = fieldoffsets(T)
    for i = 1:length(typeinfo.dtypes)
        h5offset = typeinfo.offsets[i]
        jloffset = jloffsets[i]

        if HDF5.h5t_get_class(typeinfo.dtypes[i]) == HDF5.H5T_REFERENCE
            obj = gensym("obj")
            push!(args, quote
                ref = unsafe_load(convert(Ptr{HDF5ReferenceObj}, ptr)+$h5offset)
                local $obj # must keep alive to prevent collection
                if ref == HDF5.HDF5ReferenceObj_NULL
                    unsafe_store!(convert(Ptr{Int}, out)+$jloffset, 0)
                else
                    # The typeassert ensures that the reference type is
                    # valid for this type
                    $obj = read_ref(file, ref)::$(T.types[i])
                    unsafe_store!(convert(Ptr{Ptr{Void}}, out)+$jloffset, pointer_from_objref($obj))
                end
            end)
        elseif uses_reference(T.types[i])
            # Tuple fields and non-pointerfree immutables are stored
            # inline by JLD if INLINE_TUPLE/INLINE_POINTER_IMMUTABLE is
            # true, but not by Julia
            obj = gensym("obj")
            push!(args, quote
                obj = jlconvert($(T.types[i]), file, ptr+$h5offset)
                unsafe_store!(convert(Ptr{Ptr{Void}}, out)+$jloffset, pointer_from_objref(obj))
            end)
        else
            push!(args, :(jlconvert!(out+$jloffset, $(T.types[i]), file, ptr+$h5offset)))
        end
    end
    @eval begin
        jlconvert!(out::Ptr, ::Type{$T}, file::JldFile, ptr::Ptr) = ($ex; nothing)
        $(
        if T.pointerfree
            quote
                function jlconvert(::Type{$T}, file::JldFile, ptr::Ptr)
                    out = Array($T, 1)
                    jlconvert!(pointer(out), $T, file, ptr)
                    out[1]
                end
            end
        else
            # XXX can this be improved?
            quote
                function jlconvert(::Type{$T}, file::JldFile, ptr::Ptr)
                    out = ccall(:jl_new_struct_uninit, Any, (Any,), $T)::$T
                    jlconvert!(pointer_from_objref(out)+sizeof(Int), $T, file, ptr)
                    out
                end
            end
        end
        )
    end
    nothing
end

# Dispatch for non-tuple types
function gen_jlconvert(typeinfo::JldTypeInfo, T::ANY)
    method_exists(jlconvert, (Type{T}, JldFile, Ptr)) && return

    if isempty(T.names)
        if T.size == 0
            @eval begin
                jlconvert(::Type{$T}, ::JldFile, ::Ptr) = $T()
                jlconvert!(::Ptr, ::Type{$T}, ::JldFile, ::Ptr) = nothing
            end
        else
            @eval begin
               jlconvert(::Type{$T}, ::JldFile, ptr::Ptr) =  _jlconvert_bits($T, ptr)
               jlconvert!(out::Ptr, ::Type{$T}, ::JldFile, ptr::Ptr) =  _jlconvert_bits!(out, $T, ptr)
            end
        end
        nothing
    elseif T.mutable
        _gen_jlconvert_type(typeinfo, T)
    else
        _gen_jlconvert_immutable(typeinfo, T)
    end
end

## Get corresponding JldDatatype for an HDF5 type, committing it if
## requested.

h5type{T<:Ptr}(parent::JldFile, ::Type{T}, ::Bool) = throw(PointerException())

# Construct HDF5 type corresponding to Symbol
function h5type(parent::JldFile, ::Type{Symbol}, commit::Bool)
    haskey(parent.jlh5type, Symbol) && return parent.jlh5type[Symbol]
    id = HDF5.h5t_create(HDF5.H5T_COMPOUND, 8)
    HDF5.h5t_insert(id, "symbol_", 0, h5fieldtype(parent, UTF8String, commit))
    dtype = HDF5Datatype(id, parent.plain)
    commit ? commit_datatype(parent, dtype, Symbol) : JldDatatype(dtype, -1)
end

# Construct HDF5 type corresponding to Type
function h5type(parent::JldFile, ::Type{Type}, commit::Bool)
    haskey(parent.jlh5type, Type) && return parent.jlh5type[Type]
    id = HDF5.h5t_create(HDF5.H5T_COMPOUND, 8)
    HDF5.h5t_insert(id, "typename_", 0, h5fieldtype(parent, UTF8String, commit))
    dtype = HDF5Datatype(id, parent.plain)
    commit ? commit_datatype(parent, dtype, Type) : JldDatatype(dtype, -1)
end
h5type{T}(parent::JldFile, ::Type{Type{T}}, commit::Bool) =
    h5type(parent, Type, commit)

# Construct HDF5 type corresponding to UTF16String
function h5type(parent::JldFile, ::Type{UTF16String}, commit::Bool)
    isa(parent, JldFile) && haskey(parent.jlh5type, UTF16String) && return parent.jlh5type[UTF16String]
    vlen = HDF5.h5t_vlen_create(HDF5.H5T_NATIVE_UINT16)
    id = HDF5.h5t_create(HDF5.H5T_COMPOUND, HDF5.h5t_get_size(vlen))
    HDF5.h5t_insert(id, "data_", 0, vlen)
    HDF5.h5t_close(vlen)
    dtype = HDF5Datatype(id, parent.plain)
    commit ? commit_datatype(parent, dtype, UTF16String) : JldDatatype(dtype, -1)
end

unknown_type_err() =
    error("""$T is not of a type supported by JLD
             Please report this error at https://github.com/timholy/HDF5.jl""")

# Whether this datatype should be stored as opaque
isopaque(t::(DataType...)) = isa(t, ())
isopaque(t::DataType) = isempty(t.names)

# The size of this datatype in the HDF5 file (if opaque)
opaquesize(t::(DataType...)) = 1
opaquesize(t::DataType) = max(1, t.size)

# Construct HDF5 type corresponding to a tuple type
function h5type(parent::JldFile, T::(ANY...), commit::Bool)
    !isa(T, (DataType...)) && unknown_type_err()
    T = T::(DataType...)

    haskey(parent.jlh5type, T) && return parent.jlh5type[T]
    isleaftype(T) || error("unexpected non-leaf type $T")

    typeinfo = JldTypeInfo(parent, T, commit)
    if isopaque(T)
        id = HDF5.h5t_create(HDF5.H5T_OPAQUE, opaquesize(T))
    else
        id = HDF5.h5t_create(HDF5.H5T_COMPOUND, typeinfo.size)
    end
    for i = 1:length(typeinfo.offsets)
        fielddtype = typeinfo.dtypes[i]
        HDF5.h5t_insert(id, mangle_name(fielddtype, i), typeinfo.offsets[i], fielddtype)
    end

    dtype = HDF5Datatype(id, parent.plain)
    if commit
        jlddtype = commit_datatype(parent, dtype, T)
        if isempty(T)
            # to allow recovery of empty tuples, which HDF5 does not allow
            a_write(dtype, "empty", uint8(1))
        end
        jlddtype
    else
        JldDatatype(dtype, -1)
    end
end

# Construct HDF5 type corresponding to a user-defined type
function h5type(parent::JldFile, T::ANY, commit::Bool)
    !isa(T, DataType) && unknown_type_err()
    T = T::DataType

    haskey(parent.jlh5type, T) && return parent.jlh5type[T]
    isleaftype(T) || error("unexpected non-leaf type ", T)

    if isopaque(T)
        # Empty type or non-basic bitstype
        id = HDF5.h5t_create(HDF5.H5T_OPAQUE, opaquesize(T))
    else
        # Compound type
        typeinfo = JldTypeInfo(parent, T.types, commit)
        id = HDF5.h5t_create(HDF5.H5T_COMPOUND, typeinfo.size)
        for i = 1:length(typeinfo.offsets)
            fielddtype = typeinfo.dtypes[i]
            HDF5.h5t_insert(id, mangle_name(fielddtype, T.names[i]), typeinfo.offsets[i], fielddtype)
        end
    end

    dtype = HDF5Datatype(id, parent.plain)
    if commit
        jlddtype = commit_datatype(parent, dtype, T)
        if T.size == 0
            # to allow recovery of empty types, which HDF5 does not allow
            a_write(dtype, "empty", uint8(1))
        end
        jlddtype
    else
        JldDatatype(dtype, -1)
    end
end

## Get corresponding HDF5Datatype for a specific value.

# For simple types, just pass through to HDF5
h5datatype{T<:BitsKindOrByteString}(parent::JldFile, ::T) =
    HDF5.hdf5_type_id(T)

# Arrays of types are arrays of the corresponding field type
# This stores arrays of mutable types as reference arrays
h5datatype{T}(parent::JldFile, ::Array{T}) =
    h5fieldtype(parent, T, true)

# For compound types, call h5type
h5datatype(parent::JldFile, x::ANY) = h5type(parent, typeof(x), true)

# Needed to dispatch to the right h5type implementation
h5datatype(parent::JldFile, x::Type) = h5type(parent, Type{Type}, true)

h5datatype(parent::JldGroup, x) = h5datatype(file(parent), x)

## Get corresponding Julia type for a specific HDF5 type, and define
## jlconvert for that type.

function reconstuct_type(parent::JldFile, dtype::HDF5Datatype, name::Symbol)
    class_id = HDF5.h5t_get_class(dtype.id)
    if class_id == HDF5.H5T_OPAQUE
        if exists(dtype, "empty")
            @eval (immutable $name; end; $name)
        else
            sz = int(HDF5.h5t_get_size(dtype.id))*8
            @eval (bitstype $sz $name; $name)
        end
    else
        fields = Expr(:block)
        for i = 0:HDF5.h5t_get_nmembers(dtype.id)-1
            member_name = HDF5.h5t_get_member_name(dtype.id, i)
            idx = rsearchindex(member_name, "_")
            field_name = symbol(member_name[1:idx-1])
            if idx != sizeof(member_name)
                member_dtype = HDF5.t_open(parent.plain, string(pathtypes, '/', lpad(member_name[idx+1:end], 8, '0')))
                push!(fields.args, :($(field_name)::$(jldatatype(parent, member_dtype))))
            else
                member_class = HDF5.h5t_get_member_class(dtype.id, i)
                if member_class == HDF5.H5T_REFERENCE
                    push!(fields.args, field_name)
                else
                    member_dtype = HDF5Datatype(HDF5.h5t_get_member_type(dtype.id, i), parent.plain)
                    push!(fields.args, :($(field_name)::$(jldatatype(parent, member_dtype))))
                end
            end
        end

        @eval (immutable $name; $fields; end; $name)
    end
end

# Get the index of a type in the types group. This could be cached,
# but it's already many times faster than calling H5Iget_name with
# a lot of data in the file. Revisit if this ever turns out to be a
# bottleneck.
function typeindex(parent::JldFile, addr::HDF5.Haddr)
    gtypes = parent.plain[pathtypes]
    i = 1
    for x in gtypes
        if HDF5.objinfo(x).addr == addr
            return i
        end
        i += 1
    end
end

function jldatatype(parent::JldFile, dtype::HDF5Datatype)
    class_id = HDF5.h5t_get_class(dtype.id)
    if class_id == HDF5.H5T_STRING
        cset = HDF5.h5t_get_cset(dtype.id)
        if cset == HDF5.H5T_CSET_ASCII
            return ASCIIString
        elseif cset == HDF5.H5T_CSET_UTF8
            return UTF8String
        else
            error("character set ", cset, " not recognized")
        end
    elseif class_id == HDF5.H5T_INTEGER || class_id == HDF5.H5T_FLOAT
        # This can be a performance hotspot
        HDF5.h5t_equal(dtype.id, HDF5.H5T_NATIVE_DOUBLE) > 0 && return Float64
        HDF5.h5t_equal(dtype.id, HDF5.H5T_NATIVE_INT64) > 0 && return Int64
        HDF5.h5t_equal(dtype.id, HDF5.H5T_NATIVE_FLOAT) > 0 && return Float32
        HDF5.h5t_equal(dtype.id, HDF5.H5T_NATIVE_INT32) > 0 && return Int32
        HDF5.h5t_equal(dtype.id, HDF5.H5T_NATIVE_UINT8) > 0 && return Uint8
        HDF5.h5t_equal(dtype.id, HDF5.H5T_NATIVE_UINT64) > 0 && return Uint64
        HDF5.h5t_equal(dtype.id, HDF5.H5T_NATIVE_UINT32) > 0 && return Uint32
        HDF5.h5t_equal(dtype.id, HDF5.H5T_NATIVE_INT8) > 0 && return Int8
        HDF5.h5t_equal(dtype.id, HDF5.H5T_NATIVE_INT16) > 0 && return Int16
        HDF5.h5t_equal(dtype.id, HDF5.H5T_NATIVE_UINT16) > 0 && return Uint16
        error("unrecognized integer or float type")
    elseif class_id == HDF5.H5T_COMPOUND || class_id == HDF5.H5T_OPAQUE
        addr = HDF5.objinfo(dtype).addr
        haskey(parent.h5jltype, addr) && return parent.h5jltype[addr]

        typename = a_read(dtype, name_type_attr)
        T = julia_type(typename)
        if T == UnsupportedType
            warn("type $typename not present in workspace; reconstructing")
            T = reconstuct_type(parent, dtype, gensym(typename))
        end

        if !(T in BUILTIN_TYPES)
            # Call jldatatype on dependent types to validate them and
            # define jlconvert
            if class_id == HDF5.H5T_COMPOUND
                for i = 0:HDF5.h5t_get_nmembers(dtype.id)-1
                    member_name = HDF5.h5t_get_member_name(dtype.id, i)
                    idx = rsearchindex(member_name, "_")
                    if idx != sizeof(member_name)
                        member_dtype = HDF5.t_open(parent.plain, string(pathtypes, '/', lpad(member_name[idx+1:end], 8, '0')))
                        jldatatype(parent, member_dtype)
                    end
                end
            end

            gen_jlconvert(JldTypeInfo(parent, T, false), T)
        end

        # Verify that types match
        newtype = h5type(parent, T, false).dtype
        dtype == newtype || throw(TypeMismatchException(typename))

        # Store type in type index
        index = typeindex(parent, addr)
        parent.jlh5type[T] = JldDatatype(dtype, index)
        parent.h5jltype[addr] = T
        T
    else
        error("unrecognized HDF5 datatype class ", class_id)
    end
end

jldatatype(parent::JldGroup, x) = jldatatype(file(parent), x)
