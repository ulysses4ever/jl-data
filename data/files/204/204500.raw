#
# MGS: Massive Graph Sampler
# Copyright (C) 2014  Jimmy Dubuisson <jimmy.dubuisson@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#

using Graphs, DataStructures, Logging

### Basic stats ###

# get # vertices, # of edges and density
function get_basic_stats(g)
	nvs = length(vertices(g))
	nes = num_edges(g)
	density = nes/(nvs*(nvs-1))
	return nvs,nes,density
end

# get out degree stats (avg, max, array of sinks)
function get_out_degree_stats{T<:Unsigned}(g::GenericAdjacencyList{T,Array{T,1},Array{Array{T,1},1}})
	sum = 0
	sinks = T[]
	max_degree = 0
	vs = vertices(g)
	for v in vs
		children = out_neighbors(v,g)
		od = length(children)
		sum += od
		if od == 0
			push!(sinks,v)
		end
		if od > max_degree
			max_degree = od
		end
	end
	return sum/length(vs),max_degree,sinks
end

# get array of sinks
function get_sinks{T<:Unsigned}(g::GenericAdjacencyList{T,Array{T,1},Array{Array{T,1},1}})
	sinks = T[]
	vs = vertices(g)
	for v in vs
		children = out_neighbors(v,g)
		od = length(children)
		if od == 0
			push!(sinks,v)
		end
	end
	return sinks
end

# get array of sources 
function get_sources{T<:Unsigned}(g::GenericAdjacencyList{T,Array{T,1},Array{Array{T,1},1}})
	achildren = T[]
	vs = vertices(g)
	for v in vs
		children = out_neighbors(v,g)
		achildren = union(achildren,children)
	end
	return setdiff(vs,achildren)
end

### Subgraphs && SCCs

# get the subgraph of g induced by the set of vertices sids
function subgraph{T<:Unsigned}(g::GenericAdjacencyList{T,Array{T,1},Array{Array{T,1},1}}, sids::Array{T,1})
	ng = adjlist(T, is_directed=true)
	# nvs should be sorted in acending order
	nvs = sort(sids)

	# add vertices
	for i in 1:length(nvs)
        	add_vertex!(ng,convert(T,i))
	end

	# old id -> new id
	oni = Dict{T,T}()

	counter = convert(T,1)
	for v in nvs
		oni[v] = counter
		counter += convert(T,1)
	end

	# add edges
	for v in nvs
		children = out_neighbors(v,g)
		source = oni[v]
		for c in children
			#if indexsorted(nvs,c) != 0
			if haskey(oni,c)
				target = oni[c]
				add_edge!(ng,source,target)
			end
		end
	end

	return ng,oni
end

# get the subgraph of g induced by the set of vertices sids
# write the subgraph in MGS format v2
function subgraph_streamed{T<:Unsigned}(g::GenericAdjacencyList{T,Array{T,1},Array{Array{T,1},1}}, sids::Array{T,1}, name::String)
	ng = adjlist(T, is_directed=true)
	# nvs should be sorted in acending order
	nvs = sort(sids)

	f1 = open("$name.index", "w") 
	f2 = open("$name.data", "w") 

	# old id -> new id
	oni = Dict{T,T}()

	counter = convert(T,1)
	for v in nvs
		oni[v] = counter
		counter += convert(T,1)
	end

	pos = convert(T,1)
	for v in nvs
		children = out_neighbors(v,g)
		bytes = reinterpret(Uint8, [pos])
                write(f1, reverse(bytes))
		for c in children
			if haskey(oni,c)
				target = oni[c]
				bytes = reinterpret(Uint8, [target])
                		write(f2, reverse(bytes))
				# pos += convert(Uint32, 1) -> 8 bytes!?
				pos = convert(T,pos+1)			
			end
		end
	end

	@debug("# vertices: ", length(nvs))
	@debug("# edges: ", pos)

	close(f1)
	close(f2)

	return oni
end

# Tarjan algorithm (recursive version)
#
# NB: successfully tested with FA core
# NB: the recursive calls may create a stack overflow error
function tarjan{T<:Unsigned}(g::GenericAdjacencyList{T,Array{T,1},Array{Array{T,1},1}})
	sccs = Array(Array{T,1},0)
	n = length(vertices(g))
	indices = zeros(T,n)
	lowlinks = zeros(T,n)
	S = T[]
	index = 1

	# recursive function
	function visit(v)
		indices[v] = index
		lowlinks[v] = index
		index += 1
		push!(S,v)
		children = out_neighbors(v,g)
		for w in children
			# w was not visited yet
			if indices[w] == 0
				# recursive call
				visit(w)
				# back propagate the lowlink
				lowlinks[v] = min(lowlinks[v], lowlinks[w])
			# w is in S and hence in the current SCC
			elseif findfirst(S,w) != 0
				lowlinks[v] = min(lowlinks[v], indices[w])
			end
		end

		if lowlinks[v] == indices[v]
			component = T[]
			while true
				w = pop!(S)
				push!(component,w)
				w == v && break
			end
			push!(sccs,component)
		end
	end

	for v in vertices(g)
		indices[v] == 0 && visit(v)
	end

	return sccs
end

# Pearce version of Tarjan algorithm
#
# NB: successfully tested with FA core
# NB: the recursive calls may create a stack overflow error
function pearce{T<:Unsigned}(g::GenericAdjacencyList{T,Array{T,1},Array{Array{T,1},1}})
	n = length(vertices(g))
	rindex = zeros(T,n)
	S = T[]
	index = 1
	c = n-1

	# recursive function
	function visit(v)
		root = true
		rindex[v] = index
		index += 1
		children = out_neighbors(v,g)
		for w in children
			rindex[w] == 0 && visit(w)
			rindex[w] < rindex[v] && begin rindex[v] = rindex[w]; root = false end
		end
		if root
			index -= 1
			while !isempty(S) && rindex[v] <= rindex[S[end]]
				w = pop!(S)
				rindex[w] = c
				index -= 1
			end
			rindex[v] = c
			c -= 1
		else
			push!(S,v)
		end
	end

	for v in vertices(g)
		if rindex[v] == 0
			visit(v)
		end
	end

	return rindex
end

# Pearce algorithm state
type state{T}
	v::T
	stage::T
	root::Bool
end

# Pearce version of Tarjan algorithm - iterative version
function pearce_iterative{T<:Unsigned}(g::GenericAdjacencyList{T,Array{T,1},Array{Array{T,1},1}})
	n = length(vertices(g))
	rindex = zeros(T,n)
	S = T[]
	index = 1
	c = n-1

	function visit(v)
		states = state[]
		current_state = state(v,convert(T,0),true)
		push!(states, current_state)

		@label start
		while !isempty(states)
			current_state = pop!(states)
			active_loop = false

			if current_state.stage == 0
				rindex[current_state.v] = index
				index += 1
				active_loop = true
			end
			children = out_neighbors(current_state.v,g)
			for w in children
				if active_loop
					if rindex[w] == 0
						current_state.stage = w
						push!(states,current_state)

						new_state = state(w,convert(T,0),true)
						push!(states,new_state)
						@goto start
					end
					rindex[w] < rindex[current_state.v] && begin rindex[current_state.v] = rindex[w]; current_state.root = false end
				elseif current_state.stage == w
					active_loop = true
					rindex[w] < rindex[current_state.v] && begin rindex[current_state.v] = rindex[w]; current_state.root = false end
				end
			end
			if current_state.root
				index -= 1
				while !isempty(S) && rindex[current_state.v] <= rindex[S[end]]
					w = pop!(S)
					rindex[w] = c
					index -= 1
				end
				rindex[current_state.v] = c
				c -= 1
			else
				push!(S,current_state.v)
			end
		end
	end

	for v in vertices(g)
		if rindex[v] == 0
			visit(v)
		end
	end

	return rindex
end

# get the main SCC and write it to the specified file (MGS format)
# write the subgraph in MGS format v2
function get_core_streamed{T<:Unsigned}(g::GenericAdjacencyList{T,Array{T,1},Array{Array{T,1},1}},sccs::Array{T,1},name::String)
	scc_ids = union(sccs,[])
	id_size = Dict{T,T}()

	for id in scc_ids
		id_size[id] = 0
	end

	for id in sccs
		id_size[id] += 1
	end

	sizes = collect(values(id_size))
	sort!(sizes)
	msize = sizes[end]

	# find the max SCC id
	mid = 0
	for id in keys(id_size)
		id_size[id] == msize && begin mid = id; break end
	end

	sids = T[]
	counter = convert(T,1)
	for id in sccs
		id == mid && push!(sids,counter)
		counter = convert(T,counter+1)
	end

	@debug("# core vids: ", length(sids))

	subgraph_streamed(g,sids,name)
end

# get the reverse graph (same graph with all edge directions reversed)
function get_reverse_graph{T<:Unsigned}(g::GenericAdjacencyList{T,Array{T,1},Array{Array{T,1},1}})
	ng = adjlist(T, is_directed=true)
	vs = vertices(g)

	# same set of vertices
	for v in vs
		add_vertex!(ng,v)
	end

	# inverse the edge directions
	for v in vs
		children = out_neighbors(v,g)
		for c in children
			add_edge!(ng,c,v)
		end
	end

	return ng
end

# get in-degree of g vertices
function get_vertex_in_degrees{T<:Unsigned}(g::GenericAdjacencyList{T,Array{T,1},Array{Array{T,1},1}})
	vin = Dict{T,T}()
	for v in vertices(g)
		ovs = out_neighbors(v,g)
		for o in ovs
			if !haskey(vin,o)
				vin[o] = convert(T,1)
			else
				vin[o] = convert(T,vin[o]+1)
			end
		end
	end
	return vin
end

# get in- and out- degree sequences
function get_in_out_degrees{T<:Unsigned}(g::GenericAdjacencyList{T,Array{T,1},Array{Array{T,1},1}})
	vin = get_vertex_in_degrees(g)
	in_degrees = T[]
	out_degrees = T[]
	for v in vertices(g)
		push!(in_degrees,vin[v])
		push!(out_degrees,convert(T,length(out_neighbors(v,g))))
	end
	return in_degrees,out_degrees
end

# get the avg out-degree of the set of visited nodes
function get_avg_out_degree{T<:Unsigned}(g::GenericAdjacencyList{T,Array{T,1},Array{Array{T,1},1}}, visited::Array{T,1})
	sum = 0
	for v in visited
		sum += length(out_neighbors(v,g))
	end
	return sum/length(visited)
end
