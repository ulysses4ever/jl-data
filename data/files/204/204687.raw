using Graphs, DataStructures

# get the ordered dictionary vid -> startpos
function load_graph_index(filename)
	f1 = open(filename, "r")
	ipos = OrderedDict{Uint32,Uint32}()
	while !eof(f1)
		id = read(f1,Uint8,4)
		pos = read(f1,Uint8,4)
		# Julia is 1-based -> +1
		ipos[reinterpret(Uint32,reverse(id))[1]] = reinterpret(Uint32,reverse(pos))[1] + 1
	end
	close(f1)
	return ipos
end

# get the array of children
function load_graph_data(filename)
	f2 = open(filename, "r")
	children = Uint32[]
	while !eof(f2)
		child = read(f2,Uint8,4)
		push!(children,reinterpret(Uint32,reverse(child))[1])
	end
	close(f2)
	return children
end

# generate graph (adjacency list)
function get_adjacency_list(ipos,children)
	g = adjlist(Uint32, is_directed=true)
	# ipos is an ordered dictionary
	ks = collect(keys(ipos))
	vs = sort(union(children,ks))
	oni = Dict{Uint32,Uint32}()

	for i in 1:length(vs)
        	add_vertex!(g,uint32(i))
	end

	for i in 1:length(ks)
		if haskey(oni,ks[i])
			source = oni[ks[i]]
		else
			source = searchsorted(vs,ks[i])[1]
			oni[ks[i]] = source
		end
		if i == length(ks)
			pos1 = ipos[ks[i]]
			pos2 = length(children)
		else
			pos1 = ipos[ks[i]]
			pos2 = ipos[ks[i+1]]-1
		end
		for p in pos1:pos2
			if haskey(oni,children[p])
				target = oni[children[p]]
			else
				target = searchsorted(vs,children[p])[1]
				oni[children[p]] = target
			end
			add_edge!(g,uint32(source),uint32(target))
		end
	end
	return g
end

##########

#ipos = load_graph_index("fa/graph.index")
#children = load_graph_data("fa/graph.data")
ipos = load_graph_index("~/datasets/twitter/parents/graph.index")
children = load_graph_data("~/datasets/twitter/parents/graph.data")

g = get_adjacency_list(ipos,children)

println(length(vertices(g)))
println(num_edges(g))

open("twitter-parents.jld", "w") do file
	serialize(file, g)
end
