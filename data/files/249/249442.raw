#!/usr/bin/env julia4
using Mesos
using ProtoBuf
using Logging

Logging.configure(level=DEBUG)
Logging.configure(output=open("framework.log", "a"))

const TOTAL_TASKS = 5
const TASK_CPUS = 1.
const TASK_MEM = 128.
const EXECUTOR = joinpath(Pkg.dir("Mesos"),"examples","executor.jl")

type TestSchedulerConfig <: SchedulerConfig
    tasksLaunched::Int
    tasksFinished::Int
    messagesSent::Int
    messagesReceived::Int
    implicitAcknowledgements::Bool
    taskData::Dict{String, (Proto.SlaveID, Proto.ExecutorID)}
    executor::Proto.ExecutorInfo

    function TestSchedulerConfig()
        taskData = Dict{String, (Proto.SlaveID, Proto.ExecutorID)}()

        # Setup executor
        command = Proto.CommandInfo()
        set_field!(command, :value, EXECUTOR)
        execInfo = Proto.ExecutorInfo()
        set_field!(execInfo, :name, "Test Executor (Julia)")
        set_field!(execInfo, :source, "julia_test")
        set_field!(execInfo, :executor_id, @proto Proto.ExecutorID (:value => "default"))
        set_field!(execInfo, :command, command)
        set_field!(execInfo, :resources, Proto.Resource[])
        #push!(execInfo.resources, Mesos.createResourse("cpus", TASK_CPUS))
        push!(execInfo.resources, Mesos.createResourse("mem", TASK_MEM))

        return new(0, 0, 0, 0, true, taskData, execInfo)
    end
end

# Utils


#-------------------------------------------------------------------------------
# Callbacks
#-------------------------------------------------------------------------------
function scheduler_registered(driver::SchedulerDriver, config::TestSchedulerConfig,
                              frameworkId::Proto.FrameworkID, masterInfo::Proto.MasterInfo)
    debug("Registered with framework ID $(frameworkId.value)")
end

function scheduler_reregistered(driver::SchedulerDriver, config::TestSchedulerConfig,
                                masterInfo::Proto.MasterInfo)
    debug("Re-registered with master: $(masterInfo.hostname)")
end

function scheduler_disconnected(driver::SchedulerDriver)
    debug("Disconnected")
end

function scheduler_resourceOffers(driver::SchedulerDriver, config::TestSchedulerConfig, offers::Vector{Proto.Offer})
    for offer in offers
        tasks = Proto.TaskInfo[]
        offerCpus = 0
        offerMem = 0
        for resource in offer.resources
            if resource.name == "cpus"
                offerCpus += resource.scalar.value
            elseif resource.name == "mem"
                offerMem += resource.scalar.value
            end
        end

        debug("Received offer $(offer.id.value) with cpus: $offerCpus and mem: $offerMem")

        remainingCpus = offerCpus
        remainingMem = offerMem

        while config.tasksLaunched < TOTAL_TASKS &&
              remainingCpus >= TASK_CPUS  &&
              remainingMem >= TASK_MEM

            tid = config.tasksLaunched
            config.tasksLaunched += 1

            debug("Launching task $tid using offer $(offer.id.value)")

            task = Proto.TaskInfo()
            taskId = Proto.TaskID()
            set_field!(taskId, :value, string(tid))
            set_field!(task, :task_id, taskId)
            slaveId = Proto.SlaveID()
            set_field!(slaveId, :value, offer.slave_id.value)
            set_field!(task, :slave_id, slaveId)
            set_field!(task, :name, "task $tid")
            set_field!(task, :executor, config.executor)
            set_field!(task, :resources, Proto.Resource[])

            # add resources
            push!(task.resources, makeResourse("cpus", TASK_CPUS))
            push!(task.resources, makeResourse("mem", TASK_MEM))

            push!(tasks, task)
            config.taskData[task.task_id.value] = (offer.slave_id, task.executor.executor_id)

            remainingCpus -= TASK_CPUS
            remainingMem -= TASK_MEM
        end

        # Make operation for launch
        operation = Proto.Offer_Operation()
        set_field!(operation, :_type, Proto.Offer_Operation_Type.LAUNCH)
        launchOp = Proto.Offer_Operation_Launch()
        set_field!(launchOp, :task_infos, tasks)
        set_field!(operation, :launch, launchOp)

        acceptOffers(driver, [offer.id], [operation])
    end
end

function scheduler_statusUpdate(driver::SchedulerDriver, config::TestSchedulerConfig, status::Proto.TaskStatus)
    info("Task $(status.task_id.value) is in state $(status.state)")

    # Ensure the binary data came through.
    statusData = bytestring(status.data)
    debug("Task $(status.task_id.value) status data: $statusData")
    debug("Task $(status.task_id.value) status message: $(status.message)")
    if statusData != "data with a \0 byte"
        warn("""
            StatusUpdate:
            The returned message data did not match!
                Expected: 'data with a \0 byte'
                  Actual: '$statusData'
            """)
        exit(1)
    end

    if status.state == Proto.TaskState.TASK_FINISHED
        config.tasksFinished += 1
        if config.tasksFinished == TOTAL_TASKS
            info("All tasks done, waiting for final framework message")
        end
        slave_id, executor_id = config.taskData[status.task_id.value]
        config.messagesSent += 1
        sendFrameworkMessage(driver, executor_id, slave_id, "data with a \0 byte")
    end

    if status.state == Proto.TaskState.TASK_LOST ||
       status.state == Proto.TaskState.TASK_KILLED ||
       status.state == Proto.TaskState.TASK_FAILED
        warn("Aborting because task $(status.task_id.value) is in unexpected state $(status.state) with message '$(status.message)'")
        abort(driver)
    end

    # Explicitly acknowledge the update if implicit acknowledgements are not being used.
    if !config.implicitAcknowledgements
        acknowledgeStatusUpdate(driver, status)
    end
end

function scheduler_frameworkMessage(driver::SchedulerDriver, config::TestSchedulerConfig,
                                    executorId::Proto.ExecutorID, slaveId::Proto.SlaveID, message::String)
    config.messagesReceived += 1
    if message != "data with a \0 byte"
        warn("""
            FrameworkMessage:
            The returned message data did not match!
                Expected: 'data with a \0 byte'
                  Actual: '$message'
            """)
        exit(1)
    end
    info("Received message: '$message'")

    if config.messagesReceived == TOTAL_TASKS
        if config.messagesReceived != config.messagesSent
            warn("Sent $(config.messagesSent) but received $(config.messagesReceived)")
            exit(1)
        end
        info("All tasks done, and all messages received, exiting")
        stop(driver)
    end
end

function scheduler_error(driver::SchedulerDriver, error_msg::String)
    error(error_msg)
end

#-------------------------------------------------------------------------------

if length(ARGS) == 0
    println("Usage: $(ENV["_"]) master")
    exit(1)
end

# Create scheduler configuration
config = TestSchedulerConfig()

# Setup framework
framework = @proto Proto.FrameworkInfo (
    :name =>  "Test Framework (Julia)",
    :user => "" # Have Mesos fill in the current user.
)

if haskey(ENV, "MESOS_CHECKPOINT")
    println("Enabling checkpoint for the framework")
    set_field!(framework, :checkpoint, true)
end

if haskey(ENV, "MESOS_AUTHENTICATE")
    println("Enabling authentication for the framework")
    set_field!(framework, :principal, ENV["DEFAULT_PRINCIPAL"])
else
    set_field!(framework, :principal, "test-framework-julia")
end

if haskey(ENV, "MESOS_EXPLICIT_ACKNOWLEDGEMENTS")
    println("Enabling explicit acknowledgements for status updates")
    config.implicitAcknowledgements = false
end

# Create & setup scheduler
scheduler = Scheduler(config,
                      registered = scheduler_registered,
                      reregistered = scheduler_reregistered,
                      disconnected = scheduler_disconnected,
                      resourceOffers = scheduler_resourceOffers,
                      statusUpdate = scheduler_statusUpdate,
                      frameworkMessage = scheduler_frameworkMessage,
                      error = scheduler_error)

info("Starting Scheduler Driver")
run(scheduler, framework, ARGS[1])