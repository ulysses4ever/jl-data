# Callback wrappers
function registered_wrap(eiBuf::Ptr{Uint8}, eiBufSize::Cint,
                        fiBuf::Ptr{Uint8}, fiBufSize::Cint,
                        siBuf::Ptr{Uint8}, siBufSize::Cint,
                        callback::Ptr{Void}, driver::Ptr{Void})
    f = unsafe_pointer_to_objref(callback)::Function
    executorInfo = makeproto(eiBuf, eiBufSize, Proto.ExecutorInfo)
    frameworkInfo = makeproto(fiBuf, fiBufSize, Proto.FrameworkInfo)
    slaveInfo = makeproto(siBuf, siBufSize, Proto.SlaveInfo)
    f(ExecutorDriver(driver), executorInfo, frameworkInfo, slaveInfo)
    return
end

function reregistered_wrap(slaveBuf::Ptr{Uint8}, slaveBufSize::Cint, callback::Ptr{Void}, driver::Ptr{Void})
    f = unsafe_pointer_to_objref(callback)::Function
    slaveInfo = makeproto(slaveBuf, slaveBufSize, Proto.SlaveInfo)
    f(ExecutorDriver(driver), slaveInfo)
    return
end

function disconnected_wrap(callback::Ptr{Void}, driver::Ptr{Void})
    f = unsafe_pointer_to_objref(callback)::Function
    f(ExecutorDriver(driver))
    return
end

function launchTask_wrap(taskBuf::Ptr{Uint8}, taskBufSize::Cint, callback::Ptr{Void}, driver::Ptr{Void})
    f = unsafe_pointer_to_objref(callback)::Function
    taskInfo = makeproto(taskBuf, taskBufSize, Proto.TaskInfo)
    f(ExecutorDriver(driver), taskInfo)
    return
end

function killTask_wrap(taskBuf::Ptr{Uint8}, taskBufSize::Cint, callback::Ptr{Void}, driver::Ptr{Void})
    f = unsafe_pointer_to_objref(callback)::Function
    taskId = makeproto(taskBuf, taskBufSize, Proto.TaskID)
    f(ExecutorDriver(driver), taskId)
    return
end

function frameworkMessage_wrap(data::Ptr{Uint8}, dataLength::Cint, callback::Ptr{Void}, driver::Ptr{Void})
    f = unsafe_pointer_to_objref(callback)::Function
    f(ExecutorDriver(driver), bytestring(data, dataLength))
    return
end

function shutdown_wrap(callback::Ptr{Void}, driver::Ptr{Void})
    f = unsafe_pointer_to_objref(callback)::Function
    f(ExecutorDriver(driver))
    return
end

function error_wrap(msg::Ptr{Uint8}, msgSize::Cint, callback::Ptr{Void}, driver::Ptr{Void})
    f = unsafe_pointer_to_objref(callback)::Function
    f(ExecutorDriver(driver), bytestring(msg, msgSize))
    return
end

# Callback C handles
const registered_wrap_c = cfunction(registered_wrap, Void, (Ptr{Uint8}, Cint, Ptr{Uint8}, Cint, Ptr{Uint8}, Cint, Ptr{Void}, Ptr{Void}))
const reregistered_wrap_c = cfunction(reregistered_wrap, Void, (Ptr{Uint8}, Cint, Ptr{Void}, Ptr{Void}))
const disconnected_wrap_c = cfunction(disconnected_wrap, Void, (Ptr{Void}, Ptr{Void}))
const launchTask_wrap_c = cfunction(launchTask_wrap, Void, (Ptr{Uint8}, Cint, Ptr{Void}, Ptr{Void}))
const killTask_wrap_c = cfunction(killTask_wrap, Void, (Ptr{Uint8}, Cint, Ptr{Void}, Ptr{Void}))
const frameworkMessage_wrap_c = cfunction(frameworkMessage_wrap, Void, (Ptr{Uint8}, Cint, Ptr{Void}, Ptr{Void}))
const shutdown_wrap_c = cfunction(shutdown_wrap, Void, (Ptr{Void}, Ptr{Void}))
const error_wrap_c = cfunction(error_wrap, Void, (Ptr{Uint8}, Cint, Ptr{Void}, Ptr{Void}))


# Executor (callback container)
type Executor
    registered_cf::Ptr{Void}
    registered_callback::Any
    reregistered_cf::Ptr{Void}
    reregistered_callback::Any
    disconnected_cf::Ptr{Void}
    disconnected_callback::Any
    launchTask_cf::Ptr{Void}
    launchTask_callback::Any
    killTask_cf::Ptr{Void}
    killTask_callback::Any
    frameworkMessage_cf::Ptr{Void}
    frameworkMessage_callback::Any
    shutdown_cf::Ptr{Void}
    shutdown_callback::Any
    error_cf::Ptr{Void}
    error_callback::Any

    function Executor(registered::Function, reregistered::Function, disconnected::Function,
                    launchTask::Function, killTask::Function, frameworkMessage::Function,
                    shutdown::Function, error::Function)
        return new(
            registered_wrap_c, registered,
            reregistered_wrap_c, reregistered,
            disconnected_wrap_c, disconnected,
            launchTask_wrap_c, launchTask,
            killTask_wrap_c, killTask,
            frameworkMessage_wrap_c, frameworkMessage,
            shutdown_wrap_c, shutdown,
            error_wrap_c, error
        )
    end
end

# function Base.run(executor::Executor)
#     executorDriver = ccall((:initialize, Mesos.libmesosjl), Ptr{Void}, (Ptr{Executor},), &executor)
#     if executorDriver == C_NULL
#         error("Cannot start executor driver")
#     end
#     info("Julia executor driver started")
#     run(ExecutorDriver(executorDriver))
#     ccall((:finalize, Mesos.libmesosjl), Void, (Ptr{Void},), executorDriver)
#     exit(status == Status.DRIVER_STOPPED ? 0 : 1)
# end

function Base.run(executor::Executor)
    status = ccall((:run_executor, Mesos.libmesosjl), Cint, (Ptr{Executor},), &executor)
    println("Executor ststus: $status")
    exit(status == Status.DRIVER_STOPPED ? 0 : 1)
end

