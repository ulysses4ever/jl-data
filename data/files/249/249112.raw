# generates the table that defines interval boundaries / heights and
# the various constants required for Chopin's algorithm to sample from
# a truncated normal.

using Roots, Distributions


# returns residual area above N intervals of size 'area' starting at x = 0,
# works for d symmetric around 0 with descreasing pdf above x > 0
function arearesidual(d::ContinuousUnivariateDistribution, area::Float64, N::Int)
    x = 0.0
    for i = 1:N
        x += area / pdf(d, x)  # s.t. area = dx * pdf(min(xi, xi+1))
    end
    area - cdf(d, -x)   # cdf(d, x) = 1 - cdf(d, -x) for symmetric d
end


# returns list of interval boundaries for given number N of intervals above 0
# and the lowest interval of interest, xmin
function genxtable(N::Int, xmin::Real=-2.0)
    stdn = Normal(0, 1)
    # find area such that all intervals cover the same area
    area = fzero(x -> arearesidual(stdn, x, N), 0.5 / N, 0.7 / N)
    # find interval boundaries for x >= 0
    x = Array(Float64, N+1)
    x[1] = 0.0
    for i = 1:N
        xi = x[i]
        x[i+1] = xi + area / pdf(stdn, xi)
    end
    # do not store boundaries below amin
    j = N + 1
    while x[j] > -xmin
        j -= 1
    end  # j points at interval that contains amin
    [-x[j+1:-1:2], x]
end


# returns the other interval tables given the list of interval boundaries. Here,
# yl is the smaller of the two pdf(x)'s' at the interval boundaries
# yu is the larger of the two pdf(x)'s' at the interval boundaries
# d is the interval width
# delta is d yu / yl for each interval
function genydtables(x::Vector{Float64})
    stdn = Normal(0, 1)
    nd = length(x) - 1  # number of intervals [x[i], x[i+1]]
    d = Array(Float64, nd)
    delta = Array(Float64, nd)
    yl = Array(Float64, nd)
    yu = Array(Float64, nd)
    for i = 1:nd
        xi, xi1 = x[i], x[i+1]
        if xi < 0
            yl[i] = pdf(stdn, xi)
            yu[i] = pdf(stdn, xi1)
        else
            yl[i] = pdf(stdn, xi1)
            yu[i] = pdf(stdn, xi)
        end
        d[i] = xi1 - xi
        delta[i] = d[i] * yu[i] / yl[i]
    end
    yl, yu, d, delta
end


# returns the required constants, xmin, xmax, i0, invh
function genconsts(x, d)
    h = minimum(d)    # minimum interval range
    xmin, xmax = x[1], x[end]
    i0 = 1 - ifloor(xmin / h)
    xmin, xmax, i0, 1/h
end


# returns list of indices such that, for some xmin <= a < xmax,
#   k = ncell[i0 + ifloor(a * invh)]
# guarantees
#   x[k] <= a < x[k+2]
function genncell(x, xmin, xmax, i0, invh)
    nb = length(x) - 1
    p = 1 + ifloor(xmax * invh) - ifloor(xmin * invh)
    ncell = Array(Uint16, p)
    k = 1
    for i = 1:p  # ith interval [h(i-i0), h(i-i0+1))
        while k < nb && x[k] < (i - i0) / invh  # ensure x[k] just above h(i-i0)
            k += 1
        end
        ncell[i] = max(k - 1, 1)
    end
    ncell
end


# write vector of numbers in Julia-valid format to io
function writevector{T <: Number}(io::IO, x::Vector{T}, xname, fmtstr::String, xperline::Int)
    n = length(x)
    @eval dofmt(x) = @sprintf($fmtstr, x)
    println(io, "const ", xname, " = ", string(T), "[")
    for i = 1:xperline:n
        print(io, "    ")
        for j = i:min(n, i+xperline-1)
            print(io, dofmt(x[j]), j == n ? "]" : ", ")
        end
        println(io)
    end
end
writevector(io::IO, x::Vector{Float64}, xname, xperline::Int=3) = writevector(io, x, xname, "%.16e", xperline)
writevector(io::IO, x::Vector{Uint16}, xname, xperline::Int=10) = writevector(io, x, xname, "%5d", xperline)


# writes full table to io
function writetable(io::IO, N::Int, xmin::Real=-2.0)
    xmin_ini = xmin
    x = genxtable(N, xmin)
    yl, yu, d, delta = genydtables(x)
    xmin, xmax, i0, invh = genconsts(x, d)
    ncell = genncell(x, xmin, xmax, i0, invh)

    println(io, "# value tables for sampling from a truncated normal distribution")
    println(io, "# generated by https://github.com/jdrugo/fasttn/src/gentables.jl")
    println(io, "# called with N=", N, ", xmin=", xmin_ini)
    println(io, "# number of intervals: ", length(x) - 1)
    println(io)

    # constants
    println(io, "# constants")
    println(io, "const tnzig_xmin = ", xmin)
    println(io, "const tnzig_xmax = ", xmax)
    println(io, "const tnzig_i0 = ", i0)
    println(io, "const tnzig_invh = ", invh)
    println(io)

    # tables
    println(io, "# inverval tables")
    writevector(io, x, "tnzig_x")
    println(io)
    writevector(io, yl, "tnzig_yl")
    println(io)
    writevector(io, yu, "tnzig_yu")
    println(io)
    writevector(io, d, "tnzig_d")
    println(io)
    writevector(io, delta, "tnzig_delta")
    println(io)
    writevector(io, ncell, "tnzig_ncell")
    println(io)
end


# create tables
f = open("randtn_zigtables.jl", "w")
writetable(f, 2048)
close(f)