#!/usr/bin/env julia4
using Mesos
using ProtoBuf
using Logging

Logging.configure(level=DEBUG)
Logging.configure(output=open("framework.log", "a"))

const TOTAL_TASKS = 5
const TASK_CPUS =  .5
const TASK_MEM = 256.
const EXECUTOR = joinpath(Pkg.dir("Mesos"),"examples","executor.jl")

type TestScheduler <: Scheduler
    tasksLaunched::Int
    tasksFinished::Int
    messagesSent::Int
    messagesReceived::Int
    implicitAcknowledgements::Bool
    taskData::Dict{String, Tuple{Proto.SlaveID, Proto.ExecutorID}}
    executor::Proto.ExecutorInfo

    function TestScheduler()
        taskData = Dict{String, Tuple{Proto.SlaveID, Proto.ExecutorID}}()

        # Setup executor
        execInfo = @proto Proto.ExecutorInfo (
            :name => "Test Executor (Julia)",
            :source => "julia_test",
            :executor_id => @proto(Proto.ExecutorID, :value => "default"),
            :command => @proto(Proto.CommandInfo, :value => EXECUTOR),
            :resources => [
                Mesos.createScalarResourse(Mesos.CPU_RESOURSE, TASK_CPUS),
                Mesos.createScalarResourse(Mesos.MEM_RESOURSE, TASK_MEM)
            ]
        )

        return new(0, 0, 0, 0, true, taskData, execInfo)
    end
end

#-------------------------------------------------------------------------------
# Callbacks
#-------------------------------------------------------------------------------
function scheduler_registered(driver::SchedulerDriver, frameworkId::Proto.FrameworkID,
                              masterInfo::Proto.MasterInfo)
    debug("Registered with framework ID $(frameworkId.value)")
end

function scheduler_reregistered(driver::SchedulerDriver, masterInfo::Proto.MasterInfo)
    debug("Re-registered with master: $(masterInfo.hostname)")
end

function scheduler_disconnected(driver::SchedulerDriver)
    debug("Disconnected")
end

function scheduler_resourceOffers(driver::SchedulerDriver, offers::Vector{Proto.Offer})
    for offer in offers
        tasks = Proto.TaskInfo[]
        offerCpus = getScalarResourse(offer.resources, Mesos.CPU_RESOURSE)
        offerMem = getScalarResourse(offer.resources, Mesos.MEM_RESOURSE)

        debug("Received offer $(offer.id.value) with cpus: $offerCpus and mem: $offerMem")

        remainingCpus = offerCpus
        remainingMem = offerMem

        while driver.scheduler.tasksLaunched < TOTAL_TASKS &&
              remainingCpus >= TASK_CPUS  &&
              remainingMem >= TASK_MEM

            tid = driver.scheduler.tasksLaunched
            driver.scheduler.tasksLaunched += 1

            debug("Launching task $tid using offer $(offer.id.value)")
            task = @proto Proto.TaskInfo (
                :task_id => @proto(Proto.TaskID, :value => string(tid)),
                :slave_id => @proto(Proto.SlaveID, :value => offer.slave_id.value),
                :name => "task $tid",
                :executor => driver.scheduler.executor,
                :resources => [
                    #createScalarResourse(Mesos.CPU_RESOURSE, TASK_CPUS),
                    createScalarResourse(Mesos.MEM_RESOURSE, TASK_MEM)
                ]
            )

            push!(tasks, task)
            driver.scheduler.taskData[task.task_id.value] = (offer.slave_id, task.executor.executor_id)

            remainingCpus -= TASK_CPUS
            remainingMem -= TASK_MEM
        end

        # Make operation for launch
        operation = @proto Proto.Offer_Operation (
            :_type  => Proto.Offer_Operation_Type.LAUNCH,
            :launch => @proto(Proto.Offer_Operation_Launch, :task_infos => tasks)
        )

        acceptOffers(driver, [offer.id], [operation])
    end
end

function scheduler_statusUpdate(driver::SchedulerDriver, status::Proto.TaskStatus)
    info("Task $(status.task_id.value) is in state $(status.state)")

    # Ensure the binary data came through.
    statusData = bytestring(status.data)
    debug("Task $(status.task_id.value) status data: $statusData")
    debug("Task $(status.task_id.value) status message: $(status.message)")
    if statusData != "data with a \0 byte"
        warn("""
            StatusUpdate:
            The returned message data did not match!
                Expected: 'data with a \0 byte'
                  Actual: '$statusData'
            """)
        exit(1)
    end

    if status.state == Proto.TaskState.TASK_FINISHED
        driver.scheduler.tasksFinished += 1
        if driver.scheduler.tasksFinished == TOTAL_TASKS
            info("All tasks done, waiting for final framework message")
        end
        slave_id, executor_id = driver.scheduler.taskData[status.task_id.value]
        driver.scheduler.messagesSent += 1
        sendFrameworkMessage(driver, executor_id, slave_id, "data with a \0 byte")
    end

    if status.state == Proto.TaskState.TASK_LOST ||
       status.state == Proto.TaskState.TASK_KILLED ||
       status.state == Proto.TaskState.TASK_FAILED
        warn("Aborting because task $(status.task_id.value) is in unexpected state $(status.state) with message '$(status.message)'")
        abort(driver)
    end

    # Explicitly acknowledge the update if implicit acknowledgements are not being used.
    if !driver.scheduler.implicitAcknowledgements
        acknowledgeStatusUpdate(driver, status)
    end
end

function scheduler_frameworkMessage(driver::SchedulerDriver, executorId::Proto.ExecutorID,
                                    slaveId::Proto.SlaveID, message::String)
    driver.scheduler.messagesReceived += 1
    if message != "data with a \0 byte"
        warn("""
            FrameworkMessage:
            The returned message data did not match!
                Expected: 'data with a \0 byte'
                  Actual: '$message'
            """)
        exit(1)
    end
    info("Received message: '$message'")

    if driver.scheduler.messagesReceived == TOTAL_TASKS
        if driver.scheduler.messagesReceived != driver.scheduler.messagesSent
            warn("Sent $(driver.scheduler.messagesSent) but received $(driver.scheduler.messagesReceived)")
            exit(1)
        end
        info("All tasks done, and all messages received, exiting")
        stop(driver)
    end
end

function scheduler_error(driver::SchedulerDriver, error_msg::String)
    error(error_msg)
end

#-------------------------------------------------------------------------------

if length(ARGS) == 0
    println("Usage: $(ENV["_"]) master")
    exit(1)
end

# Create scheduler configuration
scheduler = TestScheduler()

# Setup framework
framework = createFramework("Test Framework (Julia)")
if haskey(ENV, "MESOS_EXPLICIT_ACKNOWLEDGEMENTS")
    println("Enabling explicit acknowledgements for status updates")
    scheduler.implicitAcknowledgements = false
end

# Create & setup scheduler
scheduler_cb = SchedulerCallback(scheduler,
                      registered = scheduler_registered,
                      reregistered = scheduler_reregistered,
                      disconnected = scheduler_disconnected,
                      resourceOffers = scheduler_resourceOffers,
                      statusUpdate = scheduler_statusUpdate,
                      frameworkMessage = scheduler_frameworkMessage,
                      error = scheduler_error)

info("Starting Scheduler Driver")
run(scheduler_cb, framework, ARGS[1])