# -*- coding: utf-8 -*-

#=
Created on Thu Oct 29 14:36:49 2015
@author: William Herrera

Julia v0.4 code to analyze sound and use as interface with ASUS G20 lighting

IMPORTANT: run as administrator

=#

using AudioIO
using DSP

include("LightACPI.jl")
using .LightACPI

MAX = 0
SEGMENTS = 9
CHUNK_EXPONENT = 15
LIGHT_ROTATION_INTERVAL = 0
DEVICE_NUMBER = 2
SIGNALRATE = 44100

function list_devices(do_print=true)
    #=
    List all audio input devices
    =#
    devices = get_audio_devices()
    text = "Audio Device Options and Number of Possible Input Channels:\n"
    ndev = length(devices)
    devs = Array(ASCIIString, ndev)
    for idx in 1:ndev
        if devices[idx].max_input_channels > 0
            dev_line = string(devices[idx].device_index, ". ", 
                       devices[idx].name, " ",
                       devices[idx].max_input_channels)
            devs[idx] = dev_line
            text = string("$text$dev_line\n")
        end
    end
    if do_print
        print(text)
    end
    return ndev, devices
end

function asus_soundlight(do_print=true)
    #=
    Get sound samples and adjust LED light color accordingly
    =#
    # Change chunk if too fast/slow, never less than 2**13
    chunksize = UInt32(2 ^ CHUNK_EXPONENT)

    #=
    CHANGE DEVICE_NUMBER TO CORRECT INPUT DEVICE
    Look at recording devices and right click to show hidden devices,
    and enable the mixing device. Enabling stereo mixing in your
    sound card will make your sound output an input.
    Use list_devices() to list all your input devices
    and choose the mixed device as input device below.
    =#
    device_index = DEVICE_NUMBER

    paud = AudioIO.Pa_AudioStream(device_index, 2, true, SIGNALRATE, 
                                  Integer(chunksize/2))
    if do_print
        print("Starting, use Ctrl+C to stop")
    end
    do_rotate_interval = LIGHT_ROTATION_INTERVAL
    rotate_state = 0
    try
    while true
        while paud.parent_may_use_buffer == false
            sleep(0.5)
        end
        paud.parent_may_use_buffer = false
        levels = summed_spectra(paud.sbuffer, SIGNALRATE)
        paud.parent_may_use_buffer = false

        # Make all levels to be <= 255
        l_max = maximum(levels)
        for idx in 1:SEGMENTS
            levels[idx] = UInt32(round(levels[idx] * 255.0 / l_max))
        end

        if do_rotate_interval == 1
            rotate_state += 1
            rotate_state %= 3
            do_rotate_interval = LIGHT_ROTATION_INTERVAL
        end
        if do_rotate_interval > 0
            do_rotate_interval -= 1
            rotate_levels!(levels, rotate_state)
        end
        saturate_color!(levels)

        setrgb(BLIGHT, levels[1], levels[2], levels[3])
        setrgb(RLIGHT, levels[4], levels[5], levels[6])
        setrgb(LLIGHT, levels[7], levels[8], levels[9])

    end
    finally
        if do_print
            println("\nStopping")
        end
        AudioIO.Pa_StopStream(paud.stream)
        AudioIO.Pa_CloseStream(paud.stream)
    end
end

function rotate_levels!(seq, rtype)
    #=
    rotate around light postions colors
    =#
    if rtype == 1
        saveseq = seq[1:3]
        seq[1:3] = seq[6:9]
        seq[6:9] = seq[3:6]
        seq[3:6] = saveseq
    elseif rtype == 2
        saveseq = seq[1:3]
        seq[1:3] = seq[3:6]
        seq[3:6] = seq[6:9]
        seq[6:9] = saveseq
    end
    seq
end


function sat_trip(cred, cgreen, cblue)
    #=
    saturate rgb color
    =#
    mult = 255.0 / (float(max(cred, cgreen, cblue)) ^ 4)
    return UInt32(round(mult * float(cred) ^ 4)),
           UInt32(round(mult * float(cgreen) ^ 4)),
           UInt32(round(mult * float(cblue) ^ 4))
end


function saturate_color!(col)
    #=
    saturate the colrs representing sound levels
    =#
    col[1], col[2], col[3] = sat_trip(col[1], col[2], col[3])
    col[4], col[5], col[6] = sat_trip(col[4], col[5], col[6])
    col[7], col[8], col[9] = sat_trip(col[7], col[8], col[9])
    return col
end


function equalize(levels, within_factor=3.0)
    #=
    makes levels all within a factor of within of each other
    =#
    new_levels = deepcopy(levels)
    largest = 0.0
    for idx in 1:length(new_levels)
        if new_levels[idx] < 0.0001
            new_levels[idx] = 0.0001
        end
        largest = largest < new_levels[idx] ? new_levels[idx] : largest
    end
    least_allowed = largest / within_factor
    loops = 0
    for idx in 1:length(new_levels)
        while new_levels[idx] < least_allowed && loops < 100
            loops += 1
            new_levels[idx] *= 2.0
        end
    end
    new_levels
end

function summed_spectra(chunkdata, srate)
    #=
    from summed amplitude of power spectrum between low_cut and high-cut
    get amplitudes of specific frequency ranges that correspond to 
    3 intervals each in bass, midrange, and treble:

    20 Hz - 80 Hz = Low Bass
    80 Hz-160 Hz = Bass
    160 Hz - 320 Hz = Hi Bass
    320 Hz - 640 Hz = Low Mid Range
    640 Hz - 1280 Hz = Mid Mid range
    1280 Hz - 2560 Hz = High Midrange
    2560 Hz - 5120 Hz = Low Treble
    5120 Hz - 10240 Hz = Mid treble
    10240 Hz- 20480 Hz = High Treble
    =#
    fchunk = map(Float64, chunkdata)
    pgram = welch_pgram(fchunk, 4096, 0, fs=srate)
    pxx = power(pgram)
    frqs = freq(pgram)
    # the low and mid bass may be contaminated by edge artifact, so use
    # portions of high bass instead.
    lowbass = pxx[(frqs .<= 200.0) & (frqs .> 100.0)]
    midbass = pxx[(frqs .<= 300.0) & (frqs .> 200)]
    higbass = pxx[(frqs .<= 400.0) & (frqs .> 300.0)]
    lowmidr = pxx[(frqs .<= 640.0) & (frqs .> 400.0)]
    midmidr = pxx[(frqs .<= 1280.0) & (frqs .> 640.0)]
    higmidr = pxx[(frqs .<= 2560.0) & (frqs .> 1280.0)]
    # tweak to treble bands for better color changes during vocals
    lowtreb = pxx[(frqs .<= 7000.0) & (frqs .> 2560.0)]
    midtreb = pxx[(frqs .<= 10240.0) & (frqs .> 7000.0)]
    higtreb = pxx[(frqs .<= 20480.0) & (frqs .> 10240.0)]

    sound_levels = [sum(lowbass), sum(midbass), sum(higbass),
                    sum(lowmidr), sum(midmidr), sum(higmidr),
                    sum(lowtreb), sum(midtreb), sum(higtreb)]
    return equalize(sound_levels)
end



list_devices()
asus_soundlight(true)

