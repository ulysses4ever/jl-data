module IPM
#Image Processing Module: Basic methods of image export, convolution, and array colorization.
using Images
using Colors
# For simplicity, ImageWrite currently only works for real inputs (Uint8 can be implemented if necessary, but is a headache to work with). If given a rank-2 array, exports to grayscale. If given a rank-3 array (third index RGB), exports to color.

function ExportImage{T<:Real}(A::Array{T, 2}; Name = string(randstring(10), ".png"), ColorFunction = "Grayscale")
	if ColorFunction == "Grayscale"
	imwrite(grayim(A), Name)
	end
	if ColorFunction == "Orangescale"
	imwrite(convert(Image, cat(3, scale(convert(T, 1.0), A), scale(convert(T, 0.3), A), scale(convert(T, 0.1), A))), Name)
	end
	if ColorFunction == "Endolith"
	imwrite(convert(Image, Endolith(A)), Name)
	end
end

function ExportImage{T<:Real}(A::Array{T, 3}; Name = string(randstring(10), ".png"))
	imwrite(convert(Image, A), Name)
end

function ExportImage{T<:Real}(A::Array{Complex{T}, 2}; Name = string(randstring(10), ".png"))
	(n1, n2) = size(A);
	B = zeros(T, 3, n1, n2)
	temp = convert(Complex{T}, 0.0 + 0.0*im)
	for j in 1:n2
		for i in 1:n1
			temp = A[i, j]
			B[1, i, j] = convert(T, 360.0*(pi + angle(temp))/(2*pi))
			B[2, i, j] = convert(T, exp(1-max(abs(temp),1.0)))
			B[3, i, j] = convert(T, min(abs(temp),1.0))
		end
	end
	imwrite(convert(Array{RGB{T}}, reinterpret(HSV{T}, B)), Name)
end

# Convolution methods: If the input arrays are real, use the rfft and irfft methods. Otherwise, use complex fft and ifft. Works for any array rank, not just matrices. 
# Alternately, can just use the conv2 function in the Standard Library.
function Convolve{T<:Real}(A::Array{T}, B::Array{T})
	n = size(A)[1]
	return irfft(rfft(A).*rfft(B),n)
end

function Convolve(A, B)
	return ifft(fft(A).*fft(B))
end

function LorentzKernel{T<:Real}(n1::Int64, n2::Int64, width::T)
	gamma = float64(width^2)
	b1 = -iceil(n2/2)
	b2 = ifloor(n2/2)-1
	a1 = -iceil(n1/2)
	a2 = ifloor(n1/2)-1
	return [gamma/(gamma + i^2 + j^2) for i in a1:a2, j in b1:b2]
end

function Blur{T1<:Real,T2<:Real}(A::Array{T1, 2}, width::T2)
	(n1, n2) = size(A)
	return Convolve(A, LorentzKernel(n1, n2, width))
end


# Currently very basic.
function ColorizeReal{T<:Real}(A::Array{T, 2})
	(n1, n2) = size(A)
	B = zeros(Float64, n1, n2, 3)
	temp = 0.0
	for j in [1:n2]
		for i in [1:n1]
			temp = A[i, j]
			if temp >= 0
				B[i, j, :] = [temp, temp - 1, temp - 1]
			else
				B[i, j, :] = [-temp - 1, -temp - 1, -temp]
			end
		end
	end
	return B
end

function ColorizeComplex(A::Array{Complex{Float64}, 2})
	(n1, n2) = size(A);
	B = zeros(Float64, n1, n2, 3)
	temp = 0.0 + 0.0*im
	for j in 1:n2
		for i in 1:n1
			temp = A[i, j]
			B[i, j, :] = [360*(pi + angle(temp))/(2*pi), 1.0, abs(temp)]
		end
	end
	return B
end

function Endolith{T<:Real}(A::Array{T, 2})
	(n1, n2) = size(A)
	B = zeros(T, n1, n2, 3)
	temp = 0.0
	for j in 1:n2
		for i in 1:n1
			temp = A[i, j]
			if temp > 1
				B[i, j, :] = [1, 1, 0.3*(temp - 1)]
			elseif temp > 0
				B[i, j, :] = [temp*(2-temp), temp^2, 0]
			elseif temp > -1
				B[i, j, :] = [0, temp^2, -temp*(2+temp)]
			else
				B[i, j, :] = [-0.3*(1+temp), 1, 1]
			end
		end
	end
	return B
end





end #module