using Distances
using Base.Collections


function myLoop(N::Integer, dist::Vector, dist_sort::Vector)
    indices = zeros(Int64, N)
    dists = zeros(Float64, N)
    
    for j in 1:N
        for i=1:length(dist)
            if dist[i] == dist_sort[j]
                indices[j] = i
                dists[j] = dist_sort[j]
                break
            end
        end
    end
    
    return indices, dists
end

function nearest_neighbors(y::Vector, X::Matrix, N::Integer)
    dist = colwise(Euclidean(), y, X)
    dist_sort = sort(dist)

    indices, dists = myLoop(N, dist, dist_sort)
    return indices, dists
end

    
    
function nearest{T <: Real}(X::Matrix,
                            v::Vector{T},
                        k::Integer = 1,
                        exclude::Integer = -1)
  n = size(X, 2)

  if k >= n
    error("k cannot be larger than the size of the full data set")
   end

  pq = PriorityQueue{Int, Float64}(Base.Order.Reverse)
  items = 0

  for i in 1:n
    if i == exclude
      continue
    end
    d = evaluate(Euclidean(), v, X[:, i])
    if items < k
      items += 1
      enqueue!(pq, i, d)
    else
      i_max, d_max = peek(pq)
      if d < d_max
	dequeue!(pq)
	enqueue!(pq, i, d)
      end
    end
  end

  return collect(keys(pq)), collect(values(pq))
end

function majority_vote(ll, indices, dist)
    labels = ll[indices]
    uniqueLabels = unique(labels)
    highScore = 0
    score = 0
    majorLabel = uniqueLabels[1]
    for l in uniqueLabels
        score = 0
        for i=1:length(labels)
            if labels[i] == l
                score += 1
            end
        end
        if score > highScore
            highScore = score * 1
            majorLabel = l
        end
    end
    return majorLabel     
    
end
y = rand(0:0.001:10, 50);
X = rand(0:0.001:10, (50,10000));

@time inds, dists = nearest_neighbors(y, X, 5)
@time inds, dists = nearest_neighbors(y, X, 5)
@time inds, dists = nearest_neighbors(y, X, 5)
println()
@time inds, dists = nearest(X,y,5)
@time inds, dists = nearest(X,y,5)
@time inds, dists = nearest(X,y,5)
