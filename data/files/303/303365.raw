module EventWindows

using DataFrames


function intervals(
    table::DataFrame,
    index_col::Symbol,
    label_col::Symbol
    )
  sort!(table, cols=[index_col])

  out = DataFrame(
    [ eltype( table[label_col] ), Int, Int, Int ],
    [ label_col, :start, :stop, :center ],
    0 )

  by(table, label_col) do df
    label = df[1, label_col]
    push!(out, [ label, df[1, index_col], df[1, index_col], df[1, index_col] ])
    for row in 2:size(df, 1)
      index = df[row, index_col]
      if index - 1 > out[end, :stop]
        push!(out, [label, index, index, index])
      else
        out[end, :stop  ] = index
        out[end, :center] = out[end, :start] + iround( 0.5 * ( out[end, :stop] - out[end, :start] ) )
      end
    end
  end

  return out
end


function peaks!(
    intervals::DataFrame,
    table::DataFrame,
    index_col::Symbol,
    value_col::Symbol,
    label=[]
    ;
    out_col::Symbol=:peak
    )
  if !haskey(intervals, out_col)
    intervals[out_col] = Array( eltype(table[1, index_col]), size(intervals, 1) )
    fill!(intervals[out_col], NA)
  end

  for row in 1:size(intervals, 1)
    if isempty(label) || label == intervals[row, :label]
      iv = table[ intervals[row, :start] .<= table[index_col] .<= intervals[row, :stop], :]
      peakidx = iv[ indmax( iv[value_col] ), index_col ]
      intervals[row, out_col] = peakidx
    end
  end
end


function windows!(
    intervals::DataFrame,
    first_index::Integer,
    last_index::Integer,
    num_indices_before::Integer,
    num_indices_after::Integer
    ;
    num_indices_mindistance::Integer=0,
    include_interval::Bool=true,
    center_col::Symbol=:center
    )
  if include_interval
    intervals[:window_start] = [ i - num_indices_before for i in intervals[center_col] ]
    intervals[:window_stop ] = [ i + num_indices_after  for i in intervals[center_col] ]
  else
    intervals[:window_start] = [ i - num_indices_before for i in intervals[:start] ]
    intervals[:window_stop ] = [ i + num_indices_after  for i in intervals[:stop ] ]
  end

  intervals[:window_outofbounds] = outofbounds(intervals, first_index, last_index)
  intervals[:window_overlaps   ] = overlaps(intervals)
  intervals[:window_tooclose   ] = tooclose(intervals, num_indices_mindistance)
  intervals[:window_isvalid    ] = isvalid(intervals)
end


function windows!(
    intervals::DataFrame,
    first_timepoint_index::Integer,
    last_timepoint_index::Integer,
    num_seconds_before::Real,
    num_seconds_after::Real,
    sampling_sec::Real
    ;
    num_seconds_mindistance::Real=0,
    include_interval::Bool=true,
    center_col::Symbol=:center
    )
  tps_before      = iround(num_seconds_before      / sampling_sec)
  tps_after       = iround(num_seconds_after       / sampling_sec)
  tps_mindistance = iround(num_seconds_mindistance / sampling_sec)
  windows!(
    intervals,
    first_timepoint_index,
    last_timepoint_index,
    tps_before,
    tps_after,
    num_indices_mindistance=tps_mindistance,
    include_interval=include_interval,
    center_col=center_col)
end


function shifted_windows(
    intervals::DataFrame,
    first_index::Integer,
    last_index::Integer,
    num_indices_shift::Integer
    )
  out = DataFrame(
    window_start = intervals[:window_start] + num_indices_shift,
    window_stop  = intervals[:window_stop ] + num_indices_shift
    )
  out[:window_outofbounds] = outofbounds(intervals, first_index, last_index)
  out[:window_isvalid    ] = isvalid(out, Symbol[], [:window_outofbounds])
  return out
end


function shifted_windows(
    intervals::DataFrame,
    first_timepoint_index::Integer,
    last_timepoint_index::Integer,
    num_seconds_shift::Integer,
    sampling_sec::Real
    )
  tps_shift = iround(num_seconds_shift / sampling_sec)
  return shifted_windows(
    intervals,
    first_timepoint_index,
    last_timepoint_index,
    tps_shift)
end


function random_windows(
    intervals::DataFrame,
    first_index::Integer,
    last_index::Integer,
    ;
    num_indices_mindistance::Integer=0,
    max_attempts::Integer=666
    )
  valid_windows = intervals[ intervals[:window_isvalid] .== true, :]

  out = DataFrame(
    window_start = Array(Int, size(valid_windows, 1)),
    window_stop  = Array(Int, size(valid_windows, 1))
    )
  fill!(out[:window_start], NA)
  fill!(out[:window_stop ], NA)

  for row in 1:size(valid_windows, 1)
    windowsize = valid_windows[row, :window_stop] - valid_windows[row, :window_start]
    validrange = first_index:(last_index - windowsize)

    attempt = 1
    while attempt <= max_attempts
      start = rand(validrange)
      stop  = start + windowsize

      isvalid = true
      for i in 1:size(intervals, 1)
        if start <= intervals[i, :window_stop ] + num_indices_mindistance &&
            stop >= intervals[i, :window_start] - num_indices_mindistance
          isvalid = false
          break
        end
        if i < row &&
            start <= out[i, :window_stop ] + num_indices_mindistance &&
             stop >= out[i, :window_start] - num_indices_mindistance
          isvalid = false
          break
        end
      end

      if isvalid
        out[row, :window_start] = start
        out[row, :window_stop ] = stop
      end

      attempt += 1
    end
  end

  sort!(out)
  return out
end


function random_windows(
    intervals::DataFrame,
    first_timepoint_index::Integer,
    last_timepoint_index::Integer,
    sampling_sec::Real
    ;
    num_seconds_mindistance::Real=0,
    max_attempts::Integer=666
    )
  tps_mindistance = iround(num_seconds_mindistance / sampling_sec)
  random_windows(
    intervals,
    first_timepoint_index,
    last_timepoint_index,
    num_indices_mindistance=tps_mindistance,
    max_attempts=max_attempts)
end


function outofbounds(
    intervals::DataFrame,
    min_index::Integer,
    max_index::Integer,
    columns::Vector{Symbol}=[:window_start, :window_stop]
    )
  return [
    any( [ !( min_index <= intervals[row, col] <= max_index ) for col in columns ] )
    for row in 1:nrow(intervals)
    ]
end


function overlaps(
    intervals::DataFrame,
    interval_start_col::Symbol=:window_start,
    interval_stop_col::Symbol=:window_stop
    )
  if nrow(intervals) == 1
    return [ false ]
  else
    return [
      if row == 1
        intervals[row, interval_stop_col ] >= intervals[row + 1, interval_start_col]
      elseif row == nrow(intervals)
        intervals[row, interval_start_col] <= intervals[row - 1, interval_stop_col ]
      else
        intervals[row, interval_start_col] <= intervals[row - 1, interval_stop_col ] ||
        intervals[row, interval_stop_col ] >= intervals[row + 1, interval_start_col]
      end
      for row in 1:nrow(intervals)
      ]
  end
end


function overlaps(
    intervals::DataFrame,
    avoid::DataFrame,
    interval_start_col::Symbol=:window_start,
    interval_stop_col::Symbol=:window_stop
    )
  return [
    any( [ avoid[j, interval_start_col] <= intervals[i, interval_start_col] <= avoid[j, interval_stop_col] ||
           avoid[j, interval_start_col] <= intervals[i, interval_stop_col ] <= avoid[j, interval_stop_col]
           for j in 1:nrow(avoid) ] )
    for i in 1:nrow(intervals)
    ]
end


function tooclose(
    intervals::DataFrame,
    num_indices_mindistance::Integer,
    interval_start_col::Symbol=:window_start,
    interval_stop_col::Symbol=:window_stop
    )
  if nrow(intervals) == 1
    return [ false ]
  end
  return [
    if row == 1
      intervals[row, interval_stop_col ] >= intervals[row + 1, interval_start_col] - num_indices_mindistance
    elseif row == nrow(intervals)
      intervals[row, interval_start_col] <= intervals[row - 1, interval_stop_col ] + num_indices_mindistance
    else
      intervals[row, interval_start_col] <= intervals[row - 1, interval_stop_col ] + num_indices_mindistance ||
      intervals[row, interval_stop_col ] >= intervals[row + 1, interval_start_col] - num_indices_mindistance
    end
    for row in 1:nrow(intervals)
    ]
end


function isvalid(
    intervals::DataFrame,
    validating_columns::Vector{Symbol}=[],
    invalidating_columns::Vector{Symbol}=[:window_outofbounds, :window_overlaps, :window_tooclose]
    )
  return all(
    hcat( all( intervals[:,   validating_columns], 2 ),
         !any( intervals[:, invalidating_columns], 2 ) ),
    2 )
end

end # module
