#!/usr/bin/env float

###################################################
# Granular dynamics simulator by Anders Damsgaard #
###################################################

#=
Add Sphere to your julia path by:
    push!(LOAD_PATH, "~/src/julia/sphere/")

If this statement is added to `~/.juliarc.jl`, it will become persistent between
julia sessions. Note that the `~` symbol for the home folder does not seem to
work (julia v. 0.4.1) in the `.juliarc.jl` file.

Import package contents with:
    import Sphere

If this file is changed, reimport it with:
    reload("Sphere")

=#


module Sphere

# Define floating point data types
const float = Float64
const vector = Array{Float64, 1}

#export addGrain
#export getPosition

#include("vectors.jl")
#include("grain.jl")
#include("contact_search.jl")
#include("interaction.jl")


## Global arrays for general simulation data
# TODO: Variables should be local, or passed as arguments to functions whenever
# possible
g_position = vector[]
g_velocity = vector[]
g_acceleration = vector[]
g_force = vector[]

g_rotational_position = vector[]
g_rotational_velocity = vector[]
g_rotational_acceleration = vector[]
g_torque = vector[]

g_radius = float[]

g_density = float[]
g_volume = float[]
g_mass = float[]
g_rotational_inertia = float[]

g_time_iteration = 0
g_time = float
g_time_total = float
g_time_step = float
g_file_time_step = float 

g_contact_stiffness_normal = float
g_contact_stiffness_tangential = 0.0
g_contact_viscosity_normal = float
g_contact_viscosity_tangential = 0.0

g_gravitational_acceleration = zeros(3)

g_contact_pairs = Array{Integer, 1}[]
#g_positions = float[]
g_overlaps = float[]

g_simulation_id = "unnamed"


#export addSphericalGrain
"""
Adds a grain to the simulation. Example:

    Sphere.addSphericalGrain([1.0, 2.0, 3.0], 1.0)
"""
function addSphericalGrain(
    position::vector,
    radius::float = 1.0;
    velocity::vector = [0., 0., 0.],
    acceleration::vector = [0., 0., 0.],
    force::vector = [0., 0., 0.],
    rotational_position::vector = [0., 0., 0.],
    rotational_velocity::vector = [0., 0., 0.],
    rotational_acceleration::vector = [0., 0., 0.],
    torque::vector = [0., 0., 0.],
    density::float = 2600.,
    verbose::Bool = true)

    # Check input values
    if radius <= 0.0
        error("Grain radius must be greater than 0.0 (radius = $radius m)")
    elseif density <= 0.0
        error("Grain density must be greater than 0.0 (density = $density
            kg/m^3)")
    end

    # Save grain in global arrays
    push!(g_radius, radius)

    push!(g_position, position)
    push!(g_velocity, velocity)
    push!(g_acceleration, acceleration)
    push!(g_force, force)

    push!(g_rotational_position, rotational_position)
    push!(g_rotational_velocity, rotational_velocity)
    push!(g_rotational_acceleration, rotational_acceleration)
    push!(g_torque, torque)

    push!(g_density, density)
    volume = 4.0 / 3.0 * pi * radius^3.0
    push!(g_volume, volume)
    push!(g_mass, density*volume)
    push!(g_rotational_inertia, 2.0 / 5.0 * density * volume * radius^2.0)

    if verbose
        info("Added grain $(length(g_radius))")
    end
end

function removeGrain(i::Integer)
    if i < 1
        error("Grain index must be greater than 0 (i = $i)")
    end

    delete!(g_radius, i)

    delete!(g_position, i)
    delete!(g_velocity, i)
    delete!(g_acceleration, i)
    delete!(g_force, i)

    delete!(g_rotational_position, i)
    delete!(g_rotational_velocity, i)
    delete!(g_rotational_acceleration, i)
    delete!(g_torque, i)

    delete!(g_density, i)
    delete!(g_volume, i)
    delete!(g_mass, i)
    delete!(g_rotational_inertia, i)
end

## Time integration functions

"""
Find the computational time step length suitable given the grain radii, contact
stiffnesses, and grain density. Uses the scheme by Radjaii et al. 2011.
"""
function findTimeStep(epsilon::float=0.07, verbose::Bool=true)

    if length(g_radius) < 1
        error("At least 1 grain is needed to find the computational time step.")
    end

    g_time_step = epsilon / (sqrt(
        max([g_contact_stiffness_normal, g_contact_stiffness_tangential]) /
        min(g_mass)))

    if g_time_step <= 1.0e-20
        error("Time step too small or negative ($g_time_step s)")
    end

    if verbose
        info("Time step length Î”t = $g_time_step s")
    end
end

"""
Perform temporal integration for all grains.
"""
function updateKinematics()
    for i = 1:length(g_radius)
        updateGrainKinematics(i)
    end

    # Update time variables
    g_time_iteration = g_time_iteration::Integer + 1
    g_time = g_time::float + g_time_step::float

end

"""
Update the grain kinematic parameters using a temporal integration scheme,
the current force and torque balance, and gravitational acceleration.
"""
function updateGrainKinematics(i::Integer;
    method::ASCIIString = "Three-term Taylor")

    if method == "Two-term Taylor"
        updateKinematicsTwoTermTaylor(i)
    elseif method == "Three-term Taylor"
        updateKinematicsThreeTermTaylor(i)
    else
        error("Unknown integration method '$method'")
    end
end

function updateGrainKinematicsTwoTermTaylor(i::Integer)

    # Translational components
    g_acceleration[i] =
        g_force[i]::vector / g_mass[i]::vector +
        g_gravitational_acceleration::vector

    velocity_new::vector =
        g_velocity[i]::vector +
        g_acceleration[i]::vector * g_time_step::float

    g_position[i] = g_position[i]::vector +
        g_velocity[i]::vector * g_time_step::float +
        0.5 * g_acceleration[i]::vector * g_time_step::float^2.0

    g_velocity[i] = velocity_new

    # Rotational components
    g_rotational_acceleration[i] =
        g_torque[i]::vector / g_rotational_inertia[i]::vector

    rotational_velocity_new::vector =
        g_rotational_velocity[i]::vector +
        g_rotational_acceleration[i]::vector * g_time_step::float

    g_rotational_position[i] = g_rotational_position[i]::vector +
        g_rotational_velocity[i]::vector * g_time_step::float +
        0.5 * g_rotational_acceleration[i]::Array{float, 1} *
        g_time_step::float^2.0

    g_rotational_velocity[i] = rotational_velocity_new
end

function updateGrainKinematicsThreeTermTaylor(i::Integer)
    
    if g_time_iteration == 0
        acceleration_0 = zeros(3)
        rotational_acceleration_0 = zeros(3)
    else
        acceleration_0 = g_acceleration[i]::vector
        rotational_acceleration_0 = g_rotational_acceleration[i]::vector
    end

    # Temporal gradient in acceleration using backwards differences
    dacceleration_dt::vector =
            (g_acceleration[i]::vector - g_acceleration_0::vector) /
            g_time_step::float

    drotational_acceleration_dt::vector =
            (g_rotational_acceleration[i]::vector -
            g_rotational_acceleration_0::vector) /
            g_time_step::float

    # Translational components
    g_acceleration[i] = g_force[i]::vector / g_mass[i]::vector +
        g_gravitational_acceleration::vector

    velocity_new::vector =
        g_velocity[i]::vector +
        g_acceleration[i]::vector * g_time_step::float +
        0.5 * dacceleration_dt::vector * g_time_step::float^2.0

    g_position[i] = g_position[i]::vector +
        g_velocity[i]::vector * g_time_step::float +
        0.5 * g_acceleration[i]::vector * g_time_step::float^2.0 +
        1.0 / 6.0 * dacceleration_dt * g_time_step::float^3.0

    g_velocity[i] = velocity_new

    # Rotational components
    g_rotational_acceleration[i] =
        g_torque[i]::float / g_rotational_inertia[i]::float

    rotational_velocity_new::vector = g_rotational_velocity[i] +
        g_rotational_acceleration[i] * g_time_step::float +
        0.5 * drotational_acceleration_dt * g_time_step::float^2.0

    g_rotational_position[i] = g_rotational_position[i]::vector +
        g_rotational_velocity[i] * g_time_step::float +
        0.5 * g_rotational_acceleration[i] * g_time_step::float^2.0 +
        1.0 / 6.0 * drotational_acceleration_dt * g_time_step::float^3.0

    g_rotational_velocity[i] = rotational_velocity_new
end


## Interaction functions

"""
Resolve mechanical interaction between all grain pairs.
"""
function interact()
    contact_pair = Array{Integer, 1}
    overlap_ij = float
    while !isempty(g_contact_pairs)
        contact_pair = pop!(g_contact_pairs)
        interactGrains(contact_pair[1], contact_pair[2])
    end
    #for k=1:length(g_contact_pairs)
    #end
end

"""
Resolve an grain-to-grain interaction using a prescibed contact law.
"""
function interactGrains(i::Integer, j::Integer,
    overlap_vector::vector;
    contact_normal::ASCIIString = "LinearElastic")

    if contact_normal == "LinearElastic"
        interactNormalLinearViscous(i, j, overlap_vector)
    else
        error("Unknown contact_normal interaction model '$contact_normal'")
    end

end

function interactNormalLinearElastic(i::Integer, j::Integer,
    overlap_vector::vector)

    force = -g_contact_stiffness_normal * overlap_vector

    g_force[i] = g_force[i]::vector + force;
    g_force[j] = g_force[j]::vector - force;
end


## Contact mapping
function findContacts(methpd::ASCIIString = "all to all")

    if method == "all to all"
        findContactsAllToAll()
    else
        error("Unknown contact search method '$method'")
    end
end

function interGrainPositionVector(i::Integer, j::Integer)
    return g_position[j]::vector - g_position[i]::vector
end

"""
position_ij is the inter-grain position vector, and can be found with
interGrainPositionVector().
"""
function findOverlap(i::Integer, j::Integer, position_ij::vector)
    return norm(position_ij) - (g_radius[i]::float + g_radius[j]::float)
end


function findContactsAllToAll()

    for i=1:length(g_radius)
        for j=1:length(g_radius)
            if i < j

                # Inter-grain position vector and grain overlap
                position_ij = interGrainPositionVector(i, j)
                overlap_ij = findOverlap(i, j, position_ij)

                # Check if grains overlap (overlap when negative)
                if overlap < 0.0
                    push!(g_contact_pairs, [i, j])
                    #push!(g_positions, position_ij)
                    push!(g_overlaps, overlap_ij)
                end
            end
        end
    end
end

## IO functions

function writeVTK(folder::ASCIIString = '.', verbose::bool = true)

    filename = folder + "/" + g_simulation_id + ".vtu"
    if verbose
        println("Output file: $filename")
    end

    f = open(filename, "w")

    write(f, "<?xml version=\"1.0\"?>\n") # XML header
        "<VTKFile type=\"UnstructuredGrid\" version=\"0.1\" "
        "byte_order=\"LittleEndian\">\n" # VTK header
        "  <UnstructuredGrid>\n"
        "    <Piece NumberOfPoints=\"$(length(g_radius))\" "
        "NumberOfCells=\"0\">\n")

    # Coordinates for each point (positions)
    write(f, "      <Points>\n"
        "        <DataArray name=\"Position [m]\" type=\"Float32\" "
        "NumberOfComponents=\"3\" format=\"ascii\">\n"
        "          ")

    for i=1:length(g_radius)
        write(f, "%f %f %f " %
            (g_position[i,1], g_position[i,2], g_position[i,3]))

    write("\n"
        "        </DataArray>\n"
        "      </Points>\n")

    ### Data attributes
    fh.write(f, "      <PointData Scalars=\"Diameter [m]\" "
        "Vectors=\"vector\">\n")

    # Radii
    write(f, "        <DataArray type=\"Float32\" Name=\"Diameter\" "
        "format=\"ascii\">\n"
        "          ")
    for i=1:length(g_radius)
        write(f, "%f " % (self.radius[i]*2.0))
    write(f, "\n"
        "        </DataArray>\n")

    # Footer
    write(f, "      </PointData>\n"
        "      <Cells>\n"
        "        <DataArray type=\"Int32\" Name=\"connectivity\" "
        "format=\"ascii\">\n"
        "        </DataArray>\n"
        "        <DataArray type=\"Int32\" Name=\"offsets\" format=\"ascii\">\n"
        "        </DataArray>\n"
        "        <DataArray type=\"UInt8\" Name=\"types\" format=\"ascii\">\n"
        "        </DataArray>\n"
        "      </Cells>\n"
        "    </Piece>\n"
        "  </UnstructuredGrid>\n"
        "</VTKFile>")

    close(f)
end

end # module end
