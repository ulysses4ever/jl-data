#!/usr/bin/env julia

###################################################
# Granular dynamics simulator by Anders Damsgaard #
###################################################

#=
Add Sphere to your julia path by:
    push!(LOAD_PATH, "~/src/julia/sphere/")

If this statement is added to `~/.juliarc.jl`, it will become persistent between
julia sessions. Note that the `~` symbol for the home folder does not seem to
work (julia v. 0.4.1) in the `.juliarc.jl` file.

Import package contents with:
    import Sphere

=#


module Sphere

#export addGrain
#export getPosition

#include("vectors.jl")
#include("grain.jl")
#include("contact_search.jl")
#include("interaction.jl")


## Global arrays for general simulation data
g_position = Array{Float64, 1}[]
g_velocity = Array{Float64, 1}[]
g_acceleration = Array{Float64, 1}[]
g_force = Array{Float64, 1}[]

g_rotational_position = Array{Float64, 1}[]
g_rotational_velocity = Array{Float64, 1}[]
g_rotational_acceleration = Array{Float64, 1}[]
g_torque = Array{Float64, 1}[]

g_radius = Float64[]

g_density = Float64[]
g_volume = Float64[]
g_mass = Float64[]
g_rotational_inertia = Float64[]

g_time = Float64
g_time_total = Float64
g_time_step = Float64
g_file_time_step = Float64 


## Functions to create and delete grains, and set and retrieve their parameter
## values
"""
Adds a grain to the simulation. Example:

    Sphere.addSphericalGrain([1.0, 2.0, 3.0], 1.0)
"""
function addSphericalGrain(;
    position::Array{Float64, 1},
    radius::Float64 = 1.0,
    velocity::Array{Float64, 1} = [0., 0., 0.],
    acceleration::Array{Float64, 1} = [0., 0., 0.],
    force::Array{Float64, 1} = [0., 0., 0.],
    rotational_position::Array{Float64, 1} = [0., 0., 0.],
    rotational_velocity::Array{Float64, 1} = [0., 0., 0.],
    rotational_acceleration::Array{Float64, 1} = [0., 0., 0.],
    torque::Array{Float64, 1} = [0., 0., 0.],
    density::Float64 = 2600.,
    verbose::Bool = true)

    # Check input values
    if radius <= 0.0
        error("Grain radius must be greater than 0.0 (radius = $(radius) m)")
    elseif density <= 0.0
        error("Grain density must be greater than 0.0 (density = $(density)
        kg/m^3)")
    end

    # Save grain in global arrays
    push!(g_radius, radius)

    push!(g_position, position)
    push!(g_velocity, velocity)
    push!(g_acceleration, acceleration)
    push!(g_force, force)

    push!(g_rotational_position, rotational_position)
    push!(g_rotational_velocity, rotational_velocity)
    push!(g_rotational_acceleration, rotational_acceleration)
    push!(g_torque, torque)

    push!(g_density, density)
    volume = 4.0/3.0*pi*radius^3.0
    push!(g_volume, volume)
    push!(g_mass, density*volume)
    push!(g_rotational_inertia, 0.0) # TODO

    if verbose
        info("Added grain $(length(g_radius))")
    end
end

function removeGrain(i::Int)
    if i < 1
        error("Grain index must be greater than 0 (i = $(i))")
    end

    delete!(g_radius, i)

    delete!(g_position, i)
    delete!(g_velocity, i)
    delete!(g_acceleration, i)
    delete!(g_force, i)

    delete!(g_rotational_position, i)
    delete!(g_rotational_velocity, i)
    delete!(g_rotational_acceleration, i)
    delete!(g_torque, i)

    delete!(g_density, i)
    delete!(g_volume, i)
    delete!(g_mass, i)
    delete!(g_rotational_inertia, i)
end

## Time integration functions
function updateKinematics(i::Int; method::ASCIIString = "TwoTermTaylor")
    if method == "TwoTermTaylor"
        updateKinematicsTwoTermTaylor(i)
    end
end

function updateKinematicsTwoTermTaylor(i::Int)

    # Translational components
    g_acceleration[i] = g_force[i]/g_mass[i]

    velocity_new::Array{Float64, 2} =
        g_velocity[i] + g_acceleration[i]*g_time_step

    g_position += g_velocity[i]*g_time_step
        + 0.5*g_acceleration[i]*g_time_step^2

    g_velocity[i] = velocity_new

    # Rotational components
    g_rotational_acceleration[i] = g_torque[i]/g_rotational_inertia[i]

    rotational_velocity_new::Array{Float64, 2} =
        g_rotational_velocity[i] + g_rotational_acceleration[i]*g_time_step

    g_rotational_position += g_rotational_velocity[i]*g_time_step
        + 0.5*g_rotational_acceleration[i]*g_time_step^2

    g_rotational_velocity[i] = rotational_velocity_new
end



end # module end
