#!/usr/bin/env julia

###################################################
# Granular dynamics simulator by Anders Damsgaard #
###################################################

#=
Add Sphere to your julia path by:
    push!(LOAD_PATH, "~/src/julia/sphere/")

If this statement is added to `~/.juliarc.jl`, it will become persistent between
julia sessions. Note that the `~` symbol for the home folder does not seem to
work (julia v. 0.4.1) in the `.juliarc.jl` file.

Import package contents with:
    import Sphere

If this file is changed, reimport it with:
    reload("Sphere")

=#


module Sphere

# Define floating point data types
const float = Float64
const vector = Array{Float64, 1}

#export addGrain
#export getPosition

#include("vectors.jl")
#include("grain.jl")
#include("contact_search.jl")
#include("interaction.jl")


## Global arrays for general simulation data
# TODO: Variables should be local, or passed as arguments to functions whenever
# possible
g_position = vector[]
g_velocity = vector[]
g_acceleration = vector[]
g_force = vector[]

g_rotational_position = vector[]
g_rotational_velocity = vector[]
g_rotational_acceleration = vector[]
g_torque = vector[]

g_radius = float[]

g_density = float[]
g_volume = float[]
g_mass = float[]
g_rotational_inertia = float[]

g_time_iteration = 0
g_time = float
g_time_total = float
g_time_step = float
g_file_time_step = float 

g_contact_stiffness_normal = float
g_contact_stiffness_tangential = float
g_contact_viscosity_normal = float
g_contact_viscosity_tangential = float



#export addSphericalGrain
"""
Adds a grain to the simulation. Example:

    Sphere.addSphericalGrain([1.0, 2.0, 3.0], 1.0)
"""
function addSphericalGrain(
    position::vector,
    radius::float = 1.0;
    velocity::vector = [0., 0., 0.],
    acceleration::vector = [0., 0., 0.],
    force::vector = [0., 0., 0.],
    rotational_position::vector = [0., 0., 0.],
    rotational_velocity::vector = [0., 0., 0.],
    rotational_acceleration::vector = [0., 0., 0.],
    torque::vector = [0., 0., 0.],
    density::float = 2600.,
    verbose::Bool = true)

    # Check input values
    if radius <= 0.0
        error("Grain radius must be greater than 0.0 (radius = $radius m)")
    elseif density <= 0.0
        error("Grain density must be greater than 0.0 (density = $density
            kg/m^3)")
    end

    # Save grain in global arrays
    push!(g_radius, radius)

    push!(g_position, position)
    push!(g_velocity, velocity)
    push!(g_acceleration, acceleration)
    push!(g_force, force)

    push!(g_rotational_position, rotational_position)
    push!(g_rotational_velocity, rotational_velocity)
    push!(g_rotational_acceleration, rotational_acceleration)
    push!(g_torque, torque)

    push!(g_density, density)
    volume = 4.0/3.0*pi*radius^3.0
    push!(g_volume, volume)
    push!(g_mass, density*volume)
    push!(g_rotational_inertia, 2.0/5.0*m*radius^2.0)

    if verbose
        info("Added grain $(length(g_radius))")
    end
end

function removeGrain(i::Integer)
    if i < 1
        error("Grain index must be greater than 0 (i = $i)")
    end

    delete!(g_radius, i)

    delete!(g_position, i)
    delete!(g_velocity, i)
    delete!(g_acceleration, i)
    delete!(g_force, i)

    delete!(g_rotational_position, i)
    delete!(g_rotational_velocity, i)
    delete!(g_rotational_acceleration, i)
    delete!(g_torque, i)

    delete!(g_density, i)
    delete!(g_volume, i)
    delete!(g_mass, i)
    delete!(g_rotational_inertia, i)
end

## Time integration functions
function updateKinematics()
    for i = 1:length(g_radius)
        updateGrainKinematics(i)
    end

    # TODO update time variables
    # g_time_iteration += 1
    # g_time += g_time_step

end

function updateGrainKinematics(i::Integer; method::ASCIIString = "TwoTermTaylor")
    if method == "TwoTermTaylor"
        updateKinematicsTwoTermTaylor(i)
    end
end

function updateGrainKinematicsTwoTermTaylor(i::Integer)

    # Translational components
    g_acceleration[i] =
        g_force[i]::vector / g_mass[i]::vector

    velocity_new::vector =
        (g_velocity[i]::vector
        + g_acceleration[i]::vector * g_time_step::float)

    g_position[i] = (g_position[i]::vector
        + g_velocity[i]::vector * g_time_step::float
        + 0.5 * g_acceleration[i]::vector * g_time_step::float^2.0)

    g_velocity[i] = velocity_new

    # Rotational components
    g_rotational_acceleration[i] =
        (g_torque[i]::vector / g_rotational_inertia[i]::vector)

    rotational_velocity_new::vector =
        (g_rotational_velocity[i]::vector
        + g_rotational_acceleration[i]::vector * g_time_step::float)

    g_rotational_position[i] = (g_rotational_position[i]::vector
        + g_rotational_velocity[i]::vector * g_time_step::float
        + 0.5 * g_rotational_acceleration[i]::Array{float, 1}
        * g_time_step::float^2.0)

    g_rotational_velocity[i] = rotational_velocity_new
end

function updateGrainKinematicsThreeTermTaylor(i::Integer)
    
    if g_time_iteration == 0
        acceleration_0 = zeros(3)
        rotational_acceleration_0 = zeros(3)
    else
        acceleration_0 = g_acceleration[i]::vector
        rotational_acceleration_0 =
            g_rotational_acceleration[i]::vector
    end

    # Temporal gradient in acceleration using backwards differences
    dacceleration_dt::vector =
            ((g_acceleration[i]::vector -
            g_acceleration_0::vector) / g_time_step::float)

    drotational_acceleration_dt::vector =
            ((g_rotational_acceleration[i]::vector -
            g_rotational_acceleration_0::vector)
            / g_time_step::float)

    # Translational components
    g_acceleration[i] = 
        g_force[i]::vector / g_mass[i]::vector

    velocity_new::vector =
        (g_velocity[i]::vector
        + g_acceleration[i]::vector * g_time_step::float
        + 0.5 * dacceleration_dt::vector * g_time_step::float^2.0)

    g_position[i] = (g_position[i]::vector
        + g_velocity[i]::vector * g_time_step::float 
        + 0.5 * g_acceleration[i]::vector * g_time_step::float^2.0
        + 1.0/6.0 * dacceleration_dt * g_time_step::float^3.0)

    g_velocity[i] = velocity_new

    # Rotational components
    g_rotational_acceleration[i] =
        g_torque[i]::float / g_rotational_inertia[i]::float

    rotational_velocity_new::vector = (g_rotational_velocity[i]
        + g_rotational_acceleration[i] * g_time_step::float
        + 0.5 * drotational_acceleration_dt * g_time_step::float^2.0)

    g_rotational_position[i] = (g_rotational_position[i]::vector
        + g_rotational_velocity[i] * g_time_step::float
        + 0.5 * g_rotational_acceleration[i] * g_time_step::float^2.0
        + 1.0/6.0 * drotational_acceleration_dt * g_time_step::float^3.0)

    g_rotational_velocity[i] = rotational_velocity_new
end

## Interaction functions

"""
Resolve an grain-to-grain interaction using a prescibed contact law.
"""
function interact(i::Integer, j::Integer;
    contact_normal::ASCIIString = "LinearViscous")

    if contact_normal == "LinearViscous"
        interactNormalLinearViscous(i, j)
    end

end

function interactNormalLinearViscous(i::Integer, j::Integer,
    overlap_distance::float,
    overlap_vector::vector)

    # TODO
    force = zeros(3)


    g_force[i] = g_force[i]::vector + force;

end

end # module end
